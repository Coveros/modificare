<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
redupr.SetCover
</title>
<link href="prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="prettify.js"></script>
</head>
<body onload="prettyPrint()">
<h2>Javalanche report for class:<br/> redupr.SetCover </h2><pre class="prettyprint" style="border: 1px solid #888;padding: 2px"><span class="nocode"><a name="1">  1: </a></span>/*---------------------------------------------------------------------
<span class="nocode"><a name="2">  2: </a></span> *  File: $Id: SetCover.java,v 1.46 2007/03/10 21:02:22 gkapfham Exp $   
<span class="nocode"><a name="3">  3: </a></span> *  Version:  $Revision: 1.46 $
<span class="nocode"><a name="4">  4: </a></span> *
<span class="nocode"><a name="5">  5: </a></span> *  Project: DIATOMS, Database drIven Application Testing tOol ModuleS
<span class="nocode"><a name="6">  6: </a></span> *
<span class="nocode"><a name="7">  7: </a></span> *--------------------------------------------------------------------*/
<span class="nocode"><a name="8">  8: </a></span>
<span class="nocode"><a name="9">  9: </a></span>
<span class="nocode"><a name="10"> 10: </a></span>/*   The following methods were commented out by Adam M. Smith to 
<span class="nocode"><a name="11"> 11: </a></span> *   removed Mathematica dependencies.
<span class="nocode"><a name="12"> 12: </a></span> *
<span class="nocode"><a name="13"> 13: </a></span> *   public double getHarmonicNumberBound(boolean useTMax)
<span class="nocode"><a name="14"> 14: </a></span> *   
<span class="nocode"><a name="15"> 15: </a></span> *   public Set reduceUsingRandom(int desiredReductionSize,
<span class="nocode"><a name="16"> 16: </a></span> *				 int desiredReductions)
<span class="nocode"><a name="17"> 17: </a></span> *
<span class="nocode"><a name="18"> 18: </a></span> *   public Set prioritizeUsingRandom(int desiredPermutations)
<span class="nocode"><a name="19"> 19: </a></span> *   
<span class="nocode"><a name="20"> 20: </a></span> *   public SetCover deriveWorstCase()
<span class="nocode"><a name="21"> 21: </a></span> */
<span class="nocode"><a name="22"> 22: </a></span>
<span class="nocode"><a name="23"> 23: </a></span>package redupr;
<span class="nocode"><a name="24"> 24: </a></span>
<span class="nocode"><a name="25"> 25: </a></span>import java.util.Set;
<span class="nocode"><a name="26"> 26: </a></span>import java.util.HashSet;
<span class="nocode"><a name="27"> 27: </a></span>import java.util.HashMap;
<span class="nocode"><a name="28"> 28: </a></span>import java.util.LinkedHashSet;
<span class="nocode"><a name="29"> 29: </a></span>import java.util.LinkedHashMap;
<span class="nocode"><a name="30"> 30: </a></span>import java.util.Iterator;
<span class="nocode"><a name="31"> 31: </a></span>import java.util.Random;
<span class="nocode"><a name="32"> 32: </a></span>import java.util.ArrayList;
<span class="nocode"><a name="33"> 33: </a></span>import java.util.Collections;
<span class="nocode"><a name="34"> 34: </a></span>import java.util.Comparator;
<span class="nocode"><a name="35"> 35: </a></span>import java.util.ConcurrentModificationException;
<span class="nocode"><a name="36"> 36: </a></span>import java.util.*;
<span class="nocode"><a name="37"> 37: </a></span>
<span class="nocode"><a name="38"> 38: </a></span>import java.util.regex.Pattern;
<span class="nocode"><a name="39"> 39: </a></span>import java.util.regex.Matcher;
<span class="nocode"><a name="40"> 40: </a></span>
<span class="nocode"><a name="41"> 41: </a></span>import java.lang.Cloneable;
<span class="nocode"><a name="42"> 42: </a></span>
<span class="nocode"><a name="43"> 43: </a></span>import java.io.Serializable;
<span class="nocode"><a name="44"> 44: </a></span>import java.io.IOException;
<span class="nocode"><a name="45"> 45: </a></span>import java.io.ByteArrayInputStream;
<span class="nocode"><a name="46"> 46: </a></span>import java.io.ByteArrayOutputStream;
<span class="nocode"><a name="47"> 47: </a></span>import java.io.ObjectOutputStream;
<span class="nocode"><a name="48"> 48: </a></span>import java.io.ObjectInputStream; 
<span class="nocode"><a name="49"> 49: </a></span>import java.io.File;
<span class="nocode"><a name="50"> 50: </a></span>import java.io.InputStream;
<span class="nocode"><a name="51"> 51: </a></span>import java.io.FileInputStream;
<span class="nocode"><a name="52"> 52: </a></span>
<span class="nocode"><a name="53"> 53: </a></span>//import com.thoughtworks.xstream.XStream;
<span class="nocode"><a name="54"> 54: </a></span>
<span class="nocode"><a name="55"> 55: </a></span>// Commented out by Adam Smith
<span class="nocode"><a name="56"> 56: </a></span>//import com.wolfram.jlink.*;
<span class="nocode"><a name="57"> 57: </a></span>
<span class="nocode"><a name="58"> 58: </a></span>/**
<span class="nocode"><a name="59"> 59: </a></span> *  This class represents an instance of the SetCover problem.
<span class="nocode"><a name="60"> 60: </a></span> *  This instance is the dual of the HittingSet instance.
<span class="nocode"><a name="61"> 61: </a></span> *
<span class="nocode"><a name="62"> 62: </a></span> *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="63"> 63: </a></span> */
<span class="nocode"><a name="64"> 64: </a></span>
<span class="nocode"><a name="65"> 65: </a></span>public class SetCover implements Cloneable, Serializable
<span class="nocode"><a name="66"> 66: </a></span>{
<span class="nocode"><a name="67"> 67: </a></span>
<span class="nocode"><a name="68"> 68: </a></span>    /** The dual of the subsets of the HittingSet (i.e., S in
<span class="nocode"><a name="69"> 69: </a></span>      HittingSet). This represents all of the different Requirement
<span class="nocode"><a name="70"> 70: </a></span>      Subsets that were inside of the HittingSet instance. -- U -- */
<span class="nocode"><a name="71"> 71: </a></span>    private LinkedHashSet requirementSubsetUniverse;
<span class="nocode"><a name="72"> 72: </a></span>    //private Set requirementSubsetUniverse;
<span class="nocode"><a name="73"> 73: </a></span>
<span class="nocode"><a name="74"> 74: </a></span>    /** The dual of the universe of the HittingSet (i.e., U in the
<span class="nocode"><a name="75"> 75: </a></span>	HittingSet).  This represents all of the different subsets 
<span class="nocode"><a name="76"> 76: </a></span>	as they correspond to what the SingleTests actually hit. 
<span class="nocode"><a name="77"> 77: </a></span>	-- S -- */
<span class="nocode"><a name="78"> 78: </a></span>    private LinkedHashSet testSubsets;
<span class="nocode"><a name="79"> 79: </a></span>    //private Set testSubsets;
<span class="nocode"><a name="80"> 80: </a></span>
<span class="nocode"><a name="81"> 81: </a></span>    /** The number of times that the outerWhile was executed */
<span class="nocode"><a name="82"> 82: </a></span>    private int outerWhileExecute;
<span class="nocode"><a name="83"> 83: </a></span>
<span class="nocode"><a name="84"> 84: </a></span>    /** A listing of the number of times that the outerWhile was
<span class="nocode"><a name="85"> 85: </a></span>	executed in reduction when we are performing
<span class="nocode"><a name="86"> 86: </a></span>	prioritization! */
<span class="nocode"><a name="87"> 87: </a></span>    private ArrayList outerWhileExecuteList;
<span class="nocode"><a name="88"> 88: </a></span>
<span class="nocode"><a name="89"> 89: </a></span>    /** keep track of the number of times that we execute the 
<span class="nocode"><a name="90"> 90: </a></span>      outer while loop of the prioritization algorithm */
<span class="nocode"><a name="91"> 91: </a></span>    private int outerWhileExecutePrioritization;
<span class="nocode"><a name="92"> 92: </a></span>
<span class="nocode"><a name="93"> 93: </a></span>    /** The Set that includes all of the SingleTestSubsets inside
<span class="nocode"><a name="94"> 94: </a></span>	of the reduced test suite */
<span class="nocode"><a name="95"> 95: </a></span>    private LinkedHashSet reducedSingleTestSubsets;
<span class="nocode"><a name="96"> 96: </a></span>    //private Set reducedSingleTestSubsets;
<span class="nocode"><a name="97"> 97: </a></span>
<span class="nocode"><a name="98"> 98: </a></span>    /** This is the instance of the SetCover that existed before 
<span class="nocode"><a name="99"> 99: </a></span>	the reduction was performed */
<span class="nocode"><a name="100">100: </a></span>    private SetCover beforeReduction;
<span class="nocode"><a name="101">101: </a></span>
<span class="nocode"><a name="102">102: </a></span>    /** This is the random number generator that is set with a default
<span class="nocode"><a name="103">103: </a></span>	seed in order to ensure repeatable results */
<span class="nocode"><a name="104">104: </a></span>    private Random randomizer;
<span class="nocode"><a name="105">105: </a></span>
<span class="nocode"><a name="106">106: </a></span>    /** The default seed for the random number generator */
<span class="nocode"><a name="107">107: </a></span>    public static final long DEFAULT_SEED = 4160;
<span class="nocode"><a name="108">108: </a></span>
<span class="nocode"><a name="109">109: </a></span>    /** The cost of the last test case */
<span class="nocode"><a name="110">110: </a></span>    private static final double LAST_TEST_COST = 1.0;
<span class="nocode"><a name="111">111: </a></span>
<span class="nocode"><a name="112">112: </a></span>    /** The numerator of the effectiveness fractions */
<span class="nocode"><a name="113">113: </a></span>    private static final double NUMERATOR_EFFECTIVE = 1.0;
<span class="nocode"><a name="114">114: </a></span>
<span class="nocode"><a name="115">115: </a></span>    /** The cost of a test case that does not cover anything */
<span class="nocode"><a name="116">116: </a></span>    private static final int NO_COVER_COST = Integer.MAX_VALUE;
<span class="nocode"><a name="117">117: </a></span>
<span class="nocode"><a name="118">118: </a></span>    /** The time that was required to execute the reduction
<span class="nocode"><a name="119">119: </a></span>     algorithm by itself */
<span class="nocode"><a name="120">120: </a></span>    private long reductionTime;
<span class="nocode"><a name="121">121: </a></span>
<span class="nocode"><a name="122">122: </a></span>    /** The time that was required to execute the prioritization
<span class="nocode"><a name="123">123: </a></span>     algorithm */
<span class="nocode"><a name="124">124: </a></span>    private long prioritizationTime;
<span class="nocode"><a name="125">125: </a></span>
<span class="nocode"><a name="126">126: </a></span>    /** The seed that we should use for randomizer */
<span class="nocode"><a name="127">127: </a></span>    public static long chosenSeed;
<span class="nocode"><a name="128">128: </a></span>
<span class="nocode"><a name="129">129: </a></span>    /**
<span class="nocode"><a name="130">130: </a></span>     *  Default constructor that initializes all sets to the empty set.
<span class="nocode"><a name="131">131: </a></span>     *  
<span class="nocode"><a name="132">132: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="133">133: </a></span>     */
<span class="nocode"><a name="134">134: </a></span>    public SetCover()
<span class="nocode"><a name="135">135: </a></span>    {
<span class="nocode"><a name="136">136: </a></span>
<span class="nocode"><a name="137">137: </a></span>	requirementSubsetUniverse = new LinkedHashSet();
<span class="nocode"><a name="138">138: </a></span>	testSubsets = new LinkedHashSet();
<span class="nocode"><a name="139">139: </a></span>	reducedSingleTestSubsets = new LinkedHashSet();
<span class="nocode"><a name="140">140: </a></span>	randomizer = new Random(DEFAULT_SEED);
<span class="nocode"><a name="141">141: </a></span>
<span class="nocode"><a name="142">142: </a></span>	outerWhileExecute = 0;
<span class="nocode"><a name="143">143: </a></span>	outerWhileExecutePrioritization = 0;
<span class="nocode"><a name="144">144: </a></span>	outerWhileExecuteList = new ArrayList();
<span class="nocode"><a name="145">145: </a></span>
<span class="nocode"><a name="146">146: </a></span>	reductionTime = (long)0;
<span class="nocode"><a name="147">147: </a></span>	prioritizationTime = (long)0;
<span class="nocode"><a name="148">148: </a></span>
<span class="nocode"><a name="149">149: </a></span>// 	requirementSubsetUniverse = 
<span class="nocode"><a name="150">150: </a></span>// 	    Collections.synchronizedSet(new LinkedHashSet());
<span class="nocode"><a name="151">151: </a></span>// 	testSubsets = 
<span class="nocode"><a name="152">152: </a></span>// 	    Collections.synchronizedSet(new LinkedHashSet());
<span class="nocode"><a name="153">153: </a></span>// 	reducedSingleTestSubsets =
<span class="nocode"><a name="154">154: </a></span>// 	    Collections.synchronizedSet(new LinkedHashSet());
<span class="nocode"><a name="155">155: </a></span>
<span class="nocode"><a name="156">156: </a></span>    }
<span class="nocode"><a name="157">157: </a></span>
<span class="nocode"><a name="158">158: </a></span>    /**
<span class="nocode"><a name="159">159: </a></span>     *  Returns the SetCover instance that existed before the
<span class="nocode"><a name="160">160: </a></span>     *  reduction was performed.
<span class="nocode"><a name="161">161: </a></span>     *  
<span class="nocode"><a name="162">162: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="163">163: </a></span>     */
<span class="nocode"><a name="164">164: </a></span>    public SetCover getBeforeReduction()
<span class="nocode"><a name="165">165: </a></span>    {
<span class="nocode"><a name="166">166: </a></span>
<span class="nocode"><a name="167">167: </a></span>	return beforeReduction;
<span class="nocode"><a name="168">168: </a></span>
<span class="nocode"><a name="169">169: </a></span>    }
<span class="nocode"><a name="170">170: </a></span>    
<span class="nocode"><a name="171">171: </a></span>   /**
<span class="nocode"><a name="172">172: </a></span>     *  Set the SetCover instance that existed before the reduction
<span class="nocode"><a name="173">173: </a></span>     *  was performed.  Can be used before running the reduction
<span class="nocode"><a name="174">174: </a></span>     *  algorithm and also for the purposes of testing.
<span class="nocode"><a name="175">175: </a></span>     *  
<span class="nocode"><a name="176">176: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="177">177: </a></span>     */
<span class="nocode"><a name="178">178: </a></span>    public void setBeforeReduction(SetCover cover)
<span class="nocode"><a name="179">179: </a></span>    {
<span class="nocode"><a name="180">180: </a></span>
<span class="nocode"><a name="181">181: </a></span>	beforeReduction = cover;
<span class="nocode"><a name="182">182: </a></span>
<span class="nocode"><a name="183">183: </a></span>    }
<span class="nocode"><a name="184">184: </a></span>
<span class="nocode"><a name="185">185: </a></span>    /**
<span class="nocode"><a name="186">186: </a></span>     *  @author Gregory M. Kapfhammer 3/7/2007
<span class="nocode"><a name="187">187: </a></span>     */
<span class="nocode"><a name="188">188: </a></span>    public long getReductionTime()
<span class="nocode"><a name="189">189: </a></span>    {
<span class="nocode"><a name="190">190: </a></span>
<span class="nocode"><a name="191">191: </a></span>	return reductionTime;
<span class="nocode"><a name="192">192: </a></span>
<span class="nocode"><a name="193">193: </a></span>    }
<span class="nocode"><a name="194">194: </a></span>
<span class="nocode"><a name="195">195: </a></span>    /**
<span class="nocode"><a name="196">196: </a></span>     *  @author Gregory M. Kapfhammer 3/7/2007
<span class="nocode"><a name="197">197: </a></span>     */
<span class="nocode"><a name="198">198: </a></span>    public long getPrioritizationTime()
<span class="nocode"><a name="199">199: </a></span>    {
<span class="nocode"><a name="200">200: </a></span>
<span class="nocode"><a name="201">201: </a></span>	return prioritizationTime;
<span class="nocode"><a name="202">202: </a></span>
<span class="nocode"><a name="203">203: </a></span>    }
<span class="nocode"><a name="204">204: </a></span>
<span class="nocode"><a name="205">205: </a></span>    /**
<span class="nocode"><a name="206">206: </a></span>     *  Constructs a SetCover instance from a LinkedHashSet of 
<span class="nocode"><a name="207">207: </a></span>     *  SingleTestSubsets.  This method might not be directly useful
<span class="nocode"><a name="208">208: </a></span>     *  during experimentation.  
<span class="nocode"><a name="209">209: </a></span>     *  
<span class="nocode"><a name="210">210: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="211">211: </a></span>     */
<span class="nocode"><a name="212">212: </a></span>    public static SetCover constructSetCover(LinkedHashSet answer)
<span class="nocode"><a name="213">213: </a></span>    {
<span class="nocode"><a name="214">214: </a></span>
<span class="nocode"><a name="215">215: </a></span>	SetCover cover = new SetCover();
<span class="nocode"><a name="216">216: </a></span>
<span class="nocode"><a name="217">217: </a></span>	// go through all of the SingleTestSubsets and add in the 
<span class="nocode"><a name="218">218: </a></span>	// tests and the Requirements
<span class="nocode"><a name="219">219: </a></span>	Iterator answerIterator = answer.iterator();
<span class="nocode"><a name="220">220: </a></span>	while( answerIterator.hasNext() )
<span class="nocode"><a name="221">221: </a></span>	    {
<span class="nocode"><a name="222">222: </a></span>
<span class="nocode"><a name="223">223: </a></span>		// extract the currentTestSubset from the iterator
<span class="nocode"><a name="224">224: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="225">225: </a></span>		    (SingleTestSubset) answerIterator.next();
<span class="nocode"><a name="226">226: </a></span>
<span class="nocode"><a name="227">227: </a></span>		// add in the SingleTestSubset
<span class="nocode"><a name="228">228: </a></span>		cover.addSingleTestSubset(currentTestSubset);
<span class="nocode"><a name="229">229: </a></span>
<span class="nocode"><a name="230">230: </a></span>		// add in the requirementSubset to the Universe
<span class="nocode"><a name="231">231: </a></span>		cover.
<span class="nocode"><a name="232">232: </a></span>		    addToRequirementSubsetUniverse(currentTestSubset.
<span class="nocode"><a name="233">233: </a></span>						   getRequirementSubsetSet());
<span class="nocode"><a name="234">234: </a></span>
<span class="nocode"><a name="235">235: </a></span>	    }
<span class="nocode"><a name="236">236: </a></span>
<span class="nocode"><a name="237">237: </a></span>	return cover;
<span class="nocode"><a name="238">238: </a></span>
<span class="nocode"><a name="239">239: </a></span>    }
<span class="nocode"><a name="240">240: </a></span>
<span class="nocode"><a name="241">241: </a></span>	/**
<span class="nocode"><a name="242">242: </a></span>	 *	Checks to see if the given LinkedHashSet of SingleTests 
<span class="nocode"><a name="243">243: </a></span>	 * covers the requirementSubsetUnivers
<span class="nocode"><a name="244">244: </a></span>	 *
<span class="nocode"><a name="245">245: </a></span>	 * @author Adam M. Smith
<span class="nocode"><a name="246">246: </a></span>	 */
<span class="nocode"><a name="247">247: </a></span>	 
<span class="nocode"><a name="248">248: </a></span>	 public boolean coversRequirementSubsetUniverse(LinkedHashSet tests)
<span class="nocode"><a name="249">249: </a></span>	 {
<span class="nocode"><a name="250">250: </a></span>	 	Iterator testIterator = tests.iterator();
<span class="nocode"><a name="251">251: </a></span>	 	
<span class="nocode"><a name="252">252: </a></span>	 	LinkedHashSet requirements = new LinkedHashSet();
<span class="nocode"><a name="253">253: </a></span>	 	
<span class="nocode"><a name="254">254: </a></span>	 	requirements.addAll(requirementSubsetUniverse);
<span class="nocode"><a name="255">255: </a></span>	 	
<span class="nocode"><a name="256">256: </a></span>	 	while(testIterator.hasNext())
<span class="nocode"><a name="257">257: </a></span>	 	{
<span class="nocode"><a name="258">258: </a></span>	 		SingleTestSubset currentSingleTestSubset = getSingleTestSubsetFromSingleTest((SingleTest)testIterator.next());
<span class="nocode"><a name="259">259: </a></span>	 		
<span class="nocode"><a name="260">260: </a></span>	 		Iterator coveredRequirementsIterator = currentSingleTestSubset.getRequirementSubsetSet().iterator();
<span class="nocode"><a name="261">261: </a></span>	 		
<span class="nocode"><a name="262">262: </a></span>	 		while(coveredRequirementsIterator.hasNext())
<span class="nocode"><a name="263">263: </a></span>	 		{
<span class="nocode"><a name="264">264: </a></span>	 			RequirementSubset currentRS = (RequirementSubset)coveredRequirementsIterator.next();
<span class="nocode"><a name="265">265: </a></span>	 			if(requirements.contains(currentRS))
<span class="nocode"><a name="266">266: </a></span>	 				requirements.remove(currentRS);
<span class="nocode"><a name="267">267: </a></span>	 		}
<span class="nocode"><a name="268">268: </a></span>	 	}
<span class="nocode"><a name="269">269: </a></span>	 	
<span class="nocode"><a name="270">270: </a></span>	 	if(requirements.size() == 0)
<span class="nocode"><a name="271">271: </a></span>	 		return true;
<span class="nocode"><a name="272">272: </a></span>	 	
<span class="nocode"><a name="273">273: </a></span>	 	else
<span class="nocode"><a name="274">274: </a></span>	 		return false;
<span class="nocode"><a name="275">275: </a></span>	 		 	
<span class="nocode"><a name="276">276: </a></span>	 }
<span class="nocode"><a name="277">277: </a></span>
<span class="nocode"><a name="278">278: </a></span>
<span class="nocode"><a name="279">279: </a></span>	/*----------------------------------------------------------------------
<span class="nocode"><a name="280">280: </a></span>	* This method takes a SingleTest object and returns the corresponding
<span class="nocode"><a name="281">281: </a></span>	* SingleTestSubject object
<span class="nocode"><a name="282">282: </a></span>	*--------------------------------------------------------------------*/
<span class="nocode"><a name="283">283: </a></span>	private SingleTestSubset getSingleTestSubsetFromSingleTest(SingleTest test) {
<span class="nocode"><a name="284">284: </a></span>		// Extract an iterator for the testSubsets
<span class="nocode"><a name="285">285: </a></span>		Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="286">286: </a></span>	
<span class="nocode"><a name="287">287: </a></span>		// While there are more TestSubsets...
<span class="nocode"><a name="288">288: </a></span>		while (testSubsetsIterator.hasNext()) {
<span class="nocode"><a name="289">289: </a></span>			// Get the current SingleTestSubset
<span class="nocode"><a name="290">290: </a></span>			SingleTestSubset currentSingleTestSubset = 
<span class="nocode"><a name="291">291: </a></span>				(SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="292">292: </a></span>							
<span class="nocode"><a name="293">293: </a></span>			// Get the SingleTest object that corresponds to the 
<span class="nocode"><a name="294">294: </a></span>			// currentSingleTestSubset object
<span class="nocode"><a name="295">295: </a></span>			SingleTest currentSingleTestFromTS = currentSingleTestSubset.getTest();
<span class="nocode"><a name="296">296: </a></span>							
<span class="nocode"><a name="297">297: </a></span>
<span class="nocode"><a name="298">298: </a></span>			// If the current SingleTest from the testSubset iterator
<span class="nocode"><a name="299">299: </a></span>			// has the same name as the current SingleTest from the 
<span class="nocode"><a name="300">300: </a></span>			// requirementSubset iterator, then we have a match. 	
<span class="nocode"><a name="301">301: </a></span>			if ((currentSingleTestFromTS.getName()).equals(test.getName()))
<span class="nocode"><a name="302">302: </a></span>				return currentSingleTestSubset;	
<span class="nocode"><a name="303">303: </a></span>			}
<span class="nocode"><a name="304">304: </a></span>		
<span class="nocode"><a name="305">305: </a></span>		return null;	
<span class="nocode"><a name="306">306: </a></span>	}
<span class="nocode"><a name="307">307: </a></span>
<span class="nocode"><a name="308">308: </a></span>	/**
<span class="nocode"><a name="309">309: </a></span>	 * Saves a setcover as two files that can be read in
<span class="nocode"><a name="310">310: </a></span>	 * using the R class CoverageEffectiveness.R
<span class="nocode"><a name="311">311: </a></span>	 * 
<span class="nocode"><a name="312">312: </a></span>	 * This method calls the class GenerateCoverageEffectivenessData.java
<span class="nocode"><a name="313">313: </a></span>	 * that was written by Gavilan Steinman
<span class="nocode"><a name="314">314: </a></span>	 *
<span class="nocode"><a name="315">315: </a></span>	 * @author Adam M. Smith
<span class="nocode"><a name="316">316: </a></span>	 */
<span class="nocode"><a name="317">317: </a></span>
<span class="nocode"><a name="318">318: </a></span>	public static void saveSetCoverAsCoverageAndTimeFile(SetCover cover,String coverage,String time)
<span class="nocode"><a name="319">319: </a></span>	{
<span class="nocode"><a name="320">320: </a></span>		GenerateCoverageEffectivenessData g = new GenerateCoverageEffectivenessData(cover);
<span class="nocode"><a name="321">321: </a></span> 	   g.saveTimingData(time);
<span class="nocode"><a name="322">322: </a></span>      g.saveCoverageData(coverage);
<span class="nocode"><a name="323">323: </a></span>	}
<span class="nocode"><a name="324">324: </a></span>
<span class="nocode"><a name="325">325: </a></span>
<span class="nocode"><a name="326">326: </a></span>	/**
<span class="nocode"><a name="327">327: </a></span>	 * Constructs an instance of SetCover from an xml file.
<span class="nocode"><a name="328">328: </a></span>	 * 
<span class="nocode"><a name="329">329: </a></span>	 * This method returns a SetCover object
<span class="nocode"><a name="330">330: </a></span>	 *
<span class="nocode"><a name="331">331: </a></span>	 * @author Adam M. Smith
<span class="nocode"><a name="332">332: </a></span>	 */
<span class="nocode"><a name="333">333: </a></span>	/* 
<span class="nocode"><a name="334">334: </a></span>	 public static SetCover constructSetCoverFromXML(String fileName)
<span class="nocode"><a name="335">335: </a></span>	 {	
<span class="nocode"><a name="336">336: </a></span>		XStream xstream = new XStream();
<span class="nocode"><a name="337">337: </a></span>	 	FileInputStream input = null;
<span class="nocode"><a name="338">338: </a></span>	 	try 
<span class="nocode"><a name="339">339: </a></span>	 	{
<span class="nocode"><a name="340">340: </a></span>	 		input = new FileInputStream(fileName);
<span class="nocode"><a name="341">341: </a></span>	 	}
<span class="nocode"><a name="342">342: </a></span>	 	catch(java.io.FileNotFoundException e)
<span class="nocode"><a name="343">343: </a></span>	 	{
<span class="nocode"><a name="344">344: </a></span>	 		System.out.println(&quot;File &quot;+fileName+&quot; not found&quot;);
<span class="nocode"><a name="345">345: </a></span>	 	}
<span class="nocode"><a name="346">346: </a></span>		return ((SetCover) xstream.fromXML((InputStream) input));
<span class="nocode"><a name="347">347: </a></span>	 }
<span class="nocode"><a name="348">348: </a></span>	*/
<span class="nocode"><a name="349">349: </a></span>
<span class="nocode"><a name="350">350: </a></span>	/**
<span class="nocode"><a name="351">351: </a></span>	 * Constructs an instance of SetCover from a binary matrix coverage
<span class="nocode"><a name="352">352: </a></span>	 * representation.
<span class="nocode"><a name="353">353: </a></span>	 * 
<span class="nocode"><a name="354">354: </a></span>	 * This method returns a SetCover object
<span class="nocode"><a name="355">355: </a></span>	 *
<span class="nocode"><a name="356">356: </a></span>	 * @author Adam M. Smith
<span class="nocode"><a name="357">357: </a></span>	 */
<span class="nocode"><a name="358">358: </a></span>	 
<span class="nocode"><a name="359">359: </a></span>	 public static SetCover constructSetCoverFromBinary(String matrix, String time) {
<span class="nocode"><a name="360">360: </a></span>	 	 	
<span class="nocode"><a name="361">361: </a></span>	 	 SetCover cover = new SetCover();
<span class="nocode"><a name="362">362: </a></span>	 	 	
<span class="nocode"><a name="363">363: </a></span>	 	// Initialize tests to -1 because of the summary column.  The first row is popped before
<span class="nocode"><a name="364">364: </a></span>	 	// counting so it starts at 0
<span class="nocode"><a name="365">365: </a></span>		int numTests = -1;
<span class="nocode"><a name="366">366: </a></span>		int numReqs = 0;
<span class="nocode"><a name="367">367: </a></span>	
<span class="nocode"><a name="368">368: </a></span>		ArrayList requirementSubsets = new ArrayList();
<span class="nocode"><a name="369">369: </a></span>		ArrayList singleTests = new ArrayList();
<span class="nocode"><a name="370">370: </a></span>		ArrayList singleTestSubsets = new ArrayList();
<span class="nocode"><a name="371">371: </a></span>	
<span class="nocode"><a name="372">372: </a></span>		Scanner matrixScanner = null;
<span class="nocode"><a name="373">373: </a></span>		Scanner timeScanner = null;
<span class="nocode"><a name="374">374: </a></span>	
<span class="nocode"><a name="375">375: </a></span>		File matrixFile = new File(matrix);
<span class="nocode"><a name="376">376: </a></span>		File timeFile = new File(time);
<span class="nocode"><a name="377">377: </a></span>	
<span class="nocode"><a name="378">378: </a></span>		// Try to read from the file, else print an error
<span class="nocode"><a name="379">379: </a></span>		try 
<span class="nocode"><a name="380">380: </a></span>		{
<span class="nocode"><a name="381">381: </a></span>			matrixScanner = new Scanner(matrixFile).useDelimiter(&quot;\n&quot;);
<span class="nocode"><a name="382">382: </a></span>			timeScanner = new Scanner(timeFile);
<span class="nocode"><a name="383">383: </a></span>		}
<span class="nocode"><a name="384">384: </a></span>		catch(java.io.FileNotFoundException e) 
<span class="nocode"><a name="385">385: </a></span>		{
<span class="nocode"><a name="386">386: </a></span>			System.out.println(&quot;File Not Found&quot;);
<span class="nocode"><a name="387">387: </a></span>
<span class="nocode"><a name="388">388: </a></span>			return null;	 
<span class="nocode"><a name="389">389: </a></span>		}		
<span class="nocode"><a name="390">390: </a></span>		
<span class="nocode"><a name="391">391: </a></span>		// Ignore the first two label entries
<span class="nocode"><a name="392">392: </a></span>		timeScanner.next();
<span class="nocode"><a name="393">393: </a></span>		timeScanner.next(); 	
<span class="nocode"><a name="394">394: </a></span>				
<span class="nocode"><a name="395">395: </a></span>		// get the first row.  The first row must be preprocessed to get the 
<span class="nocode"><a name="396">396: </a></span>		// total number of tests.  
<span class="nocode"><a name="397">397: </a></span>		
<span class="nocode"><a name="398">398: </a></span>		// This is extremely sloppy in my opinion. 
<span class="nocode"><a name="399">399: </a></span>		// I could change the way I find the number of tests by using the
<span class="nocode"><a name="400">400: </a></span>		// time file, but the way I do it now only counts on the matrix file being correct.
<span class="nocode"><a name="401">401: </a></span>		// I need to find a way to count the number of requirements in a better way as well.
<span class="nocode"><a name="402">402: </a></span>		
<span class="nocode"><a name="403">403: </a></span>		String firstRow = (String) matrixScanner.next();
<span class="nocode"><a name="404">404: </a></span>		Scanner firstRowScanner = new Scanner(firstRow);
<span class="nocode"><a name="405">405: </a></span>		
<span class="nocode"><a name="406">406: </a></span>		while (firstRowScanner.hasNext()) 
<span class="nocode"><a name="407">407: </a></span>		{
<span class="nocode"><a name="408">408: </a></span>			firstRowScanner.next();
<span class="nocode"><a name="409">409: </a></span>			numTests++;
<span class="nocode"><a name="410">410: </a></span>		}
<span class="nocode"><a name="411">411: </a></span>		
<span class="nocode"><a name="412">412: </a></span>		while (matrixScanner.hasNext())
<span class="nocode"><a name="413">413: </a></span>		{
<span class="nocode"><a name="414">414: </a></span>			matrixScanner.next();
<span class="nocode"><a name="415">415: </a></span>			numReqs++;
<span class="nocode"><a name="416">416: </a></span>		}
<span class="nocode"><a name="417">417: </a></span>		
<span class="nocode"><a name="418">418: </a></span>		// Make the singleTest Objects 
<span class="nocode"><a name="419">419: </a></span>		
<span class="nocode"><a name="420">420: </a></span>		for(int i = 0; i &lt; numTests;i++)
<span class="nocode"><a name="421">421: </a></span>		{
<span class="nocode"><a name="422">422: </a></span>			//Ignore the test label
<span class="nocode"><a name="423">423: </a></span>			timeScanner.next();
<span class="nocode"><a name="424">424: </a></span>			double testCost = Double.parseDouble(timeScanner.next());
<span class="nocode"><a name="425">425: </a></span>			SingleTest currentTest = new SingleTest(&quot;SingleTest&quot;+i,i,testCost);
<span class="nocode"><a name="426">426: </a></span>			singleTests.add(currentTest);
<span class="nocode"><a name="427">427: </a></span>			singleTestSubsets.add(new SingleTestSubset(currentTest));
<span class="nocode"><a name="428">428: </a></span>		}
<span class="nocode"><a name="429">429: </a></span>		
<span class="nocode"><a name="430">430: </a></span>		
<span class="nocode"><a name="431">431: </a></span>		// reset the scanner
<span class="nocode"><a name="432">432: </a></span>		try 
<span class="nocode"><a name="433">433: </a></span>		{
<span class="nocode"><a name="434">434: </a></span>			matrixScanner = new Scanner(matrixFile).useDelimiter(&quot;\n&quot;);
<span class="nocode"><a name="435">435: </a></span>		}
<span class="nocode"><a name="436">436: </a></span>		catch(Exception e) {System.out.println(&quot;File Not Found&quot;);}
<span class="nocode"><a name="437">437: </a></span>		
<span class="nocode"><a name="438">438: </a></span>		// while there is another line to scan
<span class="nocode"><a name="439">439: </a></span>		for(int i = 0; i &lt; numReqs;i++) 
<span class="nocode"><a name="440">440: </a></span>		{			
<span class="nocode"><a name="441">441: </a></span>			// Create a new RequirementSubset
<span class="nocode"><a name="442">442: </a></span>			RequirementSubset currentRS = new RequirementSubset(&quot;RequirementSubset&quot;+i,i);
<span class="nocode"><a name="443">443: </a></span>			
<span class="nocode"><a name="444">444: </a></span>			// Get the next line
<span class="nocode"><a name="445">445: </a></span>			String row = (String) matrixScanner.next();
<span class="nocode"><a name="446">446: </a></span>			
<span class="nocode"><a name="447">447: </a></span>			// Create a Scanner to scan the line
<span class="nocode"><a name="448">448: </a></span>			Scanner rowScanner = new Scanner(row);
<span class="nocode"><a name="449">449: </a></span>			
<span class="nocode"><a name="450">450: </a></span>			// For each test column			
<span class="nocode"><a name="451">451: </a></span>			for(int j=0; j &lt; numTests; j++)
<span class="nocode"><a name="452">452: </a></span>			{
<span class="nocode"><a name="453">453: </a></span>				// If the test is covered
<span class="nocode"><a name="454">454: </a></span>	
<span class="nocode"><a name="455">455: </a></span>				if(Integer.parseInt(rowScanner.next())==1)
<span class="nocode"><a name="456">456: </a></span>				{
<span class="nocode"><a name="457">457: </a></span>					// Add the coresponding SingleTest object to the RS
<span class="nocode"><a name="458">458: </a></span>					currentRS.addCoveringTest( (SingleTest) singleTests.get(j));
<span class="nocode"><a name="459">459: </a></span>					
<span class="nocode"><a name="460">460: </a></span>					// Add the RS to the to the corresponding STS object
<span class="nocode"><a name="461">461: </a></span>					((SingleTestSubset) singleTestSubsets.get(j)).addRequirementSubset(currentRS);
<span class="nocode"><a name="462">462: </a></span>				}
<span class="nocode"><a name="463">463: </a></span>			}
<span class="nocode"><a name="464">464: </a></span>			
<span class="nocode"><a name="465">465: </a></span>			// Add the RequirementSubset to the ArrayList
<span class="nocode"><a name="466">466: </a></span>			requirementSubsets.add(currentRS);
<span class="nocode"><a name="467">467: </a></span>		}		
<span class="nocode"><a name="468">468: </a></span>		
<span class="nocode"><a name="469">469: </a></span>		for(int i = 0; i &lt; numTests; i++) 
<span class="nocode"><a name="470">470: </a></span>		{
<span class="nocode"><a name="471">471: </a></span>			cover.addSingleTestSubset((SingleTestSubset) singleTestSubsets.get(i));
<span class="nocode"><a name="472">472: </a></span>		}
<span class="nocode"><a name="473">473: </a></span>		
<span class="nocode"><a name="474">474: </a></span>		for(int i = 0; i &lt; numReqs; i++)
<span class="nocode"><a name="475">475: </a></span>		{
<span class="nocode"><a name="476">476: </a></span>			cover.addRequirementSubset((RequirementSubset) requirementSubsets.get(i));
<span class="nocode"><a name="477">477: </a></span>		}
<span class="nocode"><a name="478">478: </a></span>		
<span class="nocode"><a name="479">479: </a></span>		return cover;
<span class="nocode"><a name="480">480: </a></span>	
<span class="nocode"><a name="481">481: </a></span>	}
<span class="nocode"><a name="482">482: </a></span>
<span class="nocode"><a name="483">483: </a></span>    /**
<span class="nocode"><a name="484">484: </a></span>     *  Constructs an instance of SetCover from a HashMap that lists
<span class="nocode"><a name="485">485: </a></span>     *  the costs for all of the different tests.  Currently, we are
<span class="nocode"><a name="486">486: </a></span>     *  assuming that the output that is stored inside of the file
<span class="nocode"><a name="487">487: </a></span>     *  with the fileName is in the Ant JUnit output format.  This
<span class="nocode"><a name="488">488: </a></span>     *  does not produce any coverage information and as such coverage
<span class="nocode"><a name="489">489: </a></span>     *  details will have to be included in the SetCover instance
<span class="nocode"><a name="490">490: </a></span>     *  through some type of alternate means.
<span class="nocode"><a name="491">491: </a></span>     *  
<span class="nocode"><a name="492">492: </a></span>     *  Later this should probably be extended with a new parameter
<span class="nocode"><a name="493">493: </a></span>     *  that points to coverage information.  But, we do not yet know
<span class="nocode"><a name="494">494: </a></span>     *  what the format of this second parameter would look like.
<span class="nocode"><a name="495">495: </a></span>     *
<span class="nocode"><a name="496">496: </a></span>     *  @author Gregory M. Kapfhammer 10/4/2005
<span class="nocode"><a name="497">497: </a></span>     */
<span class="nocode"><a name="498">498: </a></span>    public static SetCover constructSetCover(String fileName)
<span class="nocode"><a name="499">499: </a></span>    {
<span class="nocode"><a name="500">500: </a></span>
<span class="nocode"><a name="501">501: </a></span>	SetCover cover = new SetCover();
<span class="nocode"><a name="502">502: </a></span>
<span class="nocode"><a name="503">503: </a></span>	// note that the HashMap is storing the (test name, test time)
<span class="nocode"><a name="504">504: </a></span>	// pairs and we can use this to build up the SetCover instance
<span class="nocode"><a name="505">505: </a></span>	HashMap testTimingsMap = Util.readTestTimings(fileName);
<span class="nocode"><a name="506">506: </a></span>
<span class="nocode"><a name="507">507: </a></span>// 	System.out.println(&quot;ok,here -- &quot; + testTimingsMap);
<span class="nocode"><a name="508">508: </a></span>		
<span class="nocode"><a name="509">509: </a></span>	// the test index is simply incremented as we create the 
<span class="nocode"><a name="510">510: </a></span>	// new SingleTests ; this index is arbitrary and just used
<span class="nocode"><a name="511">511: </a></span>	// for organization and debugging purposes
<span class="nocode"><a name="512">512: </a></span>	int testIndex = 1;
<span class="nocode"><a name="513">513: </a></span>
<span class="nocode"><a name="514">514: </a></span>	// extract an iterator of all of the values inside of the 
<span class="nocode"><a name="515">515: </a></span>	// HashMap (each pair represents a new SingleTest for which
<span class="nocode"><a name="516">516: </a></span>	// we should also have some coverage information)
<span class="nocode"><a name="517">517: </a></span>	Iterator testTimingsIterator = testTimingsMap.keySet().iterator();
<span class="nocode"><a name="518">518: </a></span>	while( testTimingsIterator.hasNext() )
<span class="nocode"><a name="519">519: </a></span>	    {
<span class="nocode"><a name="520">520: </a></span>
<span class="nocode"><a name="521">521: </a></span>		// extract the name of the test
<span class="nocode"><a name="522">522: </a></span>		String currentTestName = 
<span class="nocode"><a name="523">523: </a></span>		    (String) testTimingsIterator.next();
<span class="nocode"><a name="524">524: </a></span>
<span class="nocode"><a name="525">525: </a></span>		// extract the time overhead of the test
<span class="nocode"><a name="526">526: </a></span>		Double currentTestTime = 
<span class="nocode"><a name="527">527: </a></span>		    (Double) testTimingsMap.get(currentTestName);
<span class="nocode"><a name="528">528: </a></span>
<span class="nocode"><a name="529">529: </a></span>		// create a new SingleTest that has this name
<span class="nocode"><a name="530">530: </a></span>		// and the current value of the testIndex
<span class="nocode"><a name="531">531: </a></span>		SingleTest currentTest =
<span class="nocode"><a name="532">532: </a></span>		    new SingleTest(currentTestName, testIndex);
<span class="nocode"><a name="533">533: </a></span>
<span class="nocode"><a name="534">534: </a></span>		// go to the next value for the testIndex
<span class="nocode"><a name="535">535: </a></span>		testIndex++;
<span class="nocode"><a name="536">536: </a></span>
<span class="nocode"><a name="537">537: </a></span>		// set the time for this new SingleTest
<span class="nocode"><a name="538">538: </a></span>		currentTest.setCost(currentTestTime.doubleValue());
<span class="nocode"><a name="539">539: </a></span>
<span class="nocode"><a name="540">540: </a></span>		// create a new SingleTestSubset that is supposed
<span class="nocode"><a name="541">541: </a></span>		// to be placed inside of this SetCover instance that
<span class="nocode"><a name="542">542: </a></span>		// we are trying to produce
<span class="nocode"><a name="543">543: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="544">544: </a></span>		    new SingleTestSubset(currentTest);
<span class="nocode"><a name="545">545: </a></span>
<span class="nocode"><a name="546">546: </a></span>		// place the STS inside of the SetCover
<span class="nocode"><a name="547">547: </a></span>		cover.addSingleTestSubset(currentTestSubset);
<span class="nocode"><a name="548">548: </a></span>
<span class="nocode"><a name="549">549: </a></span>	    }
<span class="nocode"><a name="550">550: </a></span>
<span class="nocode"><a name="551">551: </a></span>
<span class="nocode"><a name="552">552: </a></span>	return cover;
<span class="nocode"><a name="553">553: </a></span>
<span class="nocode"><a name="554">554: </a></span>    }
<span class="nocode"><a name="555">555: </a></span>
<span class="nocode"><a name="556">556: </a></span>    /**
<span class="nocode"><a name="557">557: </a></span>     *  This method sums the purchase prices in a listing of
<span class="nocode"><a name="558">558: </a></span>     *  SingleTests.  Note that it is likely more useful to sum the
<span class="nocode"><a name="559">559: </a></span>     *  costs because from a testing perspective the costs are
<span class="nocode"><a name="560">560: </a></span>     *  directly related to either the time or the space overheads.
<span class="nocode"><a name="561">561: </a></span>     *  
<span class="nocode"><a name="562">562: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="563">563: </a></span>     */
<span class="nocode"><a name="564">564: </a></span>    public static double sumPurchasePrices(Set answer)
<span class="nocode"><a name="565">565: </a></span>    {
<span class="nocode"><a name="566">566: </a></span>
<span class="nocode"><a name="567">567: </a></span>	double priceSum = 0.0;
<span class="nocode"><a name="568">568: </a></span>
<span class="nocode"><a name="569">569: </a></span>	// extract an iterator of the SingleTests
<span class="nocode"><a name="570">570: </a></span>	Iterator testsIterator = answer.iterator();
<span class="nocode"><a name="571">571: </a></span>	while( testsIterator.hasNext() )
<span class="nocode"><a name="572">572: </a></span>	    {
<span class="nocode"><a name="573">573: </a></span>
<span class="nocode"><a name="574">574: </a></span>		SingleTest currentTest = (SingleTest) testsIterator.next();
<span class="nocode"><a name="575">575: </a></span>		priceSum = priceSum + currentTest.getPurchasePrice();
<span class="nocode"><a name="576">576: </a></span>
<span class="nocode"><a name="577">577: </a></span>	    }
<span class="nocode"><a name="578">578: </a></span>
<span class="nocode"><a name="579">579: </a></span>	return priceSum;
<span class="nocode"><a name="580">580: </a></span>
<span class="nocode"><a name="581">581: </a></span>    }
<span class="nocode"><a name="582">582: </a></span>
<span class="nocode"><a name="583">583: </a></span>    /**
<span class="nocode"><a name="584">584: </a></span>     *  This method sums the costs in a listing of SingleTests.  Note
<span class="nocode"><a name="585">585: </a></span>     *  that this is likely very useful from a testing perspective
<span class="nocode"><a name="586">586: </a></span>     *  because it is these costs that correspond to the time and
<span class="nocode"><a name="587">587: </a></span>     *  space overhead that will be incurred when testing occurs.
<span class="nocode"><a name="588">588: </a></span>     *  
<span class="nocode"><a name="589">589: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="590">590: </a></span>     */
<span class="nocode"><a name="591">591: </a></span>    public static double sumCosts(Set answer)
<span class="nocode"><a name="592">592: </a></span>    {
<span class="nocode"><a name="593">593: </a></span>
<span class="nocode"><a name="594">594: </a></span>	double costSum = 0.0;
<span class="nocode"><a name="595">595: </a></span>
<span class="nocode"><a name="596">596: </a></span>	// extract an iterator of the SingleTests
<span class="nocode"><a name="597">597: </a></span>	Iterator testsIterator = answer.iterator();
<span class="nocode"><a name="598">598: </a></span>	while( testsIterator.hasNext() )
<span class="nocode"><a name="599">599: </a></span>	    {
<span class="nocode"><a name="600">600: </a></span>
<span class="nocode"><a name="601">601: </a></span>		SingleTest currentTest = (SingleTest) testsIterator.next();
<span class="nocode"><a name="602">602: </a></span>		costSum = costSum + currentTest.getCost();
<span class="nocode"><a name="603">603: </a></span>
<span class="nocode"><a name="604">604: </a></span>	    }
<span class="nocode"><a name="605">605: </a></span>
<span class="nocode"><a name="606">606: </a></span>	return costSum;
<span class="nocode"><a name="607">607: </a></span>
<span class="nocode"><a name="608">608: </a></span>    }
<span class="nocode"><a name="609">609: </a></span>
<span class="nocode"><a name="610">610: </a></span>    /**
<span class="nocode"><a name="611">611: </a></span>     *  Determine the size of the answer.
<span class="nocode"><a name="612">612: </a></span>     *  
<span class="nocode"><a name="613">613: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="614">614: </a></span>     */
<span class="nocode"><a name="615">615: </a></span>    public static int size(Set answer)
<span class="nocode"><a name="616">616: </a></span>    {
<span class="nocode"><a name="617">617: </a></span>
<span class="nocode"><a name="618">618: </a></span>	return answer.size();
<span class="nocode"><a name="619">619: </a></span>
<span class="nocode"><a name="620">620: </a></span>    }
<span class="nocode"><a name="621">621: </a></span>
<span class="nocode"><a name="622">622: </a></span>    /**
<span class="nocode"><a name="623">623: </a></span>     *  This method sums the costs of a SetCover that represents an
<span class="nocode"><a name="624">624: </a></span>     *  entire test suite.  This method can be used for a SetCover that
<span class="nocode"><a name="625">625: </a></span>     *  has not already been reduced and for which no answer has yet
<span class="nocode"><a name="626">626: </a></span>     *  to be produced.
<span class="nocode"><a name="627">627: </a></span>     *  
<span class="nocode"><a name="628">628: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="629">629: </a></span>     */
<span class="nocode"><a name="630">630: </a></span>    public double sumInnerCosts()
<span class="nocode"><a name="631">631: </a></span>    {
<span class="nocode"><a name="632">632: </a></span>
<span class="nocode"><a name="633">633: </a></span>	double sumInnerCosts = 0.0;
<span class="nocode"><a name="634">634: </a></span>
<span class="nocode"><a name="635">635: </a></span>	// extract an iterator of the testSubsets
<span class="nocode"><a name="636">636: </a></span>	Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="637">637: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="638">638: </a></span>	    {
<span class="nocode"><a name="639">639: </a></span>
<span class="nocode"><a name="640">640: </a></span>		// extract the current SingleTestSubset
<span class="nocode"><a name="641">641: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="642">642: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="643">643: </a></span>		
<span class="nocode"><a name="644">644: </a></span>		// extract the SingleTest for the STS
<span class="nocode"><a name="645">645: </a></span>		SingleTest currentTest = currentSubset.getTest();
<span class="nocode"><a name="646">646: </a></span>
<span class="nocode"><a name="647">647: </a></span>		// add to the current value for the costs
<span class="nocode"><a name="648">648: </a></span>		sumInnerCosts = sumInnerCosts + 
<span class="nocode"><a name="649">649: </a></span>		    currentTest.getCost();
<span class="nocode"><a name="650">650: </a></span>
<span class="nocode"><a name="651">651: </a></span>	    }
<span class="nocode"><a name="652">652: </a></span>
<span class="nocode"><a name="653">653: </a></span>	return sumInnerCosts;
<span class="nocode"><a name="654">654: </a></span>
<span class="nocode"><a name="655">655: </a></span>    }
<span class="nocode"><a name="656">656: </a></span>
<span class="nocode"><a name="657">657: </a></span>    /**
<span class="nocode"><a name="658">658: </a></span>     *  This method determines the size for the test suite that
<span class="nocode"><a name="659">659: </a></span>     *  the SetCover represents.
<span class="nocode"><a name="660">660: </a></span>     *  
<span class="nocode"><a name="661">661: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="662">662: </a></span>     */
<span class="nocode"><a name="663">663: </a></span>    public int innerSize()
<span class="nocode"><a name="664">664: </a></span>    {
<span class="nocode"><a name="665">665: </a></span>
<span class="nocode"><a name="666">666: </a></span>	return testSubsets.size();
<span class="nocode"><a name="667">667: </a></span>
<span class="nocode"><a name="668">668: </a></span>    }
<span class="nocode"><a name="669">669: </a></span>
<span class="nocode"><a name="670">670: </a></span>    /**
<span class="nocode"><a name="671">671: </a></span>     *  Returns the listing of reducedSingleTestSubsets.  This can be
<span class="nocode"><a name="672">672: </a></span>     *  used along side the LinkedHashSet returned by the
<span class="nocode"><a name="673">673: </a></span>     *  reduceUsingGreedy method in order to analyze the final output.
<span class="nocode"><a name="674">674: </a></span>     *  
<span class="nocode"><a name="675">675: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="676">676: </a></span>     */
<span class="nocode"><a name="677">677: </a></span>    public LinkedHashSet getReducedSingleTestSubsets()
<span class="nocode"><a name="678">678: </a></span>	//public Set getReducedSingleTestSubsets()
<span class="nocode"><a name="679">679: </a></span>    {
<span class="nocode"><a name="680">680: </a></span>
<span class="nocode"><a name="681">681: </a></span>	return reducedSingleTestSubsets;
<span class="nocode"><a name="682">682: </a></span>
<span class="nocode"><a name="683">683: </a></span>    }
<span class="nocode"><a name="684">684: </a></span>
<span class="nocode"><a name="685">685: </a></span>    /**
<span class="nocode"><a name="686">686: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="687">687: </a></span>     */
<span class="nocode"><a name="688">688: </a></span>    public void newRandomizer()
<span class="nocode"><a name="689">689: </a></span>    {
<span class="nocode"><a name="690">690: </a></span>
<span class="nocode"><a name="691">691: </a></span>	randomizer = new Random();
<span class="nocode"><a name="692">692: </a></span>
<span class="nocode"><a name="693">693: </a></span>    }
<span class="nocode"><a name="694">694: </a></span>
<span class="nocode"><a name="695">695: </a></span>    /**
<span class="nocode"><a name="696">696: </a></span>     *  Add in a new RequirementSubset to the universe.
<span class="nocode"><a name="697">697: </a></span>     *  
<span class="nocode"><a name="698">698: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="699">699: </a></span>     */
<span class="nocode"><a name="700">700: </a></span>    public void addRequirementSubset(RequirementSubset s)
<span class="nocode"><a name="701">701: </a></span>    {
<span class="nocode"><a name="702">702: </a></span>
<span class="nocode"><a name="703">703: </a></span>		requirementSubsetUniverse.add(s);
<span class="nocode"><a name="704">704: </a></span>
<span class="nocode"><a name="705">705: </a></span>    }
<span class="nocode"><a name="706">706: </a></span>
<span class="nocode"><a name="707">707: </a></span>	/**
<span class="nocode"><a name="708">708: </a></span>     *  Add in a set of RequirementSubsets to the universe.
<span class="nocode"><a name="709">709: </a></span>     *  
<span class="nocode"><a name="710">710: </a></span>     *  @author Adam M. Smith 07/19/2007
<span class="nocode"><a name="711">711: </a></span>     */
<span class="nocode"><a name="712">712: </a></span>    public void addRequirementSubsets(LinkedHashSet s)
<span class="nocode"><a name="713">713: </a></span>    {
<span class="nocode"><a name="714">714: </a></span>	 	requirementSubsetUniverse.addAll(s);
<span class="nocode"><a name="715">715: </a></span>    }
<span class="nocode"><a name="716">716: </a></span>
<span class="nocode"><a name="717">717: </a></span>	
<span class="nocode"><a name="718">718: </a></span>    /**
<span class="nocode"><a name="719">719: </a></span>     *  Returns the requirementSubsetsUniverse.
<span class="nocode"><a name="720">720: </a></span>     *  
<span class="nocode"><a name="721">721: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="722">722: </a></span>     */
<span class="nocode"><a name="723">723: </a></span>    public Set getRequirementSubsetUniverse()
<span class="nocode"><a name="724">724: </a></span>    {
<span class="nocode"><a name="725">725: </a></span>
<span class="nocode"><a name="726">726: </a></span>	return requirementSubsetUniverse;
<span class="nocode"><a name="727">727: </a></span>
<span class="nocode"><a name="728">728: </a></span>    }
<span class="nocode"><a name="729">729: </a></span>
<span class="nocode"><a name="730">730: </a></span>    /**
<span class="nocode"><a name="731">731: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="732">732: </a></span>     */
<span class="nocode"><a name="733">733: </a></span>    public void setRequirementSubsetUniverse(LinkedHashSet universe)
<span class="nocode"><a name="734">734: </a></span>    {
<span class="nocode"><a name="735">735: </a></span>
<span class="nocode"><a name="736">736: </a></span>	requirementSubsetUniverse = universe;
<span class="nocode"><a name="737">737: </a></span>
<span class="nocode"><a name="738">738: </a></span>    }
<span class="nocode"><a name="739">739: </a></span>
<span class="nocode"><a name="740">740: </a></span>    /**
<span class="nocode"><a name="741">741: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="742">742: </a></span>     */
<span class="nocode"><a name="743">743: </a></span>   public void addToRequirementSubsetUniverse(Set moreToUniverse)
<span class="nocode"><a name="744">744: </a></span>    {
<span class="nocode"><a name="745">745: </a></span>
<span class="nocode"><a name="746">746: </a></span>	requirementSubsetUniverse.addAll(moreToUniverse);
<span class="nocode"><a name="747">747: </a></span>
<span class="nocode"><a name="748">748: </a></span>    }
<span class="nocode"><a name="749">749: </a></span>	 
<span class="nocode"><a name="750">750: </a></span>	/**
<span class="nocode"><a name="751">751: </a></span> 	 *  Remove a requirementSubset
<span class="nocode"><a name="752">752: </a></span>	 *
<span class="nocode"><a name="753">753: </a></span>	 *	 @author Adam M. Smith 7/09/2007
<span class="nocode"><a name="754">754: </a></span>	 */
<span class="nocode"><a name="755">755: </a></span>	public void removeRequirementSubset(RequirementSubset requirementSubsetToRemove)
<span class="nocode"><a name="756">756: </a></span>	{
<span class="nocode"><a name="757">757: </a></span>		
<span class="nocode"><a name="758">758: </a></span>		requirementSubsetUniverse.remove(requirementSubsetToRemove);
<span class="nocode"><a name="759">759: </a></span>	
<span class="nocode"><a name="760">760: </a></span>	}
<span class="nocode"><a name="761">761: </a></span>
<span class="nocode"><a name="762">762: </a></span>	/**
<span class="nocode"><a name="763">763: </a></span> 	 *  Remove multiple requirementSubsets
<span class="nocode"><a name="764">764: </a></span>	 *
<span class="nocode"><a name="765">765: </a></span>	 *	 @author Adam M. Smith 7/09/2007
<span class="nocode"><a name="766">766: </a></span>	 */
<span class="nocode"><a name="767">767: </a></span>	public void removeRequirementSubsets(LinkedHashSet requirementSubsetsToRemove)
<span class="nocode"><a name="768">768: </a></span>	{
<span class="nocode"><a name="769">769: </a></span>		
<span class="nocode"><a name="770">770: </a></span>		requirementSubsetUniverse.removeAll(requirementSubsetsToRemove);
<span class="nocode"><a name="771">771: </a></span>	
<span class="nocode"><a name="772">772: </a></span>	}
<span class="nocode"><a name="773">773: </a></span>	
<span class="nocode"><a name="774">774: </a></span>	/**
<span class="nocode"><a name="775">775: </a></span> 	 *  Remove a SingleTestSubset
<span class="nocode"><a name="776">776: </a></span>	 *
<span class="nocode"><a name="777">777: </a></span>	 *	 @author Adam M. Smith 7/30/2007
<span class="nocode"><a name="778">778: </a></span>	 */
<span class="nocode"><a name="779">779: </a></span>	public void clearSingleTestSubsets()
<span class="nocode"><a name="780">780: </a></span>	{
<span class="nocode"><a name="781">781: </a></span>		
<span class="nocode"><a name="782">782: </a></span>		testSubsets.clear();
<span class="nocode"><a name="783">783: </a></span>	
<span class="nocode"><a name="784">784: </a></span>	}
<span class="nocode"><a name="785">785: </a></span>	
<span class="nocode"><a name="786">786: </a></span>	/**
<span class="nocode"><a name="787">787: </a></span> 	 *  Remove a SingleTestSubset
<span class="nocode"><a name="788">788: </a></span>	 *
<span class="nocode"><a name="789">789: </a></span>	 *	 @author Adam M. Smith 7/09/2007
<span class="nocode"><a name="790">790: </a></span>	 */
<span class="nocode"><a name="791">791: </a></span>	public void removeSingleTestSubset(SingleTestSubset singleTestSubsetToRemove)
<span class="nocode"><a name="792">792: </a></span>	{
<span class="nocode"><a name="793">793: </a></span>		
<span class="nocode"><a name="794">794: </a></span>		testSubsets.remove(singleTestSubsetToRemove);
<span class="nocode"><a name="795">795: </a></span>	
<span class="nocode"><a name="796">796: </a></span>	}
<span class="nocode"><a name="797">797: </a></span>	
<span class="nocode"><a name="798">798: </a></span>	/**
<span class="nocode"><a name="799">799: </a></span> 	 *  Remove multiple SingleTestSubsets
<span class="nocode"><a name="800">800: </a></span>	 *
<span class="nocode"><a name="801">801: </a></span>	 *	 @author Adam M. Smith 7/09/2007
<span class="nocode"><a name="802">802: </a></span>	 */
<span class="nocode"><a name="803">803: </a></span>	public void removeSingleTestSubsets(LinkedHashSet singleTestSubsetsToRemove)
<span class="nocode"><a name="804">804: </a></span>	{
<span class="nocode"><a name="805">805: </a></span>		
<span class="nocode"><a name="806">806: </a></span>		testSubsets.removeAll(singleTestSubsetsToRemove);
<span class="nocode"><a name="807">807: </a></span>	
<span class="nocode"><a name="808">808: </a></span>	}
<span class="nocode"><a name="809">809: </a></span>	
<span class="nocode"><a name="810">810: </a></span>	
<span class="nocode"><a name="811">811: </a></span>	
<span class="nocode"><a name="812">812: </a></span>    /**
<span class="nocode"><a name="813">813: </a></span>     *  Add in a new SingleTestSubset.
<span class="nocode"><a name="814">814: </a></span>     *  
<span class="nocode"><a name="815">815: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="816">816: </a></span>     */
<span class="nocode"><a name="817">817: </a></span>   public void addSingleTestSubset(SingleTestSubset sts)
<span class="nocode"><a name="818">818: </a></span>    {
<span class="nocode"><a name="819">819: </a></span>
<span class="nocode"><a name="820">820: </a></span>	testSubsets.add(sts);
<span class="nocode"><a name="821">821: </a></span>
<span class="nocode"><a name="822">822: </a></span>    }
<span class="nocode"><a name="823">823: </a></span>	 
<span class="nocode"><a name="824">824: </a></span>	 /**
<span class="nocode"><a name="825">825: </a></span>     *  Add SingleTestSubsets.
<span class="nocode"><a name="826">826: </a></span>     *  
<span class="nocode"><a name="827">827: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="828">828: </a></span>     */
<span class="nocode"><a name="829">829: </a></span>   public void addSingleTestSubsets(LinkedHashSet sts)
<span class="nocode"><a name="830">830: </a></span>    {
<span class="nocode"><a name="831">831: </a></span>
<span class="nocode"><a name="832">832: </a></span>	testSubsets.addAll(sts);
<span class="nocode"><a name="833">833: </a></span>
<span class="nocode"><a name="834">834: </a></span>    }
<span class="nocode"><a name="835">835: </a></span>
<span class="nocode"><a name="836">836: </a></span>
<span class="nocode"><a name="837">837: </a></span>
<span class="nocode"><a name="838">838: </a></span>    /**
<span class="nocode"><a name="839">839: </a></span>     *  Returns the entire set of SingleTestSubsets.
<span class="nocode"><a name="840">840: </a></span>     *  
<span class="nocode"><a name="841">841: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="842">842: </a></span>     */
<span class="nocode"><a name="843">843: </a></span>    public LinkedHashSet getTestSubsets()
<span class="nocode"><a name="844">844: </a></span>	//public Set getTestSubsets()
<span class="nocode"><a name="845">845: </a></span>    {
<span class="nocode"><a name="846">846: </a></span>
<span class="nocode"><a name="847">847: </a></span>	return testSubsets;
<span class="nocode"><a name="848">848: </a></span>
<span class="nocode"><a name="849">849: </a></span>    }
<span class="nocode"><a name="850">850: </a></span>
<span class="nocode"><a name="851">851: </a></span>    /**
<span class="nocode"><a name="852">852: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="853">853: </a></span>     */
<span class="nocode"><a name="854">854: </a></span>    public void setTestSubsetsSet(LinkedHashSet set)
<span class="nocode"><a name="855">855: </a></span>    {
<span class="nocode"><a name="856">856: </a></span>
<span class="nocode"><a name="857">857: </a></span>	testSubsets = set;
<span class="nocode"><a name="858">858: </a></span>
<span class="nocode"><a name="859">859: </a></span>    }
<span class="nocode"><a name="860">860: </a></span>
<span class="nocode"><a name="861">861: </a></span>    /**
<span class="nocode"><a name="862">862: </a></span>     *  Returns the number of times that the outer while loop 
<span class="nocode"><a name="863">863: </a></span>     *  executed for a call to the greedy approximation.  This is 
<span class="nocode"><a name="864">864: </a></span>     *  useful as a measure of the performance of the greedy test
<span class="nocode"><a name="865">865: </a></span>     *  suite reduction algorithm.
<span class="nocode"><a name="866">866: </a></span>     *  
<span class="nocode"><a name="867">867: </a></span>     *  @author Gregory M. Kapfhammer 9/24/2005
<span class="nocode"><a name="868">868: </a></span>     */
<span class="nocode"><a name="869">869: </a></span>
<span class="nocode"><a name="870">870: </a></span>
<span class="nocode"><a name="871">871: </a></span>
<span class="nocode"><a name="872">872: </a></span>    public int getOuterWhileIterations()
<span class="nocode"><a name="873">873: </a></span>    {
<span class="nocode"><a name="874">874: </a></span>
<span class="nocode"><a name="875">875: </a></span>	return outerWhileExecute;
<span class="nocode"><a name="876">876: </a></span>
<span class="nocode"><a name="877">877: </a></span>    }
<span class="nocode"><a name="878">878: </a></span>
<span class="nocode"><a name="879">879: </a></span>    /**
<span class="nocode"><a name="880">880: </a></span>     *  @author Gregory M. Kapfhammer 10/13/2005
<span class="nocode"><a name="881">881: </a></span>     */
<span class="nocode"><a name="882">882: </a></span>    public int getOuterWhileIterationsPrioritization()
<span class="nocode"><a name="883">883: </a></span>    {
<span class="nocode"><a name="884">884: </a></span>
<span class="nocode"><a name="885">885: </a></span>	return outerWhileExecutePrioritization;
<span class="nocode"><a name="886">886: </a></span>
<span class="nocode"><a name="887">887: </a></span>    }
<span class="nocode"><a name="888">888: </a></span>
<span class="nocode"><a name="889">889: </a></span>    /**
<span class="nocode"><a name="890">890: </a></span>     *  @author Gregory M. Kapfhammer 3/7/2007
<span class="nocode"><a name="891">891: </a></span>     */
<span class="nocode"><a name="892">892: </a></span>    public ArrayList getOuterWhileExecuteList()
<span class="nocode"><a name="893">893: </a></span>    {
<span class="nocode"><a name="894">894: </a></span>
<span class="nocode"><a name="895">895: </a></span>	return outerWhileExecuteList;
<span class="nocode"><a name="896">896: </a></span>
<span class="nocode"><a name="897">897: </a></span>    }
<span class="nocode"><a name="898">898: </a></span>
<span class="nocode"><a name="899">899: </a></span>    /**
<span class="nocode"><a name="900">900: </a></span>     *  This method calculates the nth Harmonic Number that gives a
<span class="nocode"><a name="901">901: </a></span>     *  bound (upper, I think) on the cost of a reduced test suite.
<span class="nocode"><a name="902">902: </a></span>     *  
<span class="nocode"><a name="903">903: </a></span>     *  NOTE: I am not sure that this method will serve a practical
<span class="nocode"><a name="904">904: </a></span>     *  purpose during experimentation.
<span class="nocode"><a name="905">905: </a></span>     *
<span class="nocode"><a name="906">906: </a></span>     *  @author Gregory M. Kapfhammer 10/3/2005
<span class="nocode"><a name="907">907: </a></span>     */
<span class="nocode"><a name="908">908: </a></span>    
<span class="nocode"><a name="909">909: </a></span>/*
<span class="nocode"><a name="910">910: </a></span>
<span class="nocode"><a name="911">911: </a></span>//	Commented out by Adam M. Smith on Nov 30th to avoid MathLink, KernelLink, and Jlink
<span class="nocode"><a name="912">912: </a></span>
<span class="nocode"><a name="913">913: </a></span>
<span class="nocode"><a name="914">914: </a></span>   public double getHarmonicNumberBound(boolean useTMax)
<span class="nocode"><a name="915">915: </a></span>    {
<span class="nocode"><a name="916">916: </a></span>
<span class="nocode"><a name="917">917: </a></span>	double harmonicNumberBound = 0.0;
<span class="nocode"><a name="918">918: </a></span>
<span class="nocode"><a name="919">919: </a></span>	// we are assuming the request is for the nth harmonic number
<span class="nocode"><a name="920">920: </a></span>	// and we will only change this if useTMax is true
<span class="nocode"><a name="921">921: </a></span>	double harmonicNumberRequest = testSubsets.size();
<span class="nocode"><a name="922">922: </a></span>
<span class="nocode"><a name="923">923: </a></span>// 	System.out.println(&quot;Normal Hn = &quot; + testSubsets.size());
<span class="nocode"><a name="924">924: </a></span>
<span class="nocode"><a name="925">925: </a></span>	// this is the size of the test suite that covers the most
<span class="nocode"><a name="926">926: </a></span>	// requirements; we will only change the value of this
<span class="nocode"><a name="927">927: </a></span>	// variable if useTMax is true and we have to iterate through
<span class="nocode"><a name="928">928: </a></span>	// all of the tests and see what they cover
<span class="nocode"><a name="929">929: </a></span>	int testSuiteMax = 0;
<span class="nocode"><a name="930">930: </a></span>
<span class="nocode"><a name="931">931: </a></span>	// we are supposed to use the size of the requirement subset
<span class="nocode"><a name="932">932: </a></span>	// of the largest covering test and thus we have to find this
<span class="nocode"><a name="933">933: </a></span>	// SingleTest first
<span class="nocode"><a name="934">934: </a></span>	if( useTMax )
<span class="nocode"><a name="935">935: </a></span>	    {
<span class="nocode"><a name="936">936: </a></span>
<span class="nocode"><a name="937">937: </a></span>		Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="938">938: </a></span>		while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="939">939: </a></span>		    {
<span class="nocode"><a name="940">940: </a></span>
<span class="nocode"><a name="941">941: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="942">942: </a></span>			    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="943">943: </a></span>
<span class="nocode"><a name="944">944: </a></span>			int currentTestSuiteSize = 
<span class="nocode"><a name="945">945: </a></span>			    currentTestSubset.
<span class="nocode"><a name="946">946: </a></span>			    getRequirementSubsetSet().size(); 
<span class="nocode"><a name="947">947: </a></span>
<span class="nocode"><a name="948">948: </a></span>			if( currentTestSuiteSize &gt; testSuiteMax )
<span class="nocode"><a name="949">949: </a></span>			    {
<span class="nocode"><a name="950">950: </a></span>
<span class="nocode"><a name="951">951: </a></span>				testSuiteMax = currentTestSuiteSize;
<span class="nocode"><a name="952">952: </a></span>
<span class="nocode"><a name="953">953: </a></span>			    }
<span class="nocode"><a name="954">954: </a></span>
<span class="nocode"><a name="955">955: </a></span>		    }
<span class="nocode"><a name="956">956: </a></span>
<span class="nocode"><a name="957">957: </a></span>		harmonicNumberRequest = testSuiteMax;
<span class="nocode"><a name="958">958: </a></span>
<span class="nocode"><a name="959">959: </a></span>// 		System.out.println(&quot;test suite max: &quot; + 
<span class="nocode"><a name="960">960: </a></span>// 				   testSuiteMax);
<span class="nocode"><a name="961">961: </a></span>
<span class="nocode"><a name="962">962: </a></span>	    }
<span class="nocode"><a name="963">963: </a></span>
<span class="nocode"><a name="964">964: </a></span>	KernelLink ml = null;
<span class="nocode"><a name="965">965: </a></span>	String mathematicaConnect = 
<span class="nocode"><a name="966">966: </a></span>	    &quot;-linkmode launch -linkname \'math -mathlink\'&quot;;
<span class="nocode"><a name="967">967: </a></span>
<span class="nocode"><a name="968">968: </a></span>	try 
<span class="nocode"><a name="969">969: </a></span>	    {
<span class="nocode"><a name="970">970: </a></span>		
<span class="nocode"><a name="971">971: </a></span>		ml = MathLinkFactory.
<span class="nocode"><a name="972">972: </a></span>		    createKernelLink(mathematicaConnect);
<span class="nocode"><a name="973">973: </a></span>		
<span class="nocode"><a name="974">974: </a></span>// 		System.out.println(&quot;after kernel link&quot;);
<span class="nocode"><a name="975">975: </a></span>
<span class="nocode"><a name="976">976: </a></span>	    } 
<span class="nocode"><a name="977">977: </a></span>
<span class="nocode"><a name="978">978: </a></span>	catch (MathLinkException e) 
<span class="nocode"><a name="979">979: </a></span>	    {
<span class="nocode"><a name="980">980: </a></span>		
<span class="nocode"><a name="981">981: </a></span>		System.out.println(&quot;Fatal error opening link: &quot; + 
<span class="nocode"><a name="982">982: </a></span>				   e.getMessage());
<span class="nocode"><a name="983">983: </a></span>		e.printStackTrace();
<span class="nocode"><a name="984">984: </a></span>	    
<span class="nocode"><a name="985">985: </a></span>	    }
<span class="nocode"><a name="986">986: </a></span>
<span class="nocode"><a name="987">987: </a></span>	try 
<span class="nocode"><a name="988">988: </a></span>	    {
<span class="nocode"><a name="989">989: </a></span>			
<span class="nocode"><a name="990">990: </a></span>		// Get rid of the initial InputNamePacket the kernel
<span class="nocode"><a name="991">991: </a></span>		// will send when it is launched.
<span class="nocode"><a name="992">992: </a></span>		ml.discardAnswer();
<span class="nocode"><a name="993">993: </a></span>			
<span class="nocode"><a name="994">994: </a></span>		// this will store the final string that we will
<span class="nocode"><a name="995">995: </a></span>		// send to Mathematica
<span class="nocode"><a name="996">996: </a></span>		StringBuffer harmonicBuffer = new StringBuffer();
<span class="nocode"><a name="997">997: </a></span>
<span class="nocode"><a name="998">998: </a></span>		harmonicBuffer.append(&quot;HarmonicNumber[&quot;);
<span class="nocode"><a name="999">999: </a></span>		harmonicBuffer.append(harmonicNumberRequest);
<span class="nocode"><a name="1000">1000: </a></span>		harmonicBuffer.append(&quot;]&quot;);
<span class="nocode"><a name="1001">1001: </a></span>
<span class="nocode"><a name="1002">1002: </a></span>		// send the final string to Mathematica through 
<span class="nocode"><a name="1003">1003: </a></span>		// J/Link and retrieve the answer as a string
<span class="nocode"><a name="1004">1004: </a></span>		String solve = ml.
<span class="nocode"><a name="1005">1005: </a></span>		    evaluateToOutputForm( harmonicBuffer.toString(), 0 );
<span class="nocode"><a name="1006">1006: </a></span>		    
<span class="nocode"><a name="1007">1007: </a></span>// 		System.out.println(&quot;solve = &quot; + solve);
<span class="nocode"><a name="1008">1008: </a></span>
<span class="nocode"><a name="1009">1009: </a></span>		Double finalHarmonic = new Double(solve);
<span class="nocode"><a name="1010">1010: </a></span>		harmonicNumberBound = finalHarmonic.doubleValue();
<span class="nocode"><a name="1011">1011: </a></span>
<span class="nocode"><a name="1012">1012: </a></span>	    }
<span class="nocode"><a name="1013">1013: </a></span>
<span class="nocode"><a name="1014">1014: </a></span>	catch(Exception e)
<span class="nocode"><a name="1015">1015: </a></span>	    {
<span class="nocode"><a name="1016">1016: </a></span>
<span class="nocode"><a name="1017">1017: </a></span>		System.out.println(&quot;Problem computing harmonic number&quot;);
<span class="nocode"><a name="1018">1018: </a></span>		e.printStackTrace();
<span class="nocode"><a name="1019">1019: </a></span>
<span class="nocode"><a name="1020">1020: </a></span>	    }
<span class="nocode"><a name="1021">1021: </a></span>
<span class="nocode"><a name="1022">1022: </a></span>	
<span class="nocode"><a name="1023">1023: </a></span>	finally 
<span class="nocode"><a name="1024">1024: </a></span>	    {
<span class="nocode"><a name="1025">1025: </a></span>		
<span class="nocode"><a name="1026">1026: </a></span>		ml.close();
<span class="nocode"><a name="1027">1027: </a></span>		
<span class="nocode"><a name="1028">1028: </a></span>	    }
<span class="nocode"><a name="1029">1029: </a></span>
<span class="nocode"><a name="1030">1030: </a></span>	return harmonicNumberBound;
<span class="nocode"><a name="1031">1031: </a></span>
<span class="nocode"><a name="1032">1032: </a></span>    }
<span class="nocode"><a name="1033">1033: </a></span>*/
<span class="nocode"><a name="1034">1034: </a></span>
<span class="nocode"><a name="1035">1035: </a></span>    /**
<span class="nocode"><a name="1036">1036: </a></span>     *  Produces a random reduction of the test suite that is guaranteed
<span class="nocode"><a name="1037">1037: </a></span>     *  to be the same size as the reduced test suite that was produced
<span class="nocode"><a name="1038">1038: </a></span>     *  using the greedy approach.
<span class="nocode"><a name="1039">1039: </a></span>     *
<span class="nocode"><a name="1040">1040: </a></span>     *  This technique allows for the creation of an experimental
<span class="nocode"><a name="1041">1041: </a></span>     *  control when we are evaluating different reduction techniques.
<span class="nocode"><a name="1042">1042: </a></span>     *  Note that the size of the test suite and thus the percent
<span class="nocode"><a name="1043">1043: </a></span>     *  reduction in space will be the same as the test that was 
<span class="nocode"><a name="1044">1044: </a></span>     *  greedily reduced.  
<span class="nocode"><a name="1045">1045: </a></span>     *
<span class="nocode"><a name="1046">1046: </a></span>     *  However, the reduction in time overhead can vary considerably
<span class="nocode"><a name="1047">1047: </a></span>     *  and the final change in the defect detection ratio can also 
<span class="nocode"><a name="1048">1048: </a></span>     *  change.  This type of experimental control is also used in 
<span class="nocode"><a name="1049">1049: </a></span>     *  papers by Memon and Rothermel.
<span class="nocode"><a name="1050">1050: </a></span>     *  
<span class="nocode"><a name="1051">1051: </a></span>     *  NOTE: Note that this just produces a single Set that
<span class="nocode"><a name="1052">1052: </a></span>     *  represents a test suite.  This is not really that useful from
<span class="nocode"><a name="1053">1053: </a></span>     *  an experimental standpoint because we need a large number of
<span class="nocode"><a name="1054">1054: </a></span>     *  random test suites in order to account for the variability in
<span class="nocode"><a name="1055">1055: </a></span>     *  the random reductions.
<span class="nocode"><a name="1056">1056: </a></span>     * 
<span class="nocode"><a name="1057">1057: </a></span>     *  @author Gregory M. Kapfhammer 10/13/2005
<span class="nocode"><a name="1058">1058: </a></span>     */
<span class="nocode"><a name="1059">1059: </a></span>    public Set reduceUsingRandom(int targetSize)
<span class="nocode"><a name="1060">1060: </a></span>    {
<span class="nocode"><a name="1061">1061: </a></span>
<span class="nocode"><a name="1062">1062: </a></span>	// take the timing before
<span class="nocode"><a name="1063">1063: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1064">1064: </a></span>
<span class="nocode"><a name="1065">1065: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1066">1066: </a></span>
<span class="nocode"><a name="1067">1067: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1068">1068: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1069">1069: </a></span>
<span class="nocode"><a name="1070">1070: </a></span>	System.out.println(&quot;ChosenSeed = &quot; + chosenSeed);
<span class="nocode"><a name="1071">1071: </a></span>
<span class="nocode"><a name="1072">1072: </a></span>	// initialize the randomizer (comment out if you want default)
<span class="nocode"><a name="1073">1073: </a></span>	randomizer = new Random(chosenSeed);
<span class="nocode"><a name="1074">1074: </a></span>
<span class="nocode"><a name="1075">1075: </a></span>	// shuffle the array using our randomizer that has been 
<span class="nocode"><a name="1076">1076: </a></span>	// initialized with a specifc random seed
<span class="nocode"><a name="1077">1077: </a></span>	Collections.shuffle(testSubsetsList, randomizer);
<span class="nocode"><a name="1078">1078: </a></span>	
<span class="nocode"><a name="1079">1079: </a></span>	// this is the number of tests that we have already included
<span class="nocode"><a name="1080">1080: </a></span>	// inside of the complete listing; initially we have not
<span class="nocode"><a name="1081">1081: </a></span>	// included any tests in the coverPickSets
<span class="nocode"><a name="1082">1082: </a></span>	int includedTests = 0;
<span class="nocode"><a name="1083">1083: </a></span>
<span class="nocode"><a name="1084">1084: </a></span>	// extract an Iterator of the shuffled testSubsetsList
<span class="nocode"><a name="1085">1085: </a></span>	// and then select the first targetSize tests and 
<span class="nocode"><a name="1086">1086: </a></span>	// place them inside of coverPickSets
<span class="nocode"><a name="1087">1087: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1088">1088: </a></span>	while( testSubsetsIterator.hasNext() &amp;&amp; 
<span class="nocode"><a name="1089">1089: </a></span>	       includedTests &lt; targetSize )
<span class="nocode"><a name="1090">1090: </a></span>	    {
<span class="nocode"><a name="1091">1091: </a></span>
<span class="nocode"><a name="1092">1092: </a></span>// 		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="1093">1093: </a></span>// 		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1094">1094: </a></span>
<span class="nocode"><a name="1095">1095: </a></span>// 		coverPickSets.add(currentTestSubset.getTest());
<span class="nocode"><a name="1096">1096: </a></span>
<span class="nocode"><a name="1097">1097: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1098">1098: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1099">1099: </a></span>
<span class="nocode"><a name="1100">1100: </a></span>		coverPickSets.
<span class="nocode"><a name="1101">1101: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1102">1102: </a></span>
<span class="nocode"><a name="1103">1103: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1104">1104: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1105">1105: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1106">1106: </a></span>
<span class="nocode"><a name="1107">1107: </a></span>		includedTests++;
<span class="nocode"><a name="1108">1108: </a></span>
<span class="nocode"><a name="1109">1109: </a></span>	    }
<span class="nocode"><a name="1110">1110: </a></span>
<span class="nocode"><a name="1111">1111: </a></span>	// take the timing after
<span class="nocode"><a name="1112">1112: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1113">1113: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="1114">1114: </a></span>
<span class="nocode"><a name="1115">1115: </a></span>	return coverPickSets;
<span class="nocode"><a name="1116">1116: </a></span>
<span class="nocode"><a name="1117">1117: </a></span>    }
<span class="nocode"><a name="1118">1118: </a></span>
<span class="nocode"><a name="1119">1119: </a></span>    /**
<span class="nocode"><a name="1120">1120: </a></span>     *  Produces a random prioritization of the test suite.
<span class="nocode"><a name="1121">1121: </a></span>     *
<span class="nocode"><a name="1122">1122: </a></span>     *  This technique allows for the creation of an experimental
<span class="nocode"><a name="1123">1123: </a></span>     *  control when we are evaluating different prioritization
<span class="nocode"><a name="1124">1124: </a></span>     *  techniques.  This type of experimental control is also used in
<span class="nocode"><a name="1125">1125: </a></span>     *  papers by Memon and Rothermel.
<span class="nocode"><a name="1126">1126: </a></span>     *  
<span class="nocode"><a name="1127">1127: </a></span>     *  NOTE: Note that this just produces a single Set that
<span class="nocode"><a name="1128">1128: </a></span>     *  represents a test suite.  This is not really that useful from
<span class="nocode"><a name="1129">1129: </a></span>     *  an experimental standpoint because we need a large number of
<span class="nocode"><a name="1130">1130: </a></span>     *  random test suites in order to account for the variability in
<span class="nocode"><a name="1131">1131: </a></span>     *  the random reductions.
<span class="nocode"><a name="1132">1132: </a></span>     * 
<span class="nocode"><a name="1133">1133: </a></span>     *  @author Gregory M. Kapfhammer 12/7/2005
<span class="nocode"><a name="1134">1134: </a></span>     */
<span class="nocode"><a name="1135">1135: </a></span>    public Set prioritizeUsingRandom()
<span class="nocode"><a name="1136">1136: </a></span>    {
<span class="nocode"><a name="1137">1137: </a></span>
<span class="nocode"><a name="1138">1138: </a></span>	// take the timing before
<span class="nocode"><a name="1139">1139: </a></span>	long prioritizationTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1140">1140: </a></span>
<span class="nocode"><a name="1141">1141: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1142">1142: </a></span>
<span class="nocode"><a name="1143">1143: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1144">1144: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1145">1145: </a></span>
<span class="nocode"><a name="1146">1146: </a></span>	//System.out.println(&quot;ChosenSeed = &quot; + chosenSeed);
<span class="nocode"><a name="1147">1147: </a></span>
<span class="nocode"><a name="1148">1148: </a></span>	// initialize the randomizer (comment out if you want default)
<span class="nocode"><a name="1149">1149: </a></span>	//randomizer = new Random(chosenSeed);
<span class="nocode"><a name="1150">1150: </a></span>
<span class="nocode"><a name="1151">1151: </a></span>		randomizer = new Random(13245);
<span class="nocode"><a name="1152">1152: </a></span>		
<span class="nocode"><a name="1153">1153: </a></span>	// shuffle the array using our randomizer that has been 
<span class="nocode"><a name="1154">1154: </a></span>	// initialized with a specifc random seed
<span class="nocode"><a name="1155">1155: </a></span>	Collections.shuffle(testSubsetsList, randomizer);
<span class="nocode"><a name="1156">1156: </a></span>
<span class="nocode"><a name="1157">1157: </a></span>	// comment out for now!
<span class="nocode"><a name="1158">1158: </a></span>
<span class="nocode"><a name="1159">1159: </a></span>	// add everything inside of the shuffled list
<span class="nocode"><a name="1160">1160: </a></span>// 	coverPickSets.addAll(testSubsetsList);
<span class="nocode"><a name="1161">1161: </a></span>
<span class="nocode"><a name="1162">1162: </a></span>// 	// added by gmk on march 6
<span class="nocode"><a name="1163">1163: </a></span>// 	reducedSingleTestSubsets.
<span class="nocode"><a name="1164">1164: </a></span>// 	    addAll( testSubsetsList );
<span class="nocode"><a name="1165">1165: </a></span>
<span class="nocode"><a name="1166">1166: </a></span>	// extract an Iterator of the shuffled testSubsetsList
<span class="nocode"><a name="1167">1167: </a></span>	// and then select the first targetSize tests and 
<span class="nocode"><a name="1168">1168: </a></span>	// place them inside of coverPickSets
<span class="nocode"><a name="1169">1169: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1170">1170: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="1171">1171: </a></span>	    {
<span class="nocode"><a name="1172">1172: </a></span>
<span class="nocode"><a name="1173">1173: </a></span>// 		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="1174">1174: </a></span>// 		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1175">1175: </a></span>
<span class="nocode"><a name="1176">1176: </a></span>// 		coverPickSets.add(currentTestSubset.getTest());
<span class="nocode"><a name="1177">1177: </a></span>
<span class="nocode"><a name="1178">1178: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1179">1179: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1180">1180: </a></span>
<span class="nocode"><a name="1181">1181: </a></span>		coverPickSets.
<span class="nocode"><a name="1182">1182: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1183">1183: </a></span>
<span class="nocode"><a name="1184">1184: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1185">1185: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1186">1186: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1187">1187: </a></span>
<span class="nocode"><a name="1188">1188: </a></span>	    }
<span class="nocode"><a name="1189">1189: </a></span>
<span class="nocode"><a name="1190">1190: </a></span>	// take the timing after
<span class="nocode"><a name="1191">1191: </a></span>	long prioritizationTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1192">1192: </a></span>	prioritizationTime = (prioritizationTimeAfter -
<span class="nocode"><a name="1193">1193: </a></span>			      prioritizationTimeBefore);
<span class="nocode"><a name="1194">1194: </a></span>
<span class="nocode"><a name="1195">1195: </a></span>	return coverPickSets;
<span class="nocode"><a name="1196">1196: </a></span>
<span class="nocode"><a name="1197">1197: </a></span>    }
<span class="nocode"><a name="1198">1198: </a></span>
<span class="nocode"><a name="1199">1199: </a></span>    /**
<span class="nocode"><a name="1200">1200: </a></span>     *  Reduces the test suite by taking tests cases from the rear 
<span class="nocode"><a name="1201">1201: </a></span>     *  of the test suite until we simply reach the target size.
<span class="nocode"><a name="1202">1202: </a></span>     *  This is supposed to be paired with the concept of reverse
<span class="nocode"><a name="1203">1203: </a></span>     *  prioritization.
<span class="nocode"><a name="1204">1204: </a></span>     *  
<span class="nocode"><a name="1205">1205: </a></span>     *  @author Gregory M. Kapfhammer 12/3/2005
<span class="nocode"><a name="1206">1206: </a></span>     */
<span class="nocode"><a name="1207">1207: </a></span>    public Set reduceUsingReverse(int targetSize)
<span class="nocode"><a name="1208">1208: </a></span>    {
<span class="nocode"><a name="1209">1209: </a></span>
<span class="nocode"><a name="1210">1210: </a></span>	// take the timing before
<span class="nocode"><a name="1211">1211: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1212">1212: </a></span>
<span class="nocode"><a name="1213">1213: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1214">1214: </a></span>
<span class="nocode"><a name="1215">1215: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1216">1216: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1217">1217: </a></span>
<span class="nocode"><a name="1218">1218: </a></span>	// reverse this ArrayList 
<span class="nocode"><a name="1219">1219: </a></span>	Collections.reverse(testSubsetsList);
<span class="nocode"><a name="1220">1220: </a></span>	
<span class="nocode"><a name="1221">1221: </a></span>	// this is the number of tests that we have already included
<span class="nocode"><a name="1222">1222: </a></span>	// inside of the complete listing; initially we have not
<span class="nocode"><a name="1223">1223: </a></span>	// included any tests in the coverPickSets
<span class="nocode"><a name="1224">1224: </a></span>	int includedTests = 0;
<span class="nocode"><a name="1225">1225: </a></span>
<span class="nocode"><a name="1226">1226: </a></span>	// extract an Iterator of the testSubsetsList and then select
<span class="nocode"><a name="1227">1227: </a></span>	// the first targetSize tests and place them inside of
<span class="nocode"><a name="1228">1228: </a></span>	// coverPickSets
<span class="nocode"><a name="1229">1229: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1230">1230: </a></span>	while( testSubsetsIterator.hasNext() &amp;&amp; 
<span class="nocode"><a name="1231">1231: </a></span>	       includedTests &lt; targetSize )
<span class="nocode"><a name="1232">1232: </a></span>	    {
<span class="nocode"><a name="1233">1233: </a></span>
<span class="nocode"><a name="1234">1234: </a></span>// 		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="1235">1235: </a></span>// 		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1236">1236: </a></span>
<span class="nocode"><a name="1237">1237: </a></span>// 		coverPickSets.add(currentTestSubset.getTest());
<span class="nocode"><a name="1238">1238: </a></span>
<span class="nocode"><a name="1239">1239: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1240">1240: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1241">1241: </a></span>
<span class="nocode"><a name="1242">1242: </a></span>		coverPickSets.
<span class="nocode"><a name="1243">1243: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1244">1244: </a></span>
<span class="nocode"><a name="1245">1245: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1246">1246: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1247">1247: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1248">1248: </a></span>
<span class="nocode"><a name="1249">1249: </a></span>		includedTests++;
<span class="nocode"><a name="1250">1250: </a></span>
<span class="nocode"><a name="1251">1251: </a></span>	    }
<span class="nocode"><a name="1252">1252: </a></span>
<span class="nocode"><a name="1253">1253: </a></span>	// take the timing after
<span class="nocode"><a name="1254">1254: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1255">1255: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="1256">1256: </a></span>
<span class="nocode"><a name="1257">1257: </a></span>	return coverPickSets;
<span class="nocode"><a name="1258">1258: </a></span>
<span class="nocode"><a name="1259">1259: </a></span>    }
<span class="nocode"><a name="1260">1260: </a></span>
<span class="nocode"><a name="1261">1261: </a></span>    /**
<span class="nocode"><a name="1262">1262: </a></span>     *  Prioritize the test suite by reversing the order.  This basic
<span class="nocode"><a name="1263">1263: </a></span>     *  idea was suggested by Chandra Krintz when I met with her at
<span class="nocode"><a name="1264">1264: </a></span>     *  UCSB.
<span class="nocode"><a name="1265">1265: </a></span>     *  
<span class="nocode"><a name="1266">1266: </a></span>     *  @author Gregory M. Kapfhammer 12/3/2005
<span class="nocode"><a name="1267">1267: </a></span>     */
<span class="nocode"><a name="1268">1268: </a></span>    public Set prioritizeUsingReverse()
<span class="nocode"><a name="1269">1269: </a></span>    {
<span class="nocode"><a name="1270">1270: </a></span>
<span class="nocode"><a name="1271">1271: </a></span>	// take the timing before
<span class="nocode"><a name="1272">1272: </a></span>	long prioritizationTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1273">1273: </a></span>	
<span class="nocode"><a name="1274">1274: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1275">1275: </a></span>
<span class="nocode"><a name="1276">1276: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1277">1277: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1278">1278: </a></span>
<span class="nocode"><a name="1279">1279: </a></span>	// reverse this ArrayList 
<span class="nocode"><a name="1280">1280: </a></span>	Collections.reverse(testSubsetsList);
<span class="nocode"><a name="1281">1281: </a></span>       
<span class="nocode"><a name="1282">1282: </a></span>	// we have to go through them all and extract the 
<span class="nocode"><a name="1283">1283: </a></span>	// SingleTests since that what we are included.  This
<span class="nocode"><a name="1284">1284: </a></span>	// is not so good in terms of performance because
<span class="nocode"><a name="1285">1285: </a></span>	// we end up creating a O(n2) algorithm
<span class="nocode"><a name="1286">1286: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1287">1287: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="1288">1288: </a></span>	    {
<span class="nocode"><a name="1289">1289: </a></span>
<span class="nocode"><a name="1290">1290: </a></span>// 		coverPickSets.
<span class="nocode"><a name="1291">1291: </a></span>// 		    add( ( (SingleTestSubset) testSubsetsIterator.next() ).
<span class="nocode"><a name="1292">1292: </a></span>// 			 getTest() );
<span class="nocode"><a name="1293">1293: </a></span>
<span class="nocode"><a name="1294">1294: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1295">1295: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1296">1296: </a></span>
<span class="nocode"><a name="1297">1297: </a></span>		coverPickSets.
<span class="nocode"><a name="1298">1298: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1299">1299: </a></span>
<span class="nocode"><a name="1300">1300: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1301">1301: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1302">1302: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1303">1303: </a></span>
<span class="nocode"><a name="1304">1304: </a></span>	    }	
<span class="nocode"><a name="1305">1305: </a></span>
<span class="nocode"><a name="1306">1306: </a></span>	// take the timing after
<span class="nocode"><a name="1307">1307: </a></span>	long prioritizationTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1308">1308: </a></span>	prioritizationTime = (prioritizationTimeAfter - 
<span class="nocode"><a name="1309">1309: </a></span>			      prioritizationTimeBefore);
<span class="nocode"><a name="1310">1310: </a></span>
<span class="nocode"><a name="1311">1311: </a></span>	return coverPickSets;
<span class="nocode"><a name="1312">1312: </a></span>
<span class="nocode"><a name="1313">1313: </a></span>    }
<span class="nocode"><a name="1314">1314: </a></span>
<span class="nocode"><a name="1315">1315: </a></span>    /**
<span class="nocode"><a name="1316">1316: </a></span>     *  Prioritize the test suite by simply keeping the same 
<span class="nocode"><a name="1317">1317: </a></span>     *  order.  This is the untreated ordering.  We need this 
<span class="nocode"><a name="1318">1318: </a></span>     *  as an experiment control.
<span class="nocode"><a name="1319">1319: </a></span>     *  
<span class="nocode"><a name="1320">1320: </a></span>     *  @author Gregory M. Kapfhammer 7/10/2007
<span class="nocode"><a name="1321">1321: </a></span>     */
<span class="nocode"><a name="1322">1322: </a></span>    public Set prioritizeUsingOriginal()
<span class="nocode"><a name="1323">1323: </a></span>    {
<span class="nocode"><a name="1324">1324: </a></span>
<span class="nocode"><a name="1325">1325: </a></span>	// take the timing before
<span class="nocode"><a name="1326">1326: </a></span>	long prioritizationTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1327">1327: </a></span>	
<span class="nocode"><a name="1328">1328: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1329">1329: </a></span>
<span class="nocode"><a name="1330">1330: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1331">1331: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1332">1332: </a></span>       
<span class="nocode"><a name="1333">1333: </a></span>	// we have to go through them all and extract the SingleTests
<span class="nocode"><a name="1334">1334: </a></span>	// since that what we are included.  This is not so good in
<span class="nocode"><a name="1335">1335: </a></span>	// terms of performance because we end up creating a O(n2)
<span class="nocode"><a name="1336">1336: </a></span>	// algorithm
<span class="nocode"><a name="1337">1337: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1338">1338: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="1339">1339: </a></span>	    {
<span class="nocode"><a name="1340">1340: </a></span>
<span class="nocode"><a name="1341">1341: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1342">1342: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1343">1343: </a></span>
<span class="nocode"><a name="1344">1344: </a></span>		coverPickSets.
<span class="nocode"><a name="1345">1345: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1346">1346: </a></span>
<span class="nocode"><a name="1347">1347: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1348">1348: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1349">1349: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1350">1350: </a></span>
<span class="nocode"><a name="1351">1351: </a></span>	    }	
<span class="nocode"><a name="1352">1352: </a></span>
<span class="nocode"><a name="1353">1353: </a></span>	// take the timing after
<span class="nocode"><a name="1354">1354: </a></span>	long prioritizationTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1355">1355: </a></span>	prioritizationTime = (prioritizationTimeAfter - 
<span class="nocode"><a name="1356">1356: </a></span>			      prioritizationTimeBefore);
<span class="nocode"><a name="1357">1357: </a></span>
<span class="nocode"><a name="1358">1358: </a></span>	return coverPickSets;
<span class="nocode"><a name="1359">1359: </a></span>
<span class="nocode"><a name="1360">1360: </a></span>    }
<span class="nocode"><a name="1361">1361: </a></span>
<span class="nocode"><a name="1362">1362: </a></span>    /**
<span class="nocode"><a name="1363">1363: </a></span>     *  Reduces the test suite by taking tests cases from the front
<span class="nocode"><a name="1364">1364: </a></span>     *  of the test suite until we simply reach the target size.
<span class="nocode"><a name="1365">1365: </a></span>     *  This is supposed to be paired with the concept of reverse
<span class="nocode"><a name="1366">1366: </a></span>     *  prioritization.
<span class="nocode"><a name="1367">1367: </a></span>     *  
<span class="nocode"><a name="1368">1368: </a></span>     *  @author Gregory M. Kapfhammer 3/10/2007
<span class="nocode"><a name="1369">1369: </a></span>     */
<span class="nocode"><a name="1370">1370: </a></span>    public Set reduceUsingOriginal(int targetSize)
<span class="nocode"><a name="1371">1371: </a></span>    {
<span class="nocode"><a name="1372">1372: </a></span>
<span class="nocode"><a name="1373">1373: </a></span>	// take the timing before
<span class="nocode"><a name="1374">1374: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1375">1375: </a></span>
<span class="nocode"><a name="1376">1376: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="1377">1377: </a></span>
<span class="nocode"><a name="1378">1378: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1379">1379: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1380">1380: </a></span>
<span class="nocode"><a name="1381">1381: </a></span>	// this is the number of tests that we have already included
<span class="nocode"><a name="1382">1382: </a></span>	// inside of the complete listing; initially we have not
<span class="nocode"><a name="1383">1383: </a></span>	// included any tests in the coverPickSets
<span class="nocode"><a name="1384">1384: </a></span>	int includedTests = 0;
<span class="nocode"><a name="1385">1385: </a></span>
<span class="nocode"><a name="1386">1386: </a></span>	// extract an Iterator of the testSubsetsList and then select
<span class="nocode"><a name="1387">1387: </a></span>	// the first targetSize tests and place them inside of
<span class="nocode"><a name="1388">1388: </a></span>	// coverPickSets
<span class="nocode"><a name="1389">1389: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1390">1390: </a></span>	while( testSubsetsIterator.hasNext() &amp;&amp; 
<span class="nocode"><a name="1391">1391: </a></span>	       includedTests &lt; targetSize )
<span class="nocode"><a name="1392">1392: </a></span>	    {
<span class="nocode"><a name="1393">1393: </a></span>
<span class="nocode"><a name="1394">1394: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1395">1395: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1396">1396: </a></span>
<span class="nocode"><a name="1397">1397: </a></span>		coverPickSets.
<span class="nocode"><a name="1398">1398: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1399">1399: </a></span>
<span class="nocode"><a name="1400">1400: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1401">1401: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1402">1402: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1403">1403: </a></span>
<span class="nocode"><a name="1404">1404: </a></span>		includedTests++;
<span class="nocode"><a name="1405">1405: </a></span>
<span class="nocode"><a name="1406">1406: </a></span>	    }
<span class="nocode"><a name="1407">1407: </a></span>
<span class="nocode"><a name="1408">1408: </a></span>	// take the timing after
<span class="nocode"><a name="1409">1409: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1410">1410: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="1411">1411: </a></span>
<span class="nocode"><a name="1412">1412: </a></span>	return coverPickSets;
<span class="nocode"><a name="1413">1413: </a></span>
<span class="nocode"><a name="1414">1414: </a></span>    }
<span class="nocode"><a name="1415">1415: </a></span>
<span class="nocode"><a name="1416">1416: </a></span>   /**
<span class="nocode"><a name="1417">1417: </a></span>     *  Produces a random reduction of the test suite that is guaranteed
<span class="nocode"><a name="1418">1418: </a></span>     *  to be the same size as the reduced test suite that was produced
<span class="nocode"><a name="1419">1419: </a></span>     *  using the greedy approach.
<span class="nocode"><a name="1420">1420: </a></span>     *
<span class="nocode"><a name="1421">1421: </a></span>     *  This technique allows for the creation of an experimental
<span class="nocode"><a name="1422">1422: </a></span>     *  control when we are evaluating different reduction techniques.
<span class="nocode"><a name="1423">1423: </a></span>     *  Note that the size of the test suite and thus the percent
<span class="nocode"><a name="1424">1424: </a></span>     *  reduction in space will be the same as the test that was 
<span class="nocode"><a name="1425">1425: </a></span>     *  greedily reduced.  
<span class="nocode"><a name="1426">1426: </a></span>     *
<span class="nocode"><a name="1427">1427: </a></span>     *  However, the reduction in time overhead can vary considerably
<span class="nocode"><a name="1428">1428: </a></span>     *  and the final change in the defect detection ratio can also 
<span class="nocode"><a name="1429">1429: </a></span>     *  change.  This type of experimental control is also used in 
<span class="nocode"><a name="1430">1430: </a></span>     *  papers by Memon and Rothermel.
<span class="nocode"><a name="1431">1431: </a></span>     *  
<span class="nocode"><a name="1432">1432: </a></span>     *  NOTE: this version using Mathematica to create a specified
<span class="nocode"><a name="1433">1433: </a></span>     *  number of test suites that are all randomly reduced.
<span class="nocode"><a name="1434">1434: </a></span>     *
<span class="nocode"><a name="1435">1435: </a></span>     *  @author Gregory M. Kapfhammer 10/13/2005
<span class="nocode"><a name="1436">1436: </a></span>     */
<span class="nocode"><a name="1437">1437: </a></span>/*
<span class="nocode"><a name="1438">1438: </a></span>
<span class="nocode"><a name="1439">1439: </a></span> * Commented out on Nov 30, 2007 by Adam M. Smith to avoid MathLink, Jlink, KernelLink dependencies
<span class="nocode"><a name="1440">1440: </a></span>
<span class="nocode"><a name="1441">1441: </a></span>    public Set reduceUsingRandom(int desiredReductionSize,
<span class="nocode"><a name="1442">1442: </a></span>				 int desiredReductions)
<span class="nocode"><a name="1443">1443: </a></span>    {
<span class="nocode"><a name="1444">1444: </a></span>
<span class="nocode"><a name="1445">1445: </a></span>	// this is the final &quot;set of sets&quot; that was produced it must
<span class="nocode"><a name="1446">1446: </a></span>	// included a total of desiredReductions that are all of size
<span class="nocode"><a name="1447">1447: </a></span>	// desiredReductionSize
<span class="nocode"><a name="1448">1448: </a></span>	LinkedHashSet setOfReducedSets = new LinkedHashSet();
<span class="nocode"><a name="1449">1449: </a></span>	
<span class="nocode"><a name="1450">1450: </a></span>	// this HashMap will store the test names and the actual
<span class="nocode"><a name="1451">1451: </a></span>	// SingleTestSubsets so that they can be retrieved later
<span class="nocode"><a name="1452">1452: </a></span>	LinkedHashMap fullTestSuite = new LinkedHashMap();
<span class="nocode"><a name="1453">1453: </a></span>
<span class="nocode"><a name="1454">1454: </a></span>	// create the Strings that are going to be essentially
<span class="nocode"><a name="1455">1455: </a></span>	// constants for every call to Mathematica and only operate on
<span class="nocode"><a name="1456">1456: </a></span>	// the other variables that are indeed going to change
<span class="nocode"><a name="1457">1457: </a></span>	String loadCombinatorica = &quot;&lt;&lt; DiscreteMath`Combinatorica`;&quot;;
<span class="nocode"><a name="1458">1458: </a></span>	String finalTestSuiteReductions = &quot;finalTestSuiteReductions = {};&quot;;
<span class="nocode"><a name="1459">1459: </a></span>	String bigCodeSegment = 
<span class="nocode"><a name="1460">1460: </a></span>     &quot;testSubsets = Subsets[testSuiteReduction, {desiredReductionSize}];&quot; + 
<span class="nocode"><a name="1461">1461: </a></span>     &quot;randomTestSubsetIndex = Random[Integer, Length[testSubsets]];&quot; + 
<span class="nocode"><a name="1462">1462: </a></span>     &quot;currentTestSubset = testSubsets[[randomTestSubsetIndex]];&quot; + 
<span class="nocode"><a name="1463">1463: </a></span>     &quot;indexIntoTestSubsets = 0;&quot; + 
<span class="nocode"><a name="1464">1464: </a></span>     &quot;While[Length[finalTestSuiteReductions] &lt; desiredReductions,&quot; +  
<span class="nocode"><a name="1465">1465: </a></span>     &quot;randomTestSubsetIndex = Random[Integer, {1,Length[testSubsets]}];&quot; + 
<span class="nocode"><a name="1466">1466: </a></span>     &quot;currentTestSubset = testSubsets[[randomTestSubsetIndex]];&quot; + 
<span class="nocode"><a name="1467">1467: </a></span>     &quot;currentTestSubsetPermutation = RandomPermutation[currentTestSubset];&quot; + 
<span class="nocode"><a name="1468">1468: </a></span>     &quot;If[MemberQ[finalTestSuiteReductions, currentTestSubsetPermutation],&quot; +
<span class="nocode"><a name="1469">1469: </a></span>        &quot;duplicate,&quot; +  
<span class="nocode"><a name="1470">1470: </a></span>     &quot;AppendTo[finalTestSuiteReductions, currentTestSubsetPermutation]]];&quot; + 
<span class="nocode"><a name="1471">1471: </a></span>//&quot;SameQ[Sort[finalTestSuiteReductions], Union[finalTestSuiteReductions]]&quot; +
<span class="nocode"><a name="1472">1472: </a></span>     &quot;finalTestSuiteReductions&quot;;
<span class="nocode"><a name="1473">1473: </a></span>
<span class="nocode"><a name="1474">1474: </a></span>	// the size of the reductions that is being requested
<span class="nocode"><a name="1475">1475: </a></span>	String desiredReductionSizeMath = &quot;desiredReductionSize = &quot; + 
<span class="nocode"><a name="1476">1476: </a></span>	    desiredReductionSize + &quot;;&quot;;
<span class="nocode"><a name="1477">1477: </a></span>
<span class="nocode"><a name="1478">1478: </a></span>	// the number of reductions that are being requested
<span class="nocode"><a name="1479">1479: </a></span>	String desiredReductionsMath = &quot;desiredReductions = &quot; + 
<span class="nocode"><a name="1480">1480: </a></span>	    desiredReductions + &quot;;&quot;;
<span class="nocode"><a name="1481">1481: </a></span>	
<span class="nocode"><a name="1482">1482: </a></span>	// this StringBuffer will store the final listing of the 
<span class="nocode"><a name="1483">1483: </a></span>	// tests that will be submitted to the Mathematica
<span class="nocode"><a name="1484">1484: </a></span>	StringBuffer testSuiteReduction = new StringBuffer();
<span class="nocode"><a name="1485">1485: </a></span>
<span class="nocode"><a name="1486">1486: </a></span>	// we have to add the beginning of this String 
<span class="nocode"><a name="1487">1487: </a></span>	testSuiteReduction.append(&quot;testSuiteReduction = {&quot;);
<span class="nocode"><a name="1488">1488: </a></span>
<span class="nocode"><a name="1489">1489: </a></span>	// go through the testSubsets and build up a String that 
<span class="nocode"><a name="1490">1490: </a></span>	// represents them all -- on the side, build up a HashMap
<span class="nocode"><a name="1491">1491: </a></span>	// that is for the String and the SingleTestSubset that 
<span class="nocode"><a name="1492">1492: </a></span>	// is associated with the String
<span class="nocode"><a name="1493">1493: </a></span>	
<span class="nocode"><a name="1494">1494: </a></span>	Iterator testSetIterator = testSubsets.iterator();
<span class="nocode"><a name="1495">1495: </a></span>	while( testSetIterator.hasNext() )
<span class="nocode"><a name="1496">1496: </a></span>	    {
<span class="nocode"><a name="1497">1497: </a></span>
<span class="nocode"><a name="1498">1498: </a></span>		// extract the next SingleTestSubset
<span class="nocode"><a name="1499">1499: </a></span>		SingleTestSubset nextTestSubset = 
<span class="nocode"><a name="1500">1500: </a></span>		    (SingleTestSubset) testSetIterator.next();
<span class="nocode"><a name="1501">1501: </a></span>
<span class="nocode"><a name="1502">1502: </a></span>		// place this inside the HashMap using the key 
<span class="nocode"><a name="1503">1503: </a></span>		// and value pair that is formatted at (test name,
<span class="nocode"><a name="1504">1504: </a></span>		// nextTestSubset)
<span class="nocode"><a name="1505">1505: </a></span>		fullTestSuite.put(nextTestSubset.getTest().getName(),
<span class="nocode"><a name="1506">1506: </a></span>				  nextTestSubset.getTest());
<span class="nocode"><a name="1507">1507: </a></span>
<span class="nocode"><a name="1508">1508: </a></span>		// put the name of the test inside of the StringBuffer
<span class="nocode"><a name="1509">1509: </a></span>		// so that we can submit it to Mathematica
<span class="nocode"><a name="1510">1510: </a></span>		testSuiteReduction.append(nextTestSubset.getTest().
<span class="nocode"><a name="1511">1511: </a></span>					  getName());
<span class="nocode"><a name="1512">1512: </a></span>
<span class="nocode"><a name="1513">1513: </a></span>		// there is still going to be another test that
<span class="nocode"><a name="1514">1514: </a></span>		// we have to append and thus we need to include
<span class="nocode"><a name="1515">1515: </a></span>		// the final comma at the end
<span class="nocode"><a name="1516">1516: </a></span>		if( testSetIterator.hasNext() )
<span class="nocode"><a name="1517">1517: </a></span>		    {
<span class="nocode"><a name="1518">1518: </a></span>
<span class="nocode"><a name="1519">1519: </a></span>			testSuiteReduction.append(&quot;, &quot;);
<span class="nocode"><a name="1520">1520: </a></span>
<span class="nocode"><a name="1521">1521: </a></span>		    }
<span class="nocode"><a name="1522">1522: </a></span>
<span class="nocode"><a name="1523">1523: </a></span>	    }
<span class="nocode"><a name="1524">1524: </a></span>
<span class="nocode"><a name="1525">1525: </a></span>	// we have to add on the closing to the test suite for reduction
<span class="nocode"><a name="1526">1526: </a></span>	testSuiteReduction.append(&quot;};&quot;);
<span class="nocode"><a name="1527">1527: </a></span>
<span class="nocode"><a name="1528">1528: </a></span>	//System.out.println(fullTestSuite);
<span class="nocode"><a name="1529">1529: </a></span>	
<span class="nocode"><a name="1530">1530: </a></span>	// we are now done building up everything that has to be sent
<span class="nocode"><a name="1531">1531: </a></span>	// to Mathematica and we just to initialize the mathematica
<span class="nocode"><a name="1532">1532: </a></span>	// connection and then send the information off and handle
<span class="nocode"><a name="1533">1533: </a></span>	// the result (more String parsing required)
<span class="nocode"><a name="1534">1534: </a></span>
<span class="nocode"><a name="1535">1535: </a></span>	KernelLink ml = null;
<span class="nocode"><a name="1536">1536: </a></span>	String mathematicaConnect = 
<span class="nocode"><a name="1537">1537: </a></span>	    &quot;-linkmode launch -linkname \'math -mathlink\'&quot;;
<span class="nocode"><a name="1538">1538: </a></span>
<span class="nocode"><a name="1539">1539: </a></span>	try 
<span class="nocode"><a name="1540">1540: </a></span>	    {
<span class="nocode"><a name="1541">1541: </a></span>		
<span class="nocode"><a name="1542">1542: </a></span>		ml = MathLinkFactory.
<span class="nocode"><a name="1543">1543: </a></span>		    createKernelLink(mathematicaConnect);
<span class="nocode"><a name="1544">1544: </a></span>		
<span class="nocode"><a name="1545">1545: </a></span>	    } 
<span class="nocode"><a name="1546">1546: </a></span>
<span class="nocode"><a name="1547">1547: </a></span>	catch (MathLinkException e) 
<span class="nocode"><a name="1548">1548: </a></span>	    {
<span class="nocode"><a name="1549">1549: </a></span>		
<span class="nocode"><a name="1550">1550: </a></span>		System.out.println(&quot;Fatal error opening link: &quot; + 
<span class="nocode"><a name="1551">1551: </a></span>				   e.getMessage());
<span class="nocode"><a name="1552">1552: </a></span>		e.printStackTrace();
<span class="nocode"><a name="1553">1553: </a></span>	    
<span class="nocode"><a name="1554">1554: </a></span>	    }
<span class="nocode"><a name="1555">1555: </a></span>
<span class="nocode"><a name="1556">1556: </a></span>	try 
<span class="nocode"><a name="1557">1557: </a></span>	    {
<span class="nocode"><a name="1558">1558: </a></span>			
<span class="nocode"><a name="1559">1559: </a></span>		// Get rid of the initial InputNamePacket the kernel
<span class="nocode"><a name="1560">1560: </a></span>		// will send when it is launched.
<span class="nocode"><a name="1561">1561: </a></span>		ml.discardAnswer();
<span class="nocode"><a name="1562">1562: </a></span>			
<span class="nocode"><a name="1563">1563: </a></span>// 		System.out.println( //loadCombinatorica + 
<span class="nocode"><a name="1564">1564: </a></span>// 				    //&quot;Pause[2];&quot; + 
<span class="nocode"><a name="1565">1565: </a></span>// 				    finalTestSuiteReductions +
<span class="nocode"><a name="1566">1566: </a></span>// 				    desiredReductionsMath + 
<span class="nocode"><a name="1567">1567: </a></span>// 				    desiredReductionSizeMath + 
<span class="nocode"><a name="1568">1568: </a></span>// 				    testSuiteReduction.toString() + 
<span class="nocode"><a name="1569">1569: </a></span>// 				    bigCodeSegment );
<span class="nocode"><a name="1570">1570: </a></span>
<span class="nocode"><a name="1571">1571: </a></span>		// load the combinatorica package separately; this
<span class="nocode"><a name="1572">1572: </a></span>		// will be &quot;resident&quot; when we execute the next command
<span class="nocode"><a name="1573">1573: </a></span>		// (timing might dictate that this approach does not
<span class="nocode"><a name="1574">1574: </a></span>		// always execute correctly)
<span class="nocode"><a name="1575">1575: </a></span>		ml.evaluate(loadCombinatorica);
<span class="nocode"><a name="1576">1576: </a></span>		ml.discardAnswer();
<span class="nocode"><a name="1577">1577: </a></span>		
<span class="nocode"><a name="1578">1578: </a></span>		//Thread.currentThread().sleep(3000);
<span class="nocode"><a name="1579">1579: </a></span>
<span class="nocode"><a name="1580">1580: </a></span>		// send the final string to Mathematica through 
<span class="nocode"><a name="1581">1581: </a></span>		// J/Link and retrieve the answer as a string
<span class="nocode"><a name="1582">1582: </a></span>		String solve = ml.
<span class="nocode"><a name="1583">1583: </a></span>		    evaluateToOutputForm( //loadCombinatorica + 
<span class="nocode"><a name="1584">1584: </a></span>					  //&quot;Pause[3];&quot; + 
<span class="nocode"><a name="1585">1585: </a></span>					  finalTestSuiteReductions +
<span class="nocode"><a name="1586">1586: </a></span>					  desiredReductionsMath + 
<span class="nocode"><a name="1587">1587: </a></span>					  desiredReductionSizeMath + 
<span class="nocode"><a name="1588">1588: </a></span>					  testSuiteReduction.toString() + 
<span class="nocode"><a name="1589">1589: </a></span>					  bigCodeSegment, 0 );
<span class="nocode"><a name="1590">1590: </a></span>		    
<span class="nocode"><a name="1591">1591: </a></span>		//System.out.println(&quot;solve = &quot; + solve);
<span class="nocode"><a name="1592">1592: </a></span>
<span class="nocode"><a name="1593">1593: </a></span>		// we have the final String from Mathematica and 
<span class="nocode"><a name="1594">1594: </a></span>		// now we need to parse it correctly and then 
<span class="nocode"><a name="1595">1595: </a></span>		// return the final &quot;set of sets&quot; back to the 
<span class="nocode"><a name="1596">1596: </a></span>		// calling program
<span class="nocode"><a name="1597">1597: </a></span>		ArrayList testList = Util.
<span class="nocode"><a name="1598">1598: </a></span>		    generateTestNames(solve);
<span class="nocode"><a name="1599">1599: </a></span>
<span class="nocode"><a name="1600">1600: </a></span>		// we need an ArrayList that is going to store each of
<span class="nocode"><a name="1601">1601: </a></span>		// the individual reductions; NOTE that this cannot be
<span class="nocode"><a name="1602">1602: </a></span>		// a Set because then they will appear to be the same
<span class="nocode"><a name="1603">1603: </a></span>		// since the set does not preserve order!
<span class="nocode"><a name="1604">1604: </a></span>		ArrayList internalSet = new ArrayList();
<span class="nocode"><a name="1605">1605: </a></span>		
<span class="nocode"><a name="1606">1606: </a></span>		// for debugging purposes (corresponds to println)
<span class="nocode"><a name="1607">1607: </a></span>		int i = 1;
<span class="nocode"><a name="1608">1608: </a></span>
<span class="nocode"><a name="1609">1609: </a></span>		// go through each one of the separate ArrayLists and 
<span class="nocode"><a name="1610">1610: </a></span>		// retrieve the SingleTests that are inside of the 
<span class="nocode"><a name="1611">1611: </a></span>		// HashMap in order to make the final &quot;Set of Sets&quot;
<span class="nocode"><a name="1612">1612: </a></span>		Iterator testListIterator = testList.iterator();
<span class="nocode"><a name="1613">1613: </a></span>		while( testListIterator.hasNext() )
<span class="nocode"><a name="1614">1614: </a></span>		    {
<span class="nocode"><a name="1615">1615: </a></span>
<span class="nocode"><a name="1616">1616: </a></span>			// extract an ArrayList and an Iterator the
<span class="nocode"><a name="1617">1617: </a></span>			// current internal listing
<span class="nocode"><a name="1618">1618: </a></span>			ArrayList internalTestList = 
<span class="nocode"><a name="1619">1619: </a></span>			    (ArrayList) testListIterator.next();
<span class="nocode"><a name="1620">1620: </a></span>			Iterator internalTestListIterator = 
<span class="nocode"><a name="1621">1621: </a></span>			    internalTestList.iterator();
<span class="nocode"><a name="1622">1622: </a></span>			while( internalTestListIterator.hasNext() )
<span class="nocode"><a name="1623">1623: </a></span>			    {
<span class="nocode"><a name="1624">1624: </a></span>
<span class="nocode"><a name="1625">1625: </a></span>				// extract the current name of the
<span class="nocode"><a name="1626">1626: </a></span>				// test and then check into the
<span class="nocode"><a name="1627">1627: </a></span>				// HashMap
<span class="nocode"><a name="1628">1628: </a></span>				String currentTestName = 
<span class="nocode"><a name="1629">1629: </a></span>				    (String) internalTestListIterator.next();
<span class="nocode"><a name="1630">1630: </a></span>
<span class="nocode"><a name="1631">1631: </a></span>				//System.out.println(currentTestName);
<span class="nocode"><a name="1632">1632: </a></span>
<span class="nocode"><a name="1633">1633: </a></span>				// put in the real SingleTest
<span class="nocode"><a name="1634">1634: </a></span>				internalSet.add(fullTestSuite.
<span class="nocode"><a name="1635">1635: </a></span>						get(currentTestName));
<span class="nocode"><a name="1636">1636: </a></span>
<span class="nocode"><a name="1637">1637: </a></span>			    }			
<span class="nocode"><a name="1638">1638: </a></span>
<span class="nocode"><a name="1639">1639: </a></span>			//System.out.println(i + &quot; finished: &quot; + 
<span class="nocode"><a name="1640">1640: </a></span>			//		   internalSet);
<span class="nocode"><a name="1641">1641: </a></span>			i++;
<span class="nocode"><a name="1642">1642: </a></span>
<span class="nocode"><a name="1643">1643: </a></span>			// add in the current internalSet and then
<span class="nocode"><a name="1644">1644: </a></span>			// clone it and clear it so that it can 
<span class="nocode"><a name="1645">1645: </a></span>			// be used again while avoiding the Java
<span class="nocode"><a name="1646">1646: </a></span>			// reference problem
<span class="nocode"><a name="1647">1647: </a></span>			setOfReducedSets.add(internalSet);
<span class="nocode"><a name="1648">1648: </a></span>			internalSet = (ArrayList)internalSet.clone();
<span class="nocode"><a name="1649">1649: </a></span>			internalSet.clear();
<span class="nocode"><a name="1650">1650: </a></span>
<span class="nocode"><a name="1651">1651: </a></span>		    }
<span class="nocode"><a name="1652">1652: </a></span>
<span class="nocode"><a name="1653">1653: </a></span>	    }
<span class="nocode"><a name="1654">1654: </a></span>
<span class="nocode"><a name="1655">1655: </a></span>	catch(Exception e)
<span class="nocode"><a name="1656">1656: </a></span>	    {
<span class="nocode"><a name="1657">1657: </a></span>
<span class="nocode"><a name="1658">1658: </a></span>		System.out.println(&quot;Problem reducing in a random fashion.&quot;);
<span class="nocode"><a name="1659">1659: </a></span>		e.printStackTrace();
<span class="nocode"><a name="1660">1660: </a></span>
<span class="nocode"><a name="1661">1661: </a></span>	    }
<span class="nocode"><a name="1662">1662: </a></span>
<span class="nocode"><a name="1663">1663: </a></span>	
<span class="nocode"><a name="1664">1664: </a></span>	finally 
<span class="nocode"><a name="1665">1665: </a></span>	    {
<span class="nocode"><a name="1666">1666: </a></span>		
<span class="nocode"><a name="1667">1667: </a></span>		ml.close();
<span class="nocode"><a name="1668">1668: </a></span>		
<span class="nocode"><a name="1669">1669: </a></span>	    }
<span class="nocode"><a name="1670">1670: </a></span>
<span class="nocode"><a name="1671">1671: </a></span>	return setOfReducedSets;
<span class="nocode"><a name="1672">1672: </a></span>
<span class="nocode"><a name="1673">1673: </a></span>    }
<span class="nocode"><a name="1674">1674: </a></span>*/
<span class="nocode"><a name="1675">1675: </a></span>    /**
<span class="nocode"><a name="1676">1676: </a></span>     *  Produces a random prioritization of the test suite that is
<span class="nocode"><a name="1677">1677: </a></span>     *  guaranteed to be the same size as the original test suite.
<span class="nocode"><a name="1678">1678: </a></span>     *
<span class="nocode"><a name="1679">1679: </a></span>     *  This technique allows for the creation of an experimental
<span class="nocode"><a name="1680">1680: </a></span>     *  control when we are evaluating different prioritization
<span class="nocode"><a name="1681">1681: </a></span>     *  techniques.  
<span class="nocode"><a name="1682">1682: </a></span>     *  
<span class="nocode"><a name="1683">1683: </a></span>     *  NOTE: this version is using Mathematica to create a specified
<span class="nocode"><a name="1684">1684: </a></span>     *  number of test suites that are all randomly prioritized.
<span class="nocode"><a name="1685">1685: </a></span>     *
<span class="nocode"><a name="1686">1686: </a></span>     *  @author Gregory M. Kapfhammer 12/1/2005
<span class="nocode"><a name="1687">1687: </a></span>     */
<span class="nocode"><a name="1688">1688: </a></span>
<span class="nocode"><a name="1689">1689: </a></span>/*
<span class="nocode"><a name="1690">1690: </a></span>
<span class="nocode"><a name="1691">1691: </a></span> * Commented out on Nov 30, 2007 by Adam M. Smith to avoid MathLink, Jlink, KernelLink dependencies
<span class="nocode"><a name="1692">1692: </a></span>
<span class="nocode"><a name="1693">1693: </a></span>    public Set prioritizeUsingRandom(int desiredPermutations)
<span class="nocode"><a name="1694">1694: </a></span>    {
<span class="nocode"><a name="1695">1695: </a></span>
<span class="nocode"><a name="1696">1696: </a></span>	// this is the final &quot;set of sets&quot; that was produced it must
<span class="nocode"><a name="1697">1697: </a></span>	// included a total of desiredReductions that are all of size
<span class="nocode"><a name="1698">1698: </a></span>	// desiredReductionSize
<span class="nocode"><a name="1699">1699: </a></span>	LinkedHashSet setOfPrioritizedSets = new LinkedHashSet();
<span class="nocode"><a name="1700">1700: </a></span>	
<span class="nocode"><a name="1701">1701: </a></span>	// this HashMap will store the test names and the actual
<span class="nocode"><a name="1702">1702: </a></span>	// SingleTestSubsets so that they can be retrieved later
<span class="nocode"><a name="1703">1703: </a></span>	LinkedHashMap fullTestSuite = new LinkedHashMap();
<span class="nocode"><a name="1704">1704: </a></span>
<span class="nocode"><a name="1705">1705: </a></span>	// create the Strings that are going to be essentially
<span class="nocode"><a name="1706">1706: </a></span>	// constants for every call to Mathematica and only operate on
<span class="nocode"><a name="1707">1707: </a></span>	// the other variables that are indeed going to change
<span class="nocode"><a name="1708">1708: </a></span>	String loadCombinatorica = &quot;&lt;&lt; DiscreteMath`Combinatorica`;&quot;;
<span class="nocode"><a name="1709">1709: </a></span>	String finalTestSuitePermutations = 
<span class="nocode"><a name="1710">1710: </a></span>	    &quot;finalTestSuitePermutations = {};&quot;;
<span class="nocode"><a name="1711">1711: </a></span>	String bigCodeSegment = 
<span class="nocode"><a name="1712">1712: </a></span>	    &quot;While[Length[finalTestSuitePermutations] &lt; desiredPermutations,&quot; +
<span class="nocode"><a name="1713">1713: </a></span>	    &quot;currentPermutation = RandomPermutation[testSuitePrioritize];&quot; +
<span class="nocode"><a name="1714">1714: </a></span>    &quot;If[MemberQ[finalTestSuitePermutations, currentPermutation], duplicate,&quot; +
<span class="nocode"><a name="1715">1715: </a></span>    &quot;AppendTo[finalTestSuitePermutations, currentPermutation]]];&quot; + 
<span class="nocode"><a name="1716">1716: </a></span>            &quot;finalTestSuitePermutations&quot;;
<span class="nocode"><a name="1717">1717: </a></span>
<span class="nocode"><a name="1718">1718: </a></span>	// the number of prioritizations that are being requested
<span class="nocode"><a name="1719">1719: </a></span>	String desiredPermutationsMath = &quot;desiredPermutations =&quot; + 
<span class="nocode"><a name="1720">1720: </a></span>	    desiredPermutations + &quot;;&quot;;
<span class="nocode"><a name="1721">1721: </a></span>
<span class="nocode"><a name="1722">1722: </a></span>	// this StringBuffer will store the final listing of the 
<span class="nocode"><a name="1723">1723: </a></span>	// tests that will be submitted to the Mathematica
<span class="nocode"><a name="1724">1724: </a></span>	StringBuffer testSuitePrioritize = new StringBuffer();
<span class="nocode"><a name="1725">1725: </a></span>
<span class="nocode"><a name="1726">1726: </a></span>	// we have to add the beginning of this String 
<span class="nocode"><a name="1727">1727: </a></span>	testSuitePrioritize.append(&quot;testSuitePrioritize = {&quot;);
<span class="nocode"><a name="1728">1728: </a></span>
<span class="nocode"><a name="1729">1729: </a></span>	// go through the testSubsets and build up a String that 
<span class="nocode"><a name="1730">1730: </a></span>	// represents them all -- on the side, build up a HashMap
<span class="nocode"><a name="1731">1731: </a></span>	// that is for the String and the SingleTestSubset that 
<span class="nocode"><a name="1732">1732: </a></span>	// is associated with the String
<span class="nocode"><a name="1733">1733: </a></span>	
<span class="nocode"><a name="1734">1734: </a></span>	Iterator testSetIterator = testSubsets.iterator();
<span class="nocode"><a name="1735">1735: </a></span>	while( testSetIterator.hasNext() )
<span class="nocode"><a name="1736">1736: </a></span>	    {
<span class="nocode"><a name="1737">1737: </a></span>
<span class="nocode"><a name="1738">1738: </a></span>		// extract the next SingleTestSubset
<span class="nocode"><a name="1739">1739: </a></span>		SingleTestSubset nextTestSubset = 
<span class="nocode"><a name="1740">1740: </a></span>		    (SingleTestSubset) testSetIterator.next();
<span class="nocode"><a name="1741">1741: </a></span>
<span class="nocode"><a name="1742">1742: </a></span>		// place this inside the HashMap using the key 
<span class="nocode"><a name="1743">1743: </a></span>		// and value pair that is formatted at (test name,
<span class="nocode"><a name="1744">1744: </a></span>		// nextTestSubset)
<span class="nocode"><a name="1745">1745: </a></span>		fullTestSuite.put(nextTestSubset.getTest().getName(),
<span class="nocode"><a name="1746">1746: </a></span>				  nextTestSubset.getTest());
<span class="nocode"><a name="1747">1747: </a></span>
<span class="nocode"><a name="1748">1748: </a></span>		// put the name of the test inside of the StringBuffer
<span class="nocode"><a name="1749">1749: </a></span>		// so that we can submit it to Mathematica
<span class="nocode"><a name="1750">1750: </a></span>		testSuitePrioritize.append(nextTestSubset.getTest().
<span class="nocode"><a name="1751">1751: </a></span>					  getName());
<span class="nocode"><a name="1752">1752: </a></span>
<span class="nocode"><a name="1753">1753: </a></span>		// there is still going to be another test that
<span class="nocode"><a name="1754">1754: </a></span>		// we have to append and thus we need to include
<span class="nocode"><a name="1755">1755: </a></span>		// the final comma at the end
<span class="nocode"><a name="1756">1756: </a></span>		if( testSetIterator.hasNext() )
<span class="nocode"><a name="1757">1757: </a></span>		    {
<span class="nocode"><a name="1758">1758: </a></span>
<span class="nocode"><a name="1759">1759: </a></span>			testSuitePrioritize.append(&quot;, &quot;);
<span class="nocode"><a name="1760">1760: </a></span>
<span class="nocode"><a name="1761">1761: </a></span>		    }
<span class="nocode"><a name="1762">1762: </a></span>
<span class="nocode"><a name="1763">1763: </a></span>	    }
<span class="nocode"><a name="1764">1764: </a></span>
<span class="nocode"><a name="1765">1765: </a></span>	// we have to add on the closing to the test suite for reduction
<span class="nocode"><a name="1766">1766: </a></span>	testSuitePrioritize.append(&quot;};&quot;);
<span class="nocode"><a name="1767">1767: </a></span>
<span class="nocode"><a name="1768">1768: </a></span>// 	System.out.println(&quot;testSuitePrioritize = &quot; + 
<span class="nocode"><a name="1769">1769: </a></span>// 			   testSuitePrioritize);
<span class="nocode"><a name="1770">1770: </a></span>
<span class="nocode"><a name="1771">1771: </a></span>	//System.out.println(fullTestSuite);
<span class="nocode"><a name="1772">1772: </a></span>	
<span class="nocode"><a name="1773">1773: </a></span>	// we are now done building up everything that has to be sent
<span class="nocode"><a name="1774">1774: </a></span>	// to Mathematica and we just to initialize the mathematica
<span class="nocode"><a name="1775">1775: </a></span>	// connection and then send the information off and handle
<span class="nocode"><a name="1776">1776: </a></span>	// the result (more String parsing required)
<span class="nocode"><a name="1777">1777: </a></span>
<span class="nocode"><a name="1778">1778: </a></span>		KernelLink ml = null;
<span class="nocode"><a name="1779">1779: </a></span>	String mathematicaConnect = 
<span class="nocode"><a name="1780">1780: </a></span>	    &quot;-linkmode launch -linkname \'math -mathlink\'&quot;;
<span class="nocode"><a name="1781">1781: </a></span>
<span class="nocode"><a name="1782">1782: </a></span>	try 
<span class="nocode"><a name="1783">1783: </a></span>	    {
<span class="nocode"><a name="1784">1784: </a></span>		
<span class="nocode"><a name="1785">1785: </a></span>		ml = MathLinkFactory.
<span class="nocode"><a name="1786">1786: </a></span>		    createKernelLink(mathematicaConnect);
<span class="nocode"><a name="1787">1787: </a></span>		
<span class="nocode"><a name="1788">1788: </a></span>	    } 
<span class="nocode"><a name="1789">1789: </a></span>
<span class="nocode"><a name="1790">1790: </a></span>	catch (MathLinkException e) 
<span class="nocode"><a name="1791">1791: </a></span>	    {
<span class="nocode"><a name="1792">1792: </a></span>		
<span class="nocode"><a name="1793">1793: </a></span>		System.out.println(&quot;Fatal error opening link: &quot; + 
<span class="nocode"><a name="1794">1794: </a></span>				   e.getMessage());
<span class="nocode"><a name="1795">1795: </a></span>		e.printStackTrace();
<span class="nocode"><a name="1796">1796: </a></span>	    
<span class="nocode"><a name="1797">1797: </a></span>	    }
<span class="nocode"><a name="1798">1798: </a></span>
<span class="nocode"><a name="1799">1799: </a></span>	try 
<span class="nocode"><a name="1800">1800: </a></span>	    {
<span class="nocode"><a name="1801">1801: </a></span>			
<span class="nocode"><a name="1802">1802: </a></span>		// Get rid of the initial InputNamePacket the kernel
<span class="nocode"><a name="1803">1803: </a></span>		// will send when it is launched.
<span class="nocode"><a name="1804">1804: </a></span>		ml.discardAnswer();
<span class="nocode"><a name="1805">1805: </a></span>			
<span class="nocode"><a name="1806">1806: </a></span>		System.out.println( //loadCombinatorica + 
<span class="nocode"><a name="1807">1807: </a></span>				    //&quot;Pause[2];&quot; + 
<span class="nocode"><a name="1808">1808: </a></span>				    finalTestSuitePermutations +
<span class="nocode"><a name="1809">1809: </a></span>				    desiredPermutationsMath + 
<span class="nocode"><a name="1810">1810: </a></span>				    testSuitePrioritize.toString() + 
<span class="nocode"><a name="1811">1811: </a></span>				    bigCodeSegment );
<span class="nocode"><a name="1812">1812: </a></span>
<span class="nocode"><a name="1813">1813: </a></span>		// load the combinatorica package separately; this
<span class="nocode"><a name="1814">1814: </a></span>		// will be &quot;resident&quot; when we execute the next command
<span class="nocode"><a name="1815">1815: </a></span>		// (timing might dictate that this approach does not
<span class="nocode"><a name="1816">1816: </a></span>		// always execute correctly)
<span class="nocode"><a name="1817">1817: </a></span>		ml.evaluate(loadCombinatorica);
<span class="nocode"><a name="1818">1818: </a></span>		ml.discardAnswer();
<span class="nocode"><a name="1819">1819: </a></span>		
<span class="nocode"><a name="1820">1820: </a></span>		//Thread.currentThread().sleep(3000);
<span class="nocode"><a name="1821">1821: </a></span>
<span class="nocode"><a name="1822">1822: </a></span>		// send the final string to Mathematica through 
<span class="nocode"><a name="1823">1823: </a></span>		// J/Link and retrieve the answer as a string
<span class="nocode"><a name="1824">1824: </a></span>		String solve = ml.
<span class="nocode"><a name="1825">1825: </a></span>		    evaluateToOutputForm(finalTestSuitePermutations +
<span class="nocode"><a name="1826">1826: </a></span>					 desiredPermutationsMath + 
<span class="nocode"><a name="1827">1827: </a></span>					 testSuitePrioritize.toString() + 
<span class="nocode"><a name="1828">1828: </a></span>					 bigCodeSegment, 0 );
<span class="nocode"><a name="1829">1829: </a></span>		    
<span class="nocode"><a name="1830">1830: </a></span>// 		System.out.println(&quot;solve = &quot; + solve);
<span class="nocode"><a name="1831">1831: </a></span>
<span class="nocode"><a name="1832">1832: </a></span>		// we have the final String from Mathematica and 
<span class="nocode"><a name="1833">1833: </a></span>		// now we need to parse it correctly and then 
<span class="nocode"><a name="1834">1834: </a></span>		// return the final &quot;set of sets&quot; back to the 
<span class="nocode"><a name="1835">1835: </a></span>		// calling program
<span class="nocode"><a name="1836">1836: </a></span>		ArrayList testList = Util.
<span class="nocode"><a name="1837">1837: </a></span>		    generateTestNames(solve);
<span class="nocode"><a name="1838">1838: </a></span>
<span class="nocode"><a name="1839">1839: </a></span>		// we need an ArrayList that is going to store each of
<span class="nocode"><a name="1840">1840: </a></span>		// the individual reductions; NOTE that this cannot be
<span class="nocode"><a name="1841">1841: </a></span>		// a Set because then they will appear to be the same
<span class="nocode"><a name="1842">1842: </a></span>		// since the set does not preserve order!
<span class="nocode"><a name="1843">1843: </a></span>		ArrayList internalSet = new ArrayList();
<span class="nocode"><a name="1844">1844: </a></span>		
<span class="nocode"><a name="1845">1845: </a></span>		// for debugging purposes (corresponds to println)
<span class="nocode"><a name="1846">1846: </a></span>		int i = 1;
<span class="nocode"><a name="1847">1847: </a></span>
<span class="nocode"><a name="1848">1848: </a></span>		// go through each one of the separate ArrayLists and 
<span class="nocode"><a name="1849">1849: </a></span>		// retrieve the SingleTests that are inside of the 
<span class="nocode"><a name="1850">1850: </a></span>		// HashMap in order to make the final &quot;Set of Sets&quot;
<span class="nocode"><a name="1851">1851: </a></span>		Iterator testListIterator = testList.iterator();
<span class="nocode"><a name="1852">1852: </a></span>		while( testListIterator.hasNext() )
<span class="nocode"><a name="1853">1853: </a></span>		    {
<span class="nocode"><a name="1854">1854: </a></span>
<span class="nocode"><a name="1855">1855: </a></span>			// extract an ArrayList and an Iterator the
<span class="nocode"><a name="1856">1856: </a></span>			// current internal listing
<span class="nocode"><a name="1857">1857: </a></span>			ArrayList internalTestList = 
<span class="nocode"><a name="1858">1858: </a></span>			    (ArrayList) testListIterator.next();
<span class="nocode"><a name="1859">1859: </a></span>			Iterator internalTestListIterator = 
<span class="nocode"><a name="1860">1860: </a></span>			    internalTestList.iterator();
<span class="nocode"><a name="1861">1861: </a></span>			while( internalTestListIterator.hasNext() )
<span class="nocode"><a name="1862">1862: </a></span>			    {
<span class="nocode"><a name="1863">1863: </a></span>
<span class="nocode"><a name="1864">1864: </a></span>				// extract the current name of the
<span class="nocode"><a name="1865">1865: </a></span>				// test and then check into the
<span class="nocode"><a name="1866">1866: </a></span>				// HashMap
<span class="nocode"><a name="1867">1867: </a></span>				String currentTestName = 
<span class="nocode"><a name="1868">1868: </a></span>				    (String) internalTestListIterator.next();
<span class="nocode"><a name="1869">1869: </a></span>
<span class="nocode"><a name="1870">1870: </a></span>				//System.out.println(currentTestName);
<span class="nocode"><a name="1871">1871: </a></span>
<span class="nocode"><a name="1872">1872: </a></span>				// put in the real SingleTest
<span class="nocode"><a name="1873">1873: </a></span>				internalSet.add(fullTestSuite.
<span class="nocode"><a name="1874">1874: </a></span>						get(currentTestName));
<span class="nocode"><a name="1875">1875: </a></span>
<span class="nocode"><a name="1876">1876: </a></span>			    }			
<span class="nocode"><a name="1877">1877: </a></span>
<span class="nocode"><a name="1878">1878: </a></span>			//System.out.println(i + &quot; finished: &quot; + 
<span class="nocode"><a name="1879">1879: </a></span>			//		   internalSet);
<span class="nocode"><a name="1880">1880: </a></span>			i++;
<span class="nocode"><a name="1881">1881: </a></span>
<span class="nocode"><a name="1882">1882: </a></span>			// add in the current internalSet and then
<span class="nocode"><a name="1883">1883: </a></span>			// clone it and clear it so that it can 
<span class="nocode"><a name="1884">1884: </a></span>			// be used again while avoiding the Java
<span class="nocode"><a name="1885">1885: </a></span>			// reference problem
<span class="nocode"><a name="1886">1886: </a></span>			setOfPrioritizedSets.add(internalSet);
<span class="nocode"><a name="1887">1887: </a></span>			internalSet = (ArrayList)internalSet.clone();
<span class="nocode"><a name="1888">1888: </a></span>			internalSet.clear();
<span class="nocode"><a name="1889">1889: </a></span>
<span class="nocode"><a name="1890">1890: </a></span>		    }
<span class="nocode"><a name="1891">1891: </a></span>
<span class="nocode"><a name="1892">1892: </a></span>	    }
<span class="nocode"><a name="1893">1893: </a></span>
<span class="nocode"><a name="1894">1894: </a></span>	catch(Exception e)
<span class="nocode"><a name="1895">1895: </a></span>	    {
<span class="nocode"><a name="1896">1896: </a></span>
<span class="nocode"><a name="1897">1897: </a></span>		System.out.println(&quot;Problem reducing in a random fashion.&quot;);
<span class="nocode"><a name="1898">1898: </a></span>		e.printStackTrace();
<span class="nocode"><a name="1899">1899: </a></span>
<span class="nocode"><a name="1900">1900: </a></span>	    }
<span class="nocode"><a name="1901">1901: </a></span>
<span class="nocode"><a name="1902">1902: </a></span>	
<span class="nocode"><a name="1903">1903: </a></span>	finally 
<span class="nocode"><a name="1904">1904: </a></span>	    {
<span class="nocode"><a name="1905">1905: </a></span>		
<span class="nocode"><a name="1906">1906: </a></span>		ml.close();
<span class="nocode"><a name="1907">1907: </a></span>		
<span class="nocode"><a name="1908">1908: </a></span>	    }
<span class="nocode"><a name="1909">1909: </a></span>
<span class="nocode"><a name="1910">1910: </a></span>	return setOfPrioritizedSets;
<span class="nocode"><a name="1911">1911: </a></span>
<span class="nocode"><a name="1912">1912: </a></span>    }
<span class="nocode"><a name="1913">1913: </a></span>*/
<span class="nocode"><a name="1914">1914: </a></span>    /**
<span class="nocode"><a name="1915">1915: </a></span>     *  Reduce the test suite in a Kanonizo-like fashion that simply
<span class="nocode"><a name="1916">1916: </a></span>     *  requires that we sort the test suite **according to COST** and
<span class="nocode"><a name="1917">1917: </a></span>     *  then select those first ones that are withing our targetSize.
<span class="nocode"><a name="1918">1918: </a></span>     *  
<span class="nocode"><a name="1919">1919: </a></span>     *  @author Gregory M. Kapfhammer 12/1/2005
<span class="nocode"><a name="1920">1920: </a></span>     */
<span class="nocode"><a name="1921">1921: </a></span>    public Set reduceUsingKanonizo(int targetSize, Comparator compare)
<span class="nocode"><a name="1922">1922: </a></span>    {
<span class="nocode"><a name="1923">1923: </a></span>
<span class="nocode"><a name="1924">1924: </a></span>	// take the timing before
<span class="nocode"><a name="1925">1925: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1926">1926: </a></span>
<span class="nocode"><a name="1927">1927: </a></span>	LinkedHashSet costPickSets = new LinkedHashSet();
<span class="nocode"><a name="1928">1928: </a></span>
<span class="nocode"><a name="1929">1929: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1930">1930: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1931">1931: </a></span>
<span class="nocode"><a name="1932">1932: </a></span>	// create a new Comparator that can handle cost information
<span class="nocode"><a name="1933">1933: </a></span>	//	SingleTestSubsetCostComparator compare = 
<span class="nocode"><a name="1934">1934: </a></span>	//    new SingleTestSubsetCostComparator();
<span class="nocode"><a name="1935">1935: </a></span>
<span class="nocode"><a name="1936">1936: </a></span>	// sort this ArrayList according to COST 
<span class="nocode"><a name="1937">1937: </a></span>	Collections.sort(testSubsetsList, compare);
<span class="nocode"><a name="1938">1938: </a></span>       
<span class="nocode"><a name="1939">1939: </a></span>	// keep track of the total number of picks
<span class="nocode"><a name="1940">1940: </a></span>	int numberPicks = 0;
<span class="nocode"><a name="1941">1941: </a></span>
<span class="nocode"><a name="1942">1942: </a></span>	// pick the ones at the begining up to the targetSize
<span class="nocode"><a name="1943">1943: </a></span> 	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="1944">1944: </a></span>	while( testSubsetsIterator.hasNext() &amp;&amp; 
<span class="nocode"><a name="1945">1945: </a></span>	       numberPicks &lt; targetSize )
<span class="nocode"><a name="1946">1946: </a></span>	    {
<span class="nocode"><a name="1947">1947: </a></span>
<span class="nocode"><a name="1948">1948: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="1949">1949: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="1950">1950: </a></span>
<span class="nocode"><a name="1951">1951: </a></span>		costPickSets.
<span class="nocode"><a name="1952">1952: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="1953">1953: </a></span>
<span class="nocode"><a name="1954">1954: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="1955">1955: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="1956">1956: </a></span>		    add( stsJerk );
<span class="nocode"><a name="1957">1957: </a></span>
<span class="nocode"><a name="1958">1958: </a></span>		numberPicks++;
<span class="nocode"><a name="1959">1959: </a></span>
<span class="nocode"><a name="1960">1960: </a></span>	    }	
<span class="nocode"><a name="1961">1961: </a></span>
<span class="nocode"><a name="1962">1962: </a></span>	// take the timing after
<span class="nocode"><a name="1963">1963: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="1964">1964: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="1965">1965: </a></span>
<span class="nocode"><a name="1966">1966: </a></span>	return costPickSets;
<span class="nocode"><a name="1967">1967: </a></span>
<span class="nocode"><a name="1968">1968: </a></span>    }
<span class="nocode"><a name="1969">1969: </a></span>
<span class="nocode"><a name="1970">1970: </a></span>    /**
<span class="nocode"><a name="1971">1971: </a></span>     *  Prioritize the test suite in a Kanonizo-like fashion that
<span class="nocode"><a name="1972">1972: </a></span>     *  simply requires that we sort the test suite **according to
<span class="nocode"><a name="1973">1973: </a></span>     *  COST** or any of the other comparators.
<span class="nocode"><a name="1974">1974: </a></span>     *  
<span class="nocode"><a name="1975">1975: </a></span>     *  @author Gregory M. Kapfhammer 12/1/2005
<span class="nocode"><a name="1976">1976: </a></span>     */
<span class="nocode"><a name="1977">1977: </a></span>    public Set prioritizeUsingKanonizo(Comparator compare)
<span class="nocode"><a name="1978">1978: </a></span>    {
<span class="nocode"><a name="1979">1979: </a></span>
<span class="nocode"><a name="1980">1980: </a></span>	// take the timing before
<span class="nocode"><a name="1981">1981: </a></span>	long prioritizeTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="1982">1982: </a></span>
<span class="nocode"><a name="1983">1983: </a></span>	LinkedHashSet costPickSets = new LinkedHashSet();
<span class="nocode"><a name="1984">1984: </a></span>
<span class="nocode"><a name="1985">1985: </a></span>	// produce an ArrayList from the set of the testSubsets
<span class="nocode"><a name="1986">1986: </a></span>	ArrayList testSubsetsList = new ArrayList(testSubsets);
<span class="nocode"><a name="1987">1987: </a></span>
<span class="nocode"><a name="1988">1988: </a></span>// 	System.out.println(&quot;TSL Before: &quot; + 
<span class="nocode"><a name="1989">1989: </a></span>// 			   testSubsetsList);
<span class="nocode"><a name="1990">1990: </a></span>
<span class="nocode"><a name="1991">1991: </a></span>	// sort this ArrayList according to COST 
<span class="nocode"><a name="1992">1992: </a></span>	Collections.sort(testSubsetsList, compare);
<span class="nocode"><a name="1993">1993: </a></span>
<span class="nocode"><a name="1994">1994: </a></span>// 	System.out.println(&quot;TSL After: &quot; + 
<span class="nocode"><a name="1995">1995: </a></span>// 			   testSubsetsList);
<span class="nocode"><a name="1996">1996: </a></span>	
<span class="nocode"><a name="1997">1997: </a></span>// 	System.out.println(&quot;TSL size inside PWK : &quot; + 
<span class="nocode"><a name="1998">1998: </a></span>// 			   testSubsetsList.size());
<span class="nocode"><a name="1999">1999: </a></span>
<span class="nocode"><a name="2000">2000: </a></span>	// argh, this is horrible, but we have to go through the 
<span class="nocode"><a name="2001">2001: </a></span>	// testSubsetsList and extract the SingleTests that are 
<span class="nocode"><a name="2002">2002: </a></span>	// currently inside of the SingleTestSubsets (we can 
<span class="nocode"><a name="2003">2003: </a></span>	// probably not include this in the timing because it is
<span class="nocode"><a name="2004">2004: </a></span>	// just an accident of how we have implemented the system)
<span class="nocode"><a name="2005">2005: </a></span>	Iterator testSubsetsIterator = testSubsetsList.iterator();
<span class="nocode"><a name="2006">2006: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="2007">2007: </a></span>	    {
<span class="nocode"><a name="2008">2008: </a></span>
<span class="nocode"><a name="2009">2009: </a></span>		SingleTestSubset stsJerk = 
<span class="nocode"><a name="2010">2010: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="2011">2011: </a></span>
<span class="nocode"><a name="2012">2012: </a></span>		costPickSets.
<span class="nocode"><a name="2013">2013: </a></span>		    add( stsJerk.getTest() );
<span class="nocode"><a name="2014">2014: </a></span>
<span class="nocode"><a name="2015">2015: </a></span>		// added by gmk on march 6
<span class="nocode"><a name="2016">2016: </a></span>		reducedSingleTestSubsets.
<span class="nocode"><a name="2017">2017: </a></span>		    add( stsJerk );
<span class="nocode"><a name="2018">2018: </a></span>
<span class="nocode"><a name="2019">2019: </a></span>	    }
<span class="nocode"><a name="2020">2020: </a></span>
<span class="nocode"><a name="2021">2021: </a></span>	// take the timing after
<span class="nocode"><a name="2022">2022: </a></span>	long prioritizeTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="2023">2023: </a></span>	prioritizationTime = (prioritizeTimeAfter - prioritizeTimeBefore);
<span class="nocode"><a name="2024">2024: </a></span>
<span class="nocode"><a name="2025">2025: </a></span>	// debugging output for now
<span class="nocode"><a name="2026">2026: </a></span>// 	System.out.println(&quot;RSTS size inside PWK : &quot; + 
<span class="nocode"><a name="2027">2027: </a></span>// 			   reducedSingleTestSubsets.size());
<span class="nocode"><a name="2028">2028: </a></span>
<span class="nocode"><a name="2029">2029: </a></span>	return costPickSets;
<span class="nocode"><a name="2030">2030: </a></span>
<span class="nocode"><a name="2031">2031: </a></span>    }
<span class="nocode"><a name="2032">2032: </a></span>
<span class="nocode"><a name="2033">2033: </a></span>    /**
<span class="nocode"><a name="2034">2034: </a></span>     *  Uses repeated calls to the reduceUsingGreedy method in order
<span class="nocode"><a name="2035">2035: </a></span>     *  to perform a prioritization of the test suite.  Information
<span class="nocode"><a name="2036">2036: </a></span>     *  about the reduction algorithm that is being called:
<span class="nocode"><a name="2037">2037: </a></span>     *
<span class="nocode"><a name="2038">2038: </a></span>     *  Approximates the solution to the SetCover instance using the 
<span class="nocode"><a name="2039">2039: </a></span>     *  Greedy Set Cover Algorithm on pg 16 of Vazirani's _Approximation
<span class="nocode"><a name="2040">2040: </a></span>     *  Algorithms_.  This is a O(m*n) algorithm and it can be extended
<span class="nocode"><a name="2041">2041: </a></span>     *  to perform regression test suite prioritization as well.
<span class="nocode"><a name="2042">2042: </a></span>     *  
<span class="nocode"><a name="2043">2043: </a></span>     *  @author Gregory M. Kapfhammer 12/5/2005
<span class="nocode"><a name="2044">2044: </a></span>     */
<span class="nocode"><a name="2045">2045: </a></span>    public Set prioritizeUsingGreedy()
<span class="nocode"><a name="2046">2046: </a></span>    {
<span class="nocode"><a name="2047">2047: </a></span>
<span class="nocode"><a name="2048">2048: </a></span>	// calculate the time before we begin executing the algorithm
<span class="nocode"><a name="2049">2049: </a></span>	long prioritizeTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="2050">2050: </a></span>
<span class="nocode"><a name="2051">2051: </a></span>	// this is the final set that will store all of the
<span class="nocode"><a name="2052">2052: </a></span>	// prioritized test suite; note that this must be equal to the
<span class="nocode"><a name="2053">2053: </a></span>	// same size as the initial test suite that is represented as
<span class="nocode"><a name="2054">2054: </a></span>	// a set cover instance
<span class="nocode"><a name="2055">2055: </a></span>	LinkedHashSet prioritizedSet = new LinkedHashSet();
<span class="nocode"><a name="2056">2056: </a></span>
<span class="nocode"><a name="2057">2057: </a></span>	// debugging output
<span class="nocode"><a name="2058">2058: </a></span>// 	System.out.println(&quot;testSubsets size (before) = &quot; + 
<span class="nocode"><a name="2059">2059: </a></span>// 			   testSubsets.size());
<span class="nocode"><a name="2060">2060: </a></span>
<span class="nocode"><a name="2061">2061: </a></span>	// this is the initial size of the testSubset; I was
<span class="nocode"><a name="2062">2062: </a></span>	// collecting this information for debugging purposes;
<span class="nocode"><a name="2063">2063: </a></span>	// does not really need to be used in this implementation
<span class="nocode"><a name="2064">2064: </a></span>	int aimingForSize = testSubsets.size();
<span class="nocode"><a name="2065">2065: </a></span>	
<span class="nocode"><a name="2066">2066: </a></span>	// keep performing the reduction until we have included
<span class="nocode"><a name="2067">2067: </a></span>	// all of the test cases inside of the prioritizedSet
<span class="nocode"><a name="2068">2068: </a></span>	while( testSubsets.size() != 0 )
<span class="nocode"><a name="2069">2069: </a></span>	//	while( prioritizedSet.size() &lt; aimingForSize )
<span class="nocode"><a name="2070">2070: </a></span>	    {
<span class="nocode"><a name="2071">2071: </a></span>
<span class="nocode"><a name="2072">2072: </a></span>		// debugging information for now 
<span class="nocode"><a name="2073">2073: </a></span>
<span class="nocode"><a name="2074">2074: </a></span>// 		System.out.println(&quot;BEG testSubsets size (inside) = &quot; + 
<span class="nocode"><a name="2075">2075: </a></span>// 				   testSubsets.size());
<span class="nocode"><a name="2076">2076: </a></span>// 		System.out.println(&quot;BEG prioritizedSet size (inside) = &quot; + 
<span class="nocode"><a name="2077">2077: </a></span>// 				   prioritizedSet.size());
<span class="nocode"><a name="2078">2078: </a></span>
<span class="nocode"><a name="2079">2079: </a></span>// 		System.out.println(&quot;prioritizeSet: &quot; + prioritizedSet);
<span class="nocode"><a name="2080">2080: </a></span>// 		System.out.println(&quot;testSubsets: &quot; + testSubsets);
<span class="nocode"><a name="2081">2081: </a></span>
<span class="nocode"><a name="2082">2082: </a></span>// 		System.out.println(&quot;SC = &quot; + this);
<span class="nocode"><a name="2083">2083: </a></span>
<span class="nocode"><a name="2084">2084: </a></span>		// perform the reduction on whatever is 
<span class="nocode"><a name="2085">2085: </a></span>		// currently inside of the SetCover instance
<span class="nocode"><a name="2086">2086: </a></span>		Set internalPrioritizedSet = 
<span class="nocode"><a name="2087">2087: </a></span>		    this.reduceUsingGreedy();
<span class="nocode"><a name="2088">2088: </a></span>
<span class="nocode"><a name="2089">2089: </a></span>// 		System.out.println(&quot;internalPrioritizeSet size: &quot; + 
<span class="nocode"><a name="2090">2090: </a></span>// 				   internalPrioritizedSet.size());
<span class="nocode"><a name="2091">2091: </a></span>
<span class="nocode"><a name="2092">2092: </a></span>		// this is the listing of the RequirementSubsets
<span class="nocode"><a name="2093">2093: </a></span>		// that are still considered to be &quot;live&quot; because
<span class="nocode"><a name="2094">2094: </a></span>		// they are covered by tests that have not yet 
<span class="nocode"><a name="2095">2095: </a></span>		// been included inside of the prioritized test suite
<span class="nocode"><a name="2096">2096: </a></span>		LinkedHashSet liveRequirementSubsets = 
<span class="nocode"><a name="2097">2097: </a></span>		    new LinkedHashSet();
<span class="nocode"><a name="2098">2098: </a></span>
<span class="nocode"><a name="2099">2099: </a></span>		// gather up a listing of all of the Requirement
<span class="nocode"><a name="2100">2100: </a></span>		// Subsets that are currently still being covered
<span class="nocode"><a name="2101">2101: </a></span>		// by the test cases that are still inside of 
<span class="nocode"><a name="2102">2102: </a></span>		// the instance of the SetCover
<span class="nocode"><a name="2103">2103: </a></span>		Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="2104">2104: </a></span>		while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="2105">2105: </a></span>		    {
<span class="nocode"><a name="2106">2106: </a></span>
<span class="nocode"><a name="2107">2107: </a></span>			// extract the current SingleTestSubset
<span class="nocode"><a name="2108">2108: </a></span>			SingleTestSubset currentSingleTestSubset = 
<span class="nocode"><a name="2109">2109: </a></span>			    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="2110">2110: </a></span>
<span class="nocode"><a name="2111">2111: </a></span>// 			System.out.println(&quot;current STS: &quot; + 
<span class="nocode"><a name="2112">2112: </a></span>// 					   currentSingleTestSubset);
<span class="nocode"><a name="2113">2113: </a></span>
<span class="nocode"><a name="2114">2114: </a></span>			// extract the requirementSubsetSet
<span class="nocode"><a name="2115">2115: </a></span>			LinkedHashSet currentReqSubsetSet = 
<span class="nocode"><a name="2116">2116: </a></span>			    currentSingleTestSubset.getRequirementSubsetSet();
<span class="nocode"><a name="2117">2117: </a></span>			
<span class="nocode"><a name="2118">2118: </a></span>			// this is an example of a live requirement
<span class="nocode"><a name="2119">2119: </a></span>			// and we have to store it inside the set
<span class="nocode"><a name="2120">2120: </a></span>			liveRequirementSubsets.addAll(currentReqSubsetSet);
<span class="nocode"><a name="2121">2121: </a></span>
<span class="nocode"><a name="2122">2122: </a></span>		    }
<span class="nocode"><a name="2123">2123: </a></span>
<span class="nocode"><a name="2124">2124: </a></span>// 		System.out.println(&quot;live requirements: &quot; + 
<span class="nocode"><a name="2125">2125: </a></span>// 				   liveRequirementSubsets);
<span class="nocode"><a name="2126">2126: </a></span>
<span class="nocode"><a name="2127">2127: </a></span>// 		System.out.println(&quot;RSU Before: &quot; + 
<span class="nocode"><a name="2128">2128: </a></span>// 				   requirementSubsetUniverse);
<span class="nocode"><a name="2129">2129: </a></span>
<span class="nocode"><a name="2130">2130: </a></span>		// we now have a complete listing of all of the
<span class="nocode"><a name="2131">2131: </a></span>		// requirement subsets that are live and we have to
<span class="nocode"><a name="2132">2132: </a></span>		// remove all those dead requirements using the set
<span class="nocode"><a name="2133">2133: </a></span>		// intersection operator
<span class="nocode"><a name="2134">2134: </a></span>		requirementSubsetUniverse.retainAll(liveRequirementSubsets);
<span class="nocode"><a name="2135">2135: </a></span>
<span class="nocode"><a name="2136">2136: </a></span>// 		System.out.println(&quot;RSU After: &quot; + 
<span class="nocode"><a name="2137">2137: </a></span>// 				   requirementSubsetUniverse);
<span class="nocode"><a name="2138">2138: </a></span>
<span class="nocode"><a name="2139">2139: </a></span>		// these are test cases that we want to keep 
<span class="nocode"><a name="2140">2140: </a></span>		// and we want them in exactly the order that 
<span class="nocode"><a name="2141">2141: </a></span>		// they appear inside of the current output
<span class="nocode"><a name="2142">2142: </a></span>		// from the reduction algorithm
<span class="nocode"><a name="2143">2143: </a></span>		prioritizedSet.addAll(internalPrioritizedSet);
<span class="nocode"><a name="2144">2144: </a></span>
<span class="nocode"><a name="2145">2145: </a></span>		// keep track of the number of times that we executed
<span class="nocode"><a name="2146">2146: </a></span>		// the outer while loop; this corresponds to the
<span class="nocode"><a name="2147">2147: </a></span>		// number of times that we actually perform the
<span class="nocode"><a name="2148">2148: </a></span>		// reduction procedure
<span class="nocode"><a name="2149">2149: </a></span>		outerWhileExecutePrioritization++;
<span class="nocode"><a name="2150">2150: </a></span>
<span class="nocode"><a name="2151">2151: </a></span>// 		System.out.println(&quot;END testSubsets size (inside) = &quot; + 
<span class="nocode"><a name="2152">2152: </a></span>// 				   testSubsets.size());
<span class="nocode"><a name="2153">2153: </a></span>// 		System.out.println(&quot;END prioritizedSet size (inside) = &quot; + 
<span class="nocode"><a name="2154">2154: </a></span>// 				   prioritizedSet.size());
<span class="nocode"><a name="2155">2155: </a></span>		
<span class="nocode"><a name="2156">2156: </a></span>		// keep track of the number of times that we had to 
<span class="nocode"><a name="2157">2157: </a></span>		// execute the outer while loop of the reduction 
<span class="nocode"><a name="2158">2158: </a></span>		// algorithm; this is another good way to measure
<span class="nocode"><a name="2159">2159: </a></span>		// performance and it is nice for checking that 
<span class="nocode"><a name="2160">2160: </a></span>		// the prioritized test suite is correct
<span class="nocode"><a name="2161">2161: </a></span>		outerWhileExecuteList.add(outerWhileExecute);
<span class="nocode"><a name="2162">2162: </a></span>
<span class="nocode"><a name="2163">2163: </a></span> 	    }
<span class="nocode"><a name="2164">2164: </a></span>
<span class="nocode"><a name="2165">2165: </a></span>//  	System.out.println(&quot;prioritized set: &quot; + prioritizedSet);
<span class="nocode"><a name="2166">2166: </a></span>// 	System.out.println(&quot;**********size = &quot; + prioritizedSet.size());
<span class="nocode"><a name="2167">2167: </a></span>// 	System.out.println(&quot;outer while? &quot; + 
<span class="nocode"><a name="2168">2168: </a></span>// 			   outerWhileExecutePrioritization);
<span class="nocode"><a name="2169">2169: </a></span>
<span class="nocode"><a name="2170">2170: </a></span>	// calculate the time after executing the algorithm
<span class="nocode"><a name="2171">2171: </a></span>	long prioritizeTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="2172">2172: </a></span>
<span class="nocode"><a name="2173">2173: </a></span>	// set the actual time for prioritization
<span class="nocode"><a name="2174">2174: </a></span>	prioritizationTime = (prioritizeTimeAfter - 
<span class="nocode"><a name="2175">2175: </a></span>			      prioritizeTimeBefore);
<span class="nocode"><a name="2176">2176: </a></span>
<span class="nocode"><a name="2177">2177: </a></span>	// return the final prioritized set; note that this set is
<span class="nocode"><a name="2178">2178: </a></span>	// added to every time that we run the reduction algorithm
<span class="nocode"><a name="2179">2179: </a></span>	return prioritizedSet;
<span class="nocode"><a name="2180">2180: </a></span>
<span class="nocode"><a name="2181">2181: </a></span>    }
<span class="nocode"><a name="2182">2182: </a></span>
<span class="nocode"><a name="2183">2183: </a></span>
<span class="nocode"><a name="2184">2184: </a></span>	/**
<span class="nocode"><a name="2185">2185: </a></span>     *  Uses repeated calls to the reduceUsingGreedy method in order
<span class="nocode"><a name="2186">2186: </a></span>     *  to perform a prioritization of the test suite.  Information
<span class="nocode"><a name="2187">2187: </a></span>     *  about the reduction algorithm that is being called:
<span class="nocode"><a name="2188">2188: </a></span>     *
<span class="nocode"><a name="2189">2189: </a></span>     *  Approximates the solution to the SetCover instance using the 
<span class="nocode"><a name="2190">2190: </a></span>     *  Greedy Set Cover Algorithm on pg 16 of Vazirani's _Approximation
<span class="nocode"><a name="2191">2191: </a></span>     *  Algorithms_.  This is a O(m*n) algorithm and it can be extended
<span class="nocode"><a name="2192">2192: </a></span>     *  to perform regression test suite prioritization as well.
<span class="nocode"><a name="2193">2193: </a></span>     *  
<span class="nocode"><a name="2194">2194: </a></span>     *  @author Gregory M. Kapfhammer 12/5/2005
<span class="nocode"><a name="2195">2195: </a></span>     */
<span class="nocode"><a name="2196">2196: </a></span>     
<span class="nocode"><a name="2197">2197: </a></span>     
<span class="nocode"><a name="2198">2198: </a></span>    /* Commented out by AMS on 03/17/08 because it is no longer needed and
<span class="nocode"><a name="2199">2199: </a></span>     * may not be working 100% correctly.
<span class="nocode"><a name="2200">2200: </a></span>     * 
<span class="nocode"><a name="2201">2201: </a></span>     * Use the ReduceUsingGreedy.java class instead
<span class="nocode"><a name="2202">2202: </a></span>     */
<span class="nocode"><a name="2203">2203: </a></span>     
<span class="nocode"><a name="2204">2204: </a></span>     /*
<span class="nocode"><a name="2205">2205: </a></span>    public Set prioritizeUsingGreedy(String metric)
<span class="nocode"><a name="2206">2206: </a></span>    {
<span class="nocode"><a name="2207">2207: </a></span>
<span class="nocode"><a name="2208">2208: </a></span>	// calculate the time before we begin executing the algorithm
<span class="nocode"><a name="2209">2209: </a></span>	long prioritizeTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="2210">2210: </a></span>
<span class="nocode"><a name="2211">2211: </a></span>	// this is the final set that will store all of the
<span class="nocode"><a name="2212">2212: </a></span>	// prioritized test suite; note that this must be equal to the
<span class="nocode"><a name="2213">2213: </a></span>	// same size as the initial test suite that is represented as
<span class="nocode"><a name="2214">2214: </a></span>	// a set cover instance
<span class="nocode"><a name="2215">2215: </a></span>	LinkedHashSet prioritizedSet = new LinkedHashSet();
<span class="nocode"><a name="2216">2216: </a></span>
<span class="nocode"><a name="2217">2217: </a></span>	// debugging output
<span class="nocode"><a name="2218">2218: </a></span>// 	System.out.println(&quot;testSubsets size (before) = &quot; + 
<span class="nocode"><a name="2219">2219: </a></span>// 			   testSubsets.size());
<span class="nocode"><a name="2220">2220: </a></span>
<span class="nocode"><a name="2221">2221: </a></span>	// this is the initial size of the testSubset; I was
<span class="nocode"><a name="2222">2222: </a></span>	// collecting this information for debugging purposes;
<span class="nocode"><a name="2223">2223: </a></span>	// does not really need to be used in this implementation
<span class="nocode"><a name="2224">2224: </a></span>	int aimingForSize = testSubsets.size();
<span class="nocode"><a name="2225">2225: </a></span>	
<span class="nocode"><a name="2226">2226: </a></span>	// keep performing the reduction until we have included
<span class="nocode"><a name="2227">2227: </a></span>	// all of the test cases inside of the prioritizedSet
<span class="nocode"><a name="2228">2228: </a></span>	while( testSubsets.size() != 0 )
<span class="nocode"><a name="2229">2229: </a></span>	//	while( prioritizedSet.size() &lt; aimingForSize )
<span class="nocode"><a name="2230">2230: </a></span>	    {
<span class="nocode"><a name="2231">2231: </a></span>
<span class="nocode"><a name="2232">2232: </a></span>		// debugging information for now 
<span class="nocode"><a name="2233">2233: </a></span>
<span class="nocode"><a name="2234">2234: </a></span>// 		System.out.println(&quot;BEG testSubsets size (inside) = &quot; + 
<span class="nocode"><a name="2235">2235: </a></span>// 				   testSubsets.size());
<span class="nocode"><a name="2236">2236: </a></span>// 		System.out.println(&quot;BEG prioritizedSet size (inside) = &quot; + 
<span class="nocode"><a name="2237">2237: </a></span>// 				   prioritizedSet.size());
<span class="nocode"><a name="2238">2238: </a></span>
<span class="nocode"><a name="2239">2239: </a></span>// 		System.out.println(&quot;prioritizeSet: &quot; + prioritizedSet);
<span class="nocode"><a name="2240">2240: </a></span>// 		System.out.println(&quot;testSubsets: &quot; + testSubsets);
<span class="nocode"><a name="2241">2241: </a></span>
<span class="nocode"><a name="2242">2242: </a></span>// 		System.out.println(&quot;SC = &quot; + this);
<span class="nocode"><a name="2243">2243: </a></span>
<span class="nocode"><a name="2244">2244: </a></span>		// perform the reduction on whatever is 
<span class="nocode"><a name="2245">2245: </a></span>		// currently inside of the SetCover instance
<span class="nocode"><a name="2246">2246: </a></span>		Set internalPrioritizedSet = 
<span class="nocode"><a name="2247">2247: </a></span>		    this.reduceUsingGreedy(metric);
<span class="nocode"><a name="2248">2248: </a></span>
<span class="nocode"><a name="2249">2249: </a></span>// 		System.out.println(&quot;internalPrioritizeSet size: &quot; + 
<span class="nocode"><a name="2250">2250: </a></span>// 				   internalPrioritizedSet.size());
<span class="nocode"><a name="2251">2251: </a></span>
<span class="nocode"><a name="2252">2252: </a></span>		// this is the listing of the RequirementSubsets
<span class="nocode"><a name="2253">2253: </a></span>		// that are still considered to be &quot;live&quot; because
<span class="nocode"><a name="2254">2254: </a></span>		// they are covered by tests that have not yet 
<span class="nocode"><a name="2255">2255: </a></span>		// been included inside of the prioritized test suite
<span class="nocode"><a name="2256">2256: </a></span>		LinkedHashSet liveRequirementSubsets = 
<span class="nocode"><a name="2257">2257: </a></span>		    new LinkedHashSet();
<span class="nocode"><a name="2258">2258: </a></span>
<span class="nocode"><a name="2259">2259: </a></span>		// gather up a listing of all of the Requirement
<span class="nocode"><a name="2260">2260: </a></span>		// Subsets that are currently still being covered
<span class="nocode"><a name="2261">2261: </a></span>		// by the test cases that are still inside of 
<span class="nocode"><a name="2262">2262: </a></span>		// the instance of the SetCover
<span class="nocode"><a name="2263">2263: </a></span>		Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="2264">2264: </a></span>		while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="2265">2265: </a></span>		    {
<span class="nocode"><a name="2266">2266: </a></span>
<span class="nocode"><a name="2267">2267: </a></span>			// extract the current SingleTestSubset
<span class="nocode"><a name="2268">2268: </a></span>			SingleTestSubset currentSingleTestSubset = 
<span class="nocode"><a name="2269">2269: </a></span>			    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="2270">2270: </a></span>
<span class="nocode"><a name="2271">2271: </a></span>// 			System.out.println(&quot;current STS: &quot; + 
<span class="nocode"><a name="2272">2272: </a></span>// 					   currentSingleTestSubset);
<span class="nocode"><a name="2273">2273: </a></span>
<span class="nocode"><a name="2274">2274: </a></span>			// extract the requirementSubsetSet
<span class="nocode"><a name="2275">2275: </a></span>			LinkedHashSet currentReqSubsetSet = 
<span class="nocode"><a name="2276">2276: </a></span>			    currentSingleTestSubset.getRequirementSubsetSet();
<span class="nocode"><a name="2277">2277: </a></span>			
<span class="nocode"><a name="2278">2278: </a></span>			// this is an example of a live requirement
<span class="nocode"><a name="2279">2279: </a></span>			// and we have to store it inside the set
<span class="nocode"><a name="2280">2280: </a></span>			liveRequirementSubsets.addAll(currentReqSubsetSet);
<span class="nocode"><a name="2281">2281: </a></span>
<span class="nocode"><a name="2282">2282: </a></span>		    }
<span class="nocode"><a name="2283">2283: </a></span>
<span class="nocode"><a name="2284">2284: </a></span>// 		System.out.println(&quot;live requirements: &quot; + 
<span class="nocode"><a name="2285">2285: </a></span>// 				   liveRequirementSubsets);
<span class="nocode"><a name="2286">2286: </a></span>
<span class="nocode"><a name="2287">2287: </a></span>// 		System.out.println(&quot;RSU Before: &quot; + 
<span class="nocode"><a name="2288">2288: </a></span>// 				   requirementSubsetUniverse);
<span class="nocode"><a name="2289">2289: </a></span>
<span class="nocode"><a name="2290">2290: </a></span>		// we now have a complete listing of all of the
<span class="nocode"><a name="2291">2291: </a></span>		// requirement subsets that are live and we have to
<span class="nocode"><a name="2292">2292: </a></span>		// remove all those dead requirements using the set
<span class="nocode"><a name="2293">2293: </a></span>		// intersection operator
<span class="nocode"><a name="2294">2294: </a></span>		requirementSubsetUniverse.retainAll(liveRequirementSubsets);
<span class="nocode"><a name="2295">2295: </a></span>
<span class="nocode"><a name="2296">2296: </a></span>// 		System.out.println(&quot;RSU After: &quot; + 
<span class="nocode"><a name="2297">2297: </a></span>// 				   requirementSubsetUniverse);
<span class="nocode"><a name="2298">2298: </a></span>
<span class="nocode"><a name="2299">2299: </a></span>		// these are test cases that we want to keep 
<span class="nocode"><a name="2300">2300: </a></span>		// and we want them in exactly the order that 
<span class="nocode"><a name="2301">2301: </a></span>		// they appear inside of the current output
<span class="nocode"><a name="2302">2302: </a></span>		// from the reduction algorithm
<span class="nocode"><a name="2303">2303: </a></span>		prioritizedSet.addAll(internalPrioritizedSet);
<span class="nocode"><a name="2304">2304: </a></span>
<span class="nocode"><a name="2305">2305: </a></span>		// keep track of the number of times that we executed
<span class="nocode"><a name="2306">2306: </a></span>		// the outer while loop; this corresponds to the
<span class="nocode"><a name="2307">2307: </a></span>		// number of times that we actually perform the
<span class="nocode"><a name="2308">2308: </a></span>		// reduction procedure
<span class="nocode"><a name="2309">2309: </a></span>		outerWhileExecutePrioritization++;
<span class="nocode"><a name="2310">2310: </a></span>
<span class="nocode"><a name="2311">2311: </a></span>// 		System.out.println(&quot;END testSubsets size (inside) = &quot; + 
<span class="nocode"><a name="2312">2312: </a></span>// 				   testSubsets.size());
<span class="nocode"><a name="2313">2313: </a></span>// 		System.out.println(&quot;END prioritizedSet size (inside) = &quot; + 
<span class="nocode"><a name="2314">2314: </a></span>// 				   prioritizedSet.size());
<span class="nocode"><a name="2315">2315: </a></span>		
<span class="nocode"><a name="2316">2316: </a></span>		// keep track of the number of times that we had to 
<span class="nocode"><a name="2317">2317: </a></span>		// execute the outer while loop of the reduction 
<span class="nocode"><a name="2318">2318: </a></span>		// algorithm; this is another good way to measure
<span class="nocode"><a name="2319">2319: </a></span>		// performance and it is nice for checking that 
<span class="nocode"><a name="2320">2320: </a></span>		// the prioritized test suite is correct
<span class="nocode"><a name="2321">2321: </a></span>		outerWhileExecuteList.add(outerWhileExecute);
<span class="nocode"><a name="2322">2322: </a></span>
<span class="nocode"><a name="2323">2323: </a></span> 	    }
<span class="nocode"><a name="2324">2324: </a></span>
<span class="nocode"><a name="2325">2325: </a></span>//  	System.out.println(&quot;prioritized set: &quot; + prioritizedSet);
<span class="nocode"><a name="2326">2326: </a></span>// 	System.out.println(&quot;**********size = &quot; + prioritizedSet.size());
<span class="nocode"><a name="2327">2327: </a></span>// 	System.out.println(&quot;outer while? &quot; + 
<span class="nocode"><a name="2328">2328: </a></span>// 			   outerWhileExecutePrioritization);
<span class="nocode"><a name="2329">2329: </a></span>
<span class="nocode"><a name="2330">2330: </a></span>	// calculate the time after executing the algorithm
<span class="nocode"><a name="2331">2331: </a></span>	long prioritizeTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="2332">2332: </a></span>
<span class="nocode"><a name="2333">2333: </a></span>	// set the actual time for prioritization
<span class="nocode"><a name="2334">2334: </a></span>	prioritizationTime = (prioritizeTimeAfter - 
<span class="nocode"><a name="2335">2335: </a></span>			      prioritizeTimeBefore);
<span class="nocode"><a name="2336">2336: </a></span>
<span class="nocode"><a name="2337">2337: </a></span>	// return the final prioritized set; note that this set is
<span class="nocode"><a name="2338">2338: </a></span>	// added to every time that we run the reduction algorithm
<span class="nocode"><a name="2339">2339: </a></span>	return prioritizedSet;
<span class="nocode"><a name="2340">2340: </a></span>
<span class="nocode"><a name="2341">2341: </a></span>    }
<span class="nocode"><a name="2342">2342: </a></span>    */
<span class="nocode"><a name="2343">2343: </a></span>
<span class="nocode"><a name="2344">2344: </a></span>    /**
<span class="nocode"><a name="2345">2345: </a></span>     *  Approximates the solution to the SetCover instance using the 
<span class="nocode"><a name="2346">2346: </a></span>     *  Greedy Set Cover Algorithm on pg 16 of Vazirani's _Approximation
<span class="nocode"><a name="2347">2347: </a></span>     *  Algorithms_.  This is a O(m*n) algorithm and it can be extended
<span class="nocode"><a name="2348">2348: </a></span>     *  to perform regression test suite prioritization as well.
<span class="nocode"><a name="2349">2349: </a></span>     *  
<span class="nocode"><a name="2350">2350: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2005
<span class="nocode"><a name="2351">2351: </a></span>     */
<span class="nocode"><a name="2352">2352: </a></span>    public Set reduceUsingGreedy()
<span class="nocode"><a name="2353">2353: </a></span>    {
<span class="nocode"><a name="2354">2354: </a></span>
<span class="nocode"><a name="2355">2355: </a></span>	// take the timing before running the algorithm
<span class="nocode"><a name="2356">2356: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="2357">2357: </a></span>
<span class="nocode"><a name="2358">2358: </a></span>// 	System.out.println(&quot;Reducing using Greedy&quot;);
<span class="nocode"><a name="2359">2359: </a></span>
<span class="nocode"><a name="2360">2360: </a></span>	// this is the Set that contains the final covering; 
<span class="nocode"><a name="2361">2361: </a></span>	// actually this is not the case; we just use this 
<span class="nocode"><a name="2362">2362: </a></span>	// to store intermediate results -- we do return
<span class="nocode"><a name="2363">2363: </a></span>	// the variable called coverPickSet
<span class="nocode"><a name="2364">2364: </a></span>	LinkedHashSet cover = new LinkedHashSet();
<span class="nocode"><a name="2365">2365: </a></span>
<span class="nocode"><a name="2366">2366: </a></span>	// this is the Picked sets; this corresponds to the answer to
<span class="nocode"><a name="2367">2367: </a></span>	// the HittingSet problem that we have solved via the greedy
<span class="nocode"><a name="2368">2368: </a></span>	// approximation to the SetCover problem
<span class="nocode"><a name="2369">2369: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="2370">2370: </a></span>
<span class="nocode"><a name="2371">2371: </a></span>// 	System.out.println(&quot;requirementSubsetUniverse = &quot; +
<span class="nocode"><a name="2372">2372: </a></span>// 			   requirementSubsetUniverse);
<span class="nocode"><a name="2373">2373: </a></span>
<span class="nocode"><a name="2374">2374: </a></span>	// A NOTE TO UNDERSTAND THE PURPOSE OF REMOVAL: You can remove
<span class="nocode"><a name="2375">2375: </a></span>	// a test case whenever **all** of the test requirements that
<span class="nocode"><a name="2376">2376: </a></span>	// it covers are already covered by another test case.
<span class="nocode"><a name="2377">2377: </a></span>	// However, you have to be careful because we want to add
<span class="nocode"><a name="2378">2378: </a></span>	// these back in when we are done.  Adding them in does not
<span class="nocode"><a name="2379">2379: </a></span>	// impact the reduced test suite in a negative fashion.  But,
<span class="nocode"><a name="2380">2380: </a></span>	// it does enable prioritization by repeated reduction
<span class="nocode"><a name="2381">2381: </a></span>
<span class="nocode"><a name="2382">2382: </a></span>	// note that initially there is nothing to remove ; 
<span class="nocode"><a name="2383">2383: </a></span>	// we just build up this list over time and re-init 
<span class="nocode"><a name="2384">2384: </a></span>	// after we execute the removal
<span class="nocode"><a name="2385">2385: </a></span>	LinkedHashSet goingToRemove = new LinkedHashSet();
<span class="nocode"><a name="2386">2386: </a></span>
<span class="nocode"><a name="2387">2387: </a></span>	// we need to keep track of all tests that were removed
<span class="nocode"><a name="2388">2388: </a></span>	// so that we can add them back in right before we return
<span class="nocode"><a name="2389">2389: </a></span>	// from this method.  We need to do this so that we can 
<span class="nocode"><a name="2390">2390: </a></span>	// properly support prioritization via repeated reduction
<span class="nocode"><a name="2391">2391: </a></span>	LinkedHashSet goingToRemoveTrack = new LinkedHashSet();
<span class="nocode"><a name="2392">2392: </a></span>
<span class="nocode"><a name="2393">2393: </a></span>	// this variable will keep track of the number of iterations
<span class="nocode"><a name="2394">2394: </a></span>	// of the while loop ; this gives us some basic information
<span class="nocode"><a name="2395">2395: </a></span>	// about the performance of the algorithm without using
<span class="nocode"><a name="2396">2396: </a></span>	// profiling instrumentation (my observation is that this
<span class="nocode"><a name="2397">2397: </a></span>	// should always be equal to the number of tests in the
<span class="nocode"><a name="2398">2398: </a></span>	// reduced test suite)
<span class="nocode"><a name="2399">2399: </a></span>	outerWhileExecute = 0;
<span class="nocode"><a name="2400">2400: </a></span>	
<span class="nocode"><a name="2401">2401: </a></span>	// we are going to clone the current instance so that we can
<span class="nocode"><a name="2402">2402: </a></span>	// store it and use it whenever we need to calculate
<span class="nocode"><a name="2403">2403: </a></span>	// reductions and percent reductions
<span class="nocode"><a name="2404">2404: </a></span>	beforeReduction = (SetCover) this.clone();
<span class="nocode"><a name="2405">2405: </a></span>
<span class="nocode"><a name="2406">2406: </a></span>	// keep iterating until we have picked a set of test cases
<span class="nocode"><a name="2407">2407: </a></span>	// that will cover the entire universe of test requirements
<span class="nocode"><a name="2408">2408: </a></span>	// note that each test case corresponds to the coverage of 
<span class="nocode"><a name="2409">2409: </a></span>	// certain test requirements
<span class="nocode"><a name="2410">2410: </a></span>	while( ! cover.equals(requirementSubsetUniverse) )
<span class="nocode"><a name="2411">2411: </a></span>	    {
<span class="nocode"><a name="2412">2412: </a></span>
<span class="nocode"><a name="2413">2413: </a></span>// 		System.out.println(&quot;Cover = &quot; + cover);
<span class="nocode"><a name="2414">2414: </a></span>// 		System.out.println();
<span class="nocode"><a name="2415">2415: </a></span>
<span class="nocode"><a name="2416">2416: </a></span>// 		System.out.println(&quot;U = &quot; + requirementSubsetUniverse);
<span class="nocode"><a name="2417">2417: </a></span>// 		System.out.println();
<span class="nocode"><a name="2418">2418: </a></span>
<span class="nocode"><a name="2419">2419: </a></span>		// NOTE: we would like to do the following step inside
<span class="nocode"><a name="2420">2420: </a></span>		// of the while() loop but Java will throw a
<span class="nocode"><a name="2421">2421: </a></span>		// ConcurrentModificationException because the
<span class="nocode"><a name="2422">2422: </a></span>		// iterator that is returned is fail-fast
<span class="nocode"><a name="2423">2423: </a></span>
<span class="nocode"><a name="2424">2424: </a></span>		// NOTE: this might not be any faster in terms of Java
<span class="nocode"><a name="2425">2425: </a></span>		// performance because of the allocation and deallocation
<span class="nocode"><a name="2426">2426: </a></span>		// (this is probably open to experimentation) but note
<span class="nocode"><a name="2427">2427: </a></span>		// that it does result in different reduced test suites
<span class="nocode"><a name="2428">2428: </a></span>		// that still all cover the test requirements
<span class="nocode"><a name="2429">2429: </a></span>
<span class="nocode"><a name="2430">2430: </a></span>		// debugging output for now
<span class="nocode"><a name="2431">2431: </a></span>// 		System.out.println(&quot;Going to Remove Size (inside): &quot; + 
<span class="nocode"><a name="2432">2432: </a></span>// 				   goingToRemove.size());
<span class="nocode"><a name="2433">2433: </a></span>		
<span class="nocode"><a name="2434">2434: </a></span>		// remove all of the sets inside of the TestSubsets
<span class="nocode"><a name="2435">2435: </a></span>		// that no longer ever need to be considered (this
<span class="nocode"><a name="2436">2436: </a></span>		// cuts down on the number of iterations of the next
<span class="nocode"><a name="2437">2437: </a></span>		// while loop)
<span class="nocode"><a name="2438">2438: </a></span>		testSubsets.removeAll(goingToRemove);
<span class="nocode"><a name="2439">2439: </a></span>		goingToRemoveTrack.addAll(goingToRemove);
<span class="nocode"><a name="2440">2440: </a></span>		goingToRemove = new LinkedHashSet();
<span class="nocode"><a name="2441">2441: </a></span>		
<span class="nocode"><a name="2442">2442: </a></span>		// extract an iterator of the TestSubsets; this is 
<span class="nocode"><a name="2443">2443: </a></span>		// the S for the SetCover instance ; we have to keep
<span class="nocode"><a name="2444">2444: </a></span>		// going through these until we have selected enough
<span class="nocode"><a name="2445">2445: </a></span>		// of them to equal the entire universe U
<span class="nocode"><a name="2446">2446: </a></span>		Iterator testSubsetsIterator = 
<span class="nocode"><a name="2447">2447: </a></span>		    testSubsets.iterator();
<span class="nocode"><a name="2448">2448: </a></span>
<span class="nocode"><a name="2449">2449: </a></span>		// create the MinCost RequirementSubset because this
<span class="nocode"><a name="2450">2450: </a></span>		// is the one that we are going to select for this
<span class="nocode"><a name="2451">2451: </a></span>		// iteration of the algorithm
<span class="nocode"><a name="2452">2452: </a></span>		Set minCostRequirementSubsetSet = new LinkedHashSet();
<span class="nocode"><a name="2453">2453: </a></span>
<span class="nocode"><a name="2454">2454: </a></span>		// this corresponds to the SingleTestSubset that 
<span class="nocode"><a name="2455">2455: </a></span>		// is defined to have the minimum cost 
<span class="nocode"><a name="2456">2456: </a></span>		SingleTestSubset minCostSingleTestSubset = null;
<span class="nocode"><a name="2457">2457: </a></span>		double minimumTestSubsetCost = Double.MAX_VALUE;
<span class="nocode"><a name="2458">2458: </a></span>
<span class="nocode"><a name="2459">2459: </a></span>		// if there are SingleTestSubsets that have exactly
<span class="nocode"><a name="2460">2460: </a></span>		// the same cost, we go ahead and store all of them
<span class="nocode"><a name="2461">2461: </a></span>		// so that we can pick one of them afterwards
<span class="nocode"><a name="2462">2462: </a></span>		ArrayList equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2463">2463: </a></span>
<span class="nocode"><a name="2464">2464: </a></span>		// go through all of the remaining RequirementSubsets
<span class="nocode"><a name="2465">2465: </a></span>		// and measure their cost
<span class="nocode"><a name="2466">2466: </a></span>		while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="2467">2467: </a></span>		    {
<span class="nocode"><a name="2468">2468: </a></span>
<span class="nocode"><a name="2469">2469: </a></span>			// this is the listing of the selected tests
<span class="nocode"><a name="2470">2470: </a></span>			// that have the same cost (we have to 
<span class="nocode"><a name="2471">2471: </a></span>			// select from these some how)
<span class="nocode"><a name="2472">2472: </a></span>			//equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2473">2473: </a></span>
<span class="nocode"><a name="2474">2474: </a></span>			// go to the next SingleTestSubset and
<span class="nocode"><a name="2475">2475: </a></span>			// determine if it has any elements left
<span class="nocode"><a name="2476">2476: </a></span>			// within it and if so, what its cost might be
<span class="nocode"><a name="2477">2477: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="2478">2478: </a></span>			    (SingleTestSubset)testSubsetsIterator.next();
<span class="nocode"><a name="2479">2479: </a></span>
<span class="nocode"><a name="2480">2480: </a></span>// 			System.out.println(&quot;considering &quot; + 
<span class="nocode"><a name="2481">2481: </a></span>// 					   currentTestSubset);
<span class="nocode"><a name="2482">2482: </a></span>
<span class="nocode"><a name="2483">2483: </a></span>// 			System.out.println(&quot;current cover &quot; + 
<span class="nocode"><a name="2484">2484: </a></span>// 					   cover);
<span class="nocode"><a name="2485">2485: </a></span>
<span class="nocode"><a name="2486">2486: </a></span>			// we have found a SingleTestSubset that still
<span class="nocode"><a name="2487">2487: </a></span>			// has some test requirements that have not
<span class="nocode"><a name="2488">2488: </a></span>			// been covered and thus we should keep it
<span class="nocode"><a name="2489">2489: </a></span>			// running
<span class="nocode"><a name="2490">2490: </a></span>			if( currentTestSubset.containsElements(cover) )
<span class="nocode"><a name="2491">2491: </a></span>			    {
<span class="nocode"><a name="2492">2492: </a></span>
<span class="nocode"><a name="2493">2493: </a></span>
<span class="nocode"><a name="2494">2494: </a></span>				
<span class="nocode"><a name="2495">2495: </a></span>					// calculate the cost of the currentTestSubset (ratio)
<span class="nocode"><a name="2496">2496: </a></span>					double currentTestSubsetCost = 
<span class="nocode"><a name="2497">2497: </a></span>				   	 currentTestSubset.
<span class="nocode"><a name="2498">2498: </a></span>				   	 costEffectiveness(cover);
<span class="nocode"><a name="2499">2499: </a></span>
<span class="nocode"><a name="2500">2500: </a></span>// 				System.out.println(&quot;curr calculated cost: &quot; + 
<span class="nocode"><a name="2501">2501: </a></span>// 						   currentTestSubsetCost);
<span class="nocode"><a name="2502">2502: </a></span>
<span class="nocode"><a name="2503">2503: </a></span>				// we found one that is cheaper 
<span class="nocode"><a name="2504">2504: </a></span>				// according to the cost function
<span class="nocode"><a name="2505">2505: </a></span>				if( currentTestSubsetCost &lt;  
<span class="nocode"><a name="2506">2506: </a></span>				    minimumTestSubsetCost )
<span class="nocode"><a name="2507">2507: </a></span>				    {
<span class="nocode"><a name="2508">2508: </a></span>
<span class="nocode"><a name="2509">2509: </a></span>// 					System.out.println(&quot;Pick you!&quot;);
<span class="nocode"><a name="2510">2510: </a></span>
<span class="nocode"><a name="2511">2511: </a></span>					// extract the set of
<span class="nocode"><a name="2512">2512: </a></span>					// requirements that are
<span class="nocode"><a name="2513">2513: </a></span>					// covered by this test case
<span class="nocode"><a name="2514">2514: </a></span>					// that is of the new minimum
<span class="nocode"><a name="2515">2515: </a></span>					// cost
<span class="nocode"><a name="2516">2516: </a></span>					minCostRequirementSubsetSet = 
<span class="nocode"><a name="2517">2517: </a></span>					    currentTestSubset.
<span class="nocode"><a name="2518">2518: </a></span>					    getRequirementSubsetSet();
<span class="nocode"><a name="2519">2519: </a></span>
<span class="nocode"><a name="2520">2520: </a></span>					// reinitialize the list of
<span class="nocode"><a name="2521">2521: </a></span>					// test cases that are of
<span class="nocode"><a name="2522">2522: </a></span>					// equal cost since we have
<span class="nocode"><a name="2523">2523: </a></span>					// found a new minium
<span class="nocode"><a name="2524">2524: </a></span>					equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2525">2525: </a></span>
<span class="nocode"><a name="2526">2526: </a></span>					// reinitialize the test case
<span class="nocode"><a name="2527">2527: </a></span>					// that is of minimum cost;
<span class="nocode"><a name="2528">2528: </a></span>					// this is the one that we
<span class="nocode"><a name="2529">2529: </a></span>					// will currently be
<span class="nocode"><a name="2530">2530: </a></span>					// considering
<span class="nocode"><a name="2531">2531: </a></span>					minCostSingleTestSubset = 
<span class="nocode"><a name="2532">2532: </a></span>					    currentTestSubset;
<span class="nocode"><a name="2533">2533: </a></span>
<span class="nocode"><a name="2534">2534: </a></span>					// set the cost for this 
<span class="nocode"><a name="2535">2535: </a></span>					// specific test cse
<span class="nocode"><a name="2536">2536: </a></span>					minimumTestSubsetCost = 
<span class="nocode"><a name="2537">2537: </a></span>					    currentTestSubsetCost;
<span class="nocode"><a name="2538">2538: </a></span>					
<span class="nocode"><a name="2539">2539: </a></span>					// add this test case in as
<span class="nocode"><a name="2540">2540: </a></span>					// the first of those that
<span class="nocode"><a name="2541">2541: </a></span>					// might be of equal cost (of
<span class="nocode"><a name="2542">2542: </a></span>					// course, we might not find
<span class="nocode"><a name="2543">2543: </a></span>					// any others and then we have
<span class="nocode"><a name="2544">2544: </a></span>					// a singleton set)
<span class="nocode"><a name="2545">2545: </a></span>					equalCostSubsets.
<span class="nocode"><a name="2546">2546: </a></span>					    add(minCostSingleTestSubset);
<span class="nocode"><a name="2547">2547: </a></span>				
<span class="nocode"><a name="2548">2548: </a></span>				    }
<span class="nocode"><a name="2549">2549: </a></span>
<span class="nocode"><a name="2550">2550: </a></span>				// we found a TestSubset that is the 
<span class="nocode"><a name="2551">2551: </a></span>				// same cost as the previous one that 
<span class="nocode"><a name="2552">2552: </a></span>				// was considered the minimum
<span class="nocode"><a name="2553">2553: </a></span>				else if( currentTestSubsetCost == 
<span class="nocode"><a name="2554">2554: </a></span>					 minimumTestSubsetCost )
<span class="nocode"><a name="2555">2555: </a></span>				    {
<span class="nocode"><a name="2556">2556: </a></span>
<span class="nocode"><a name="2557">2557: </a></span>// 					System.out.println(&quot;== cost!&quot;);
<span class="nocode"><a name="2558">2558: </a></span>					equalCostSubsets.
<span class="nocode"><a name="2559">2559: </a></span>					    add(currentTestSubset);
<span class="nocode"><a name="2560">2560: </a></span>
<span class="nocode"><a name="2561">2561: </a></span>				    }
<span class="nocode"><a name="2562">2562: </a></span>
<span class="nocode"><a name="2563">2563: </a></span>			    }
<span class="nocode"><a name="2564">2564: </a></span>
<span class="nocode"><a name="2565">2565: </a></span>			// we have found a set that does not any longer
<span class="nocode"><a name="2566">2566: </a></span>			// contain viable test requirements
<span class="nocode"><a name="2567">2567: </a></span>			else
<span class="nocode"><a name="2568">2568: </a></span>			    {
<span class="nocode"><a name="2569">2569: </a></span>
<span class="nocode"><a name="2570">2570: </a></span>// 				System.out.println(&quot;Ready to Remove: &quot; +
<span class="nocode"><a name="2571">2571: </a></span>// 						   currentTestSubset);
<span class="nocode"><a name="2572">2572: </a></span>				
<span class="nocode"><a name="2573">2573: </a></span>				// next run through the algorithm go
<span class="nocode"><a name="2574">2574: </a></span>				// ahead and remove this test case
<span class="nocode"><a name="2575">2575: </a></span>				goingToRemove.add(currentTestSubset);
<span class="nocode"><a name="2576">2576: </a></span>				
<span class="nocode"><a name="2577">2577: </a></span>				// NOTE: would like to do this, but 
<span class="nocode"><a name="2578">2578: </a></span>				// cannot because of the CME in Java
<span class="nocode"><a name="2579">2579: </a></span>				//testSubsets.remove(currentTestSubset);
<span class="nocode"><a name="2580">2580: </a></span>				
<span class="nocode"><a name="2581">2581: </a></span>			    }
<span class="nocode"><a name="2582">2582: </a></span>			
<span class="nocode"><a name="2583">2583: </a></span>			// I think that it would be at this point that
<span class="nocode"><a name="2584">2584: </a></span>			// we would resolve any of the types of ties
<span class="nocode"><a name="2585">2585: </a></span>			// that could occur; this could occur with
<span class="nocode"><a name="2586">2586: </a></span>			// respect to granularity or randomly; this could
<span class="nocode"><a name="2587">2587: </a></span>			// be triggered by some type of flag to the 
<span class="nocode"><a name="2588">2588: </a></span>			// method itself although this would break a lot
<span class="nocode"><a name="2589">2589: </a></span>			// of the test cases. SO, JUST NOTE THAT I AM
<span class="nocode"><a name="2590">2590: </a></span>			// REALLY NOT HANDLING TIES!
<span class="nocode"><a name="2591">2591: </a></span>
<span class="nocode"><a name="2592">2592: </a></span>		    }
<span class="nocode"><a name="2593">2593: </a></span>
<span class="nocode"><a name="2594">2594: </a></span>// 		System.out.println(&quot;minCostRequirementSubsetSet = &quot; + 
<span class="nocode"><a name="2595">2595: </a></span>// 				   minCostRequirementSubsetSet);
<span class="nocode"><a name="2596">2596: </a></span>
<span class="nocode"><a name="2597">2597: </a></span>// 		System.out.println(&quot;same costs &quot; + equalCostSubsets);
<span class="nocode"><a name="2598">2598: </a></span>
<span class="nocode"><a name="2599">2599: </a></span>		// add the selected minCostRequirementSubsetSet items
<span class="nocode"><a name="2600">2600: </a></span>		// to the cover listing (ONCE AGAIN, IGNORING TIES)
<span class="nocode"><a name="2601">2601: </a></span>		cover.addAll(minCostRequirementSubsetSet);
<span class="nocode"><a name="2602">2602: </a></span>
<span class="nocode"><a name="2603">2603: </a></span>		// set the purchase price of this test case that we
<span class="nocode"><a name="2604">2604: </a></span>		// have just selected and then add it to the set of
<span class="nocode"><a name="2605">2605: </a></span>		// the picked test case (by keeping track of purchase
<span class="nocode"><a name="2606">2606: </a></span>		// price we can know the order of selection)
<span class="nocode"><a name="2607">2607: </a></span>
<span class="nocode"><a name="2608">2608: </a></span>// 		System.out.println(&quot;minCostSingleTestSubset = &quot; +
<span class="nocode"><a name="2609">2609: </a></span>// 				   minCostSingleTestSubset);
<span class="nocode"><a name="2610">2610: </a></span>
<span class="nocode"><a name="2611">2611: </a></span>// 		System.out.println(&quot;getTest = &quot; + 
<span class="nocode"><a name="2612">2612: </a></span>// 				   minCostSingleTestSubset.getTest());
<span class="nocode"><a name="2613">2613: </a></span>
<span class="nocode"><a name="2614">2614: </a></span>		// purchase the test which means applying the cost
<span class="nocode"><a name="2615">2615: </a></span>		// for the entire TestSubset to this specific test
<span class="nocode"><a name="2616">2616: </a></span>		minCostSingleTestSubset.getTest().
<span class="nocode"><a name="2617">2617: </a></span>		    purchase(minimumTestSubsetCost);
<span class="nocode"><a name="2618">2618: </a></span>
<span class="nocode"><a name="2619">2619: </a></span>		// add this **SingleTest** into the final coverPickSets
<span class="nocode"><a name="2620">2620: </a></span>		// note that this might be better as a SingleTestSubset
<span class="nocode"><a name="2621">2621: </a></span>		// but we are keeping this approach because it breaks
<span class="nocode"><a name="2622">2622: </a></span>		// the tests and the clients
<span class="nocode"><a name="2623">2623: </a></span>		coverPickSets.add(minCostSingleTestSubset.getTest());
<span class="nocode"><a name="2624">2624: </a></span>
<span class="nocode"><a name="2625">2625: </a></span>		// add the SingleTestSubset to the listing that can
<span class="nocode"><a name="2626">2626: </a></span>		// be accessed after the reduction has been completed
<span class="nocode"><a name="2627">2627: </a></span>		reducedSingleTestSubsets.add(minCostSingleTestSubset);
<span class="nocode"><a name="2628">2628: </a></span>
<span class="nocode"><a name="2629">2629: </a></span>		// WRONG: this would take them out of U and we have to
<span class="nocode"><a name="2630">2630: </a></span>		// compare to U as the algorithm continues to execute
<span class="nocode"><a name="2631">2631: </a></span>
<span class="nocode"><a name="2632">2632: </a></span>		// remove the one with the minimum cost from 
<span class="nocode"><a name="2633">2633: </a></span>		// the testSubsets
<span class="nocode"><a name="2634">2634: </a></span>// 		boolean foundRsu = requirementSubsetUniverse.
<span class="nocode"><a name="2635">2635: </a></span>// 		   removeAll(minCostRequirementSubsetSet);
<span class="nocode"><a name="2636">2636: </a></span>		
<span class="nocode"><a name="2637">2637: </a></span>// 		System.out.println(&quot;found rSU ? = &quot; + foundRsu);
<span class="nocode"><a name="2638">2638: </a></span>// 		System.out.println();
<span class="nocode"><a name="2639">2639: </a></span>
<span class="nocode"><a name="2640">2640: </a></span>		// we were able to remove this test case from the 
<span class="nocode"><a name="2641">2641: </a></span>		// overall set of test cases (this flag is really
<span class="nocode"><a name="2642">2642: </a></span>		// just used for debugging purposes)
<span class="nocode"><a name="2643">2643: </a></span>		boolean found = testSubsets.remove(minCostSingleTestSubset);
<span class="nocode"><a name="2644">2644: </a></span>
<span class="nocode"><a name="2645">2645: </a></span>// 		System.out.println(&quot;found tS ? = &quot; + found);
<span class="nocode"><a name="2646">2646: </a></span>// 		System.out.println();
<span class="nocode"><a name="2647">2647: </a></span>
<span class="nocode"><a name="2648">2648: </a></span>		// increment counter; really just used for the
<span class="nocode"><a name="2649">2649: </a></span>		// purposes of performance evaluation (always equal to
<span class="nocode"><a name="2650">2650: </a></span>		// the number of final tests in the test suite)
<span class="nocode"><a name="2651">2651: </a></span>		outerWhileExecute++;
<span class="nocode"><a name="2652">2652: </a></span>
<span class="nocode"><a name="2653">2653: </a></span>	    }
<span class="nocode"><a name="2654">2654: </a></span>
<span class="nocode"><a name="2655">2655: </a></span>	// debugging output for now
<span class="nocode"><a name="2656">2656: </a></span>// 	System.out.println(&quot;size of goingtoRemoveTrack = &quot; + 
<span class="nocode"><a name="2657">2657: </a></span>// 			   goingToRemoveTrack.size());
<span class="nocode"><a name="2658">2658: </a></span>
<span class="nocode"><a name="2659">2659: </a></span>	// add back all of the test cases that were removed because
<span class="nocode"><a name="2660">2660: </a></span>	// their set of test requirements were completely exhausted;
<span class="nocode"><a name="2661">2661: </a></span>	// this will support prioritization by repeated reduction
<span class="nocode"><a name="2662">2662: </a></span>	testSubsets.addAll(goingToRemoveTrack);
<span class="nocode"><a name="2663">2663: </a></span>
<span class="nocode"><a name="2664">2664: </a></span>	// take the timing after running the algorithm
<span class="nocode"><a name="2665">2665: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="2666">2666: </a></span>
<span class="nocode"><a name="2667">2667: </a></span>	// calculate the execution time and store the result
<span class="nocode"><a name="2668">2668: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="2669">2669: </a></span>
<span class="nocode"><a name="2670">2670: </a></span>	// return the result to the calling method; this actually 
<span class="nocode"><a name="2671">2671: </a></span>	// represents the test cases that we chose to KEEP and 
<span class="nocode"><a name="2672">2672: </a></span>	// thus this is the reduced test suite that we want!
<span class="nocode"><a name="2673">2673: </a></span>	return coverPickSets;
<span class="nocode"><a name="2674">2674: </a></span>
<span class="nocode"><a name="2675">2675: </a></span>    }
<span class="nocode"><a name="2676">2676: </a></span>   
<span class="nocode"><a name="2677">2677: </a></span>
<span class="nocode"><a name="2678">2678: </a></span>
<span class="nocode"><a name="2679">2679: </a></span> 	/**								CLONE
<span class="nocode"><a name="2680">2680: </a></span>     *  Approximates the solution to the SetCover instance using the 
<span class="nocode"><a name="2681">2681: </a></span>     *  Greedy Set Cover Algorithm on pg 16 of Vazirani's _Approximation
<span class="nocode"><a name="2682">2682: </a></span>     *  Algorithms_.  This is a O(m*n) algorithm and it can be extended
<span class="nocode"><a name="2683">2683: </a></span>     *  to perform regression test suite prioritization as well.
<span class="nocode"><a name="2684">2684: </a></span>     *  
<span class="nocode"><a name="2685">2685: </a></span>     *  This method is a clone of the reduceUsingGreedy() one above.  
<span class="nocode"><a name="2686">2686: </a></span>     *  This method allows for the greedy metric to be selected, and
<span class="nocode"><a name="2687">2687: </a></span>     *  the test cases that use the above version will still pass.
<span class="nocode"><a name="2688">2688: </a></span>     *
<span class="nocode"><a name="2689">2689: </a></span>     *  @author Gregory M. Kapfhammer 9/17/2007
<span class="nocode"><a name="2690">2690: </a></span>     *  @author Adam M. Smith	3/11/2008
<span class="nocode"><a name="2691">2691: </a></span>     *
<span class="nocode"><a name="2692">2692: </a></span>     */
<span class="nocode"><a name="2693">2693: </a></span>    
<span class="nocode"><a name="2694">2694: </a></span>    
<span class="nocode"><a name="2695">2695: </a></span>    /* Commented out by AMS on 03/17/08 because it is no longer needed and
<span class="nocode"><a name="2696">2696: </a></span>     * may not be working 100% correctly.
<span class="nocode"><a name="2697">2697: </a></span>     * 
<span class="nocode"><a name="2698">2698: </a></span>     * Use the ReduceUsingGreedy.java class instead
<span class="nocode"><a name="2699">2699: </a></span>     */
<span class="nocode"><a name="2700">2700: </a></span>     
<span class="nocode"><a name="2701">2701: </a></span>     /*
<span class="nocode"><a name="2702">2702: </a></span>    public Set reduceUsingGreedy(String metric)
<span class="nocode"><a name="2703">2703: </a></span>    {
<span class="nocode"><a name="2704">2704: </a></span>
<span class="nocode"><a name="2705">2705: </a></span>	// take the timing before running the algorithm
<span class="nocode"><a name="2706">2706: </a></span>	long reductionTimeBefore = System.currentTimeMillis();
<span class="nocode"><a name="2707">2707: </a></span>
<span class="nocode"><a name="2708">2708: </a></span>// 	System.out.println(&quot;Reducing using Greedy&quot;);
<span class="nocode"><a name="2709">2709: </a></span>
<span class="nocode"><a name="2710">2710: </a></span>	// this is the Set that contains the final covering; 
<span class="nocode"><a name="2711">2711: </a></span>	// actually this is not the case; we just use this 
<span class="nocode"><a name="2712">2712: </a></span>	// to store intermediate results -- we do return
<span class="nocode"><a name="2713">2713: </a></span>	// the variable called coverPickSets
<span class="nocode"><a name="2714">2714: </a></span>	LinkedHashSet cover = new LinkedHashSet();
<span class="nocode"><a name="2715">2715: </a></span>
<span class="nocode"><a name="2716">2716: </a></span>	// this is the Picked sets; this corresponds to the answer to
<span class="nocode"><a name="2717">2717: </a></span>	// the HittingSet problem that we have solved via the greedy
<span class="nocode"><a name="2718">2718: </a></span>	// approximation to the SetCover problem
<span class="nocode"><a name="2719">2719: </a></span>	LinkedHashSet coverPickSets = new LinkedHashSet();
<span class="nocode"><a name="2720">2720: </a></span>
<span class="nocode"><a name="2721">2721: </a></span>// 	System.out.println(&quot;requirementSubsetUniverse = &quot; +
<span class="nocode"><a name="2722">2722: </a></span>// 			   requirementSubsetUniverse);
<span class="nocode"><a name="2723">2723: </a></span>
<span class="nocode"><a name="2724">2724: </a></span>	// A NOTE TO UNDERSTAND THE PURPOSE OF REMOVAL: You can remove
<span class="nocode"><a name="2725">2725: </a></span>	// a test case whenever **all** of the test requirements that
<span class="nocode"><a name="2726">2726: </a></span>	// it covers are already covered by another test case.
<span class="nocode"><a name="2727">2727: </a></span>	// However, you have to be careful because we want to add
<span class="nocode"><a name="2728">2728: </a></span>	// these back in when we are done.  Adding them in does not
<span class="nocode"><a name="2729">2729: </a></span>	// impact the reduced test suite in a negative fashion.  But,
<span class="nocode"><a name="2730">2730: </a></span>	// it does enable prioritization by repeated reduction
<span class="nocode"><a name="2731">2731: </a></span>
<span class="nocode"><a name="2732">2732: </a></span>	// note that initially there is nothing to remove ; 
<span class="nocode"><a name="2733">2733: </a></span>	// we just build up this list over time and re-init 
<span class="nocode"><a name="2734">2734: </a></span>	// after we execute the removal
<span class="nocode"><a name="2735">2735: </a></span>	LinkedHashSet goingToRemove = new LinkedHashSet();
<span class="nocode"><a name="2736">2736: </a></span>
<span class="nocode"><a name="2737">2737: </a></span>	// we need to keep track of all tests that were removed
<span class="nocode"><a name="2738">2738: </a></span>	// so that we can add them back in right before we return
<span class="nocode"><a name="2739">2739: </a></span>	// from this method.  We need to do this so that we can 
<span class="nocode"><a name="2740">2740: </a></span>	// properly support prioritization via repeated reduction
<span class="nocode"><a name="2741">2741: </a></span>	LinkedHashSet goingToRemoveTrack = new LinkedHashSet();
<span class="nocode"><a name="2742">2742: </a></span>
<span class="nocode"><a name="2743">2743: </a></span>	// this variable will keep track of the number of iterations
<span class="nocode"><a name="2744">2744: </a></span>	// of the while loop ; this gives us some basic information
<span class="nocode"><a name="2745">2745: </a></span>	// about the performance of the algorithm without using
<span class="nocode"><a name="2746">2746: </a></span>	// profiling instrumentation (my observation is that this
<span class="nocode"><a name="2747">2747: </a></span>	// should always be equal to the number of tests in the
<span class="nocode"><a name="2748">2748: </a></span>	// reduced test suite)
<span class="nocode"><a name="2749">2749: </a></span>	outerWhileExecute = 0;
<span class="nocode"><a name="2750">2750: </a></span>	
<span class="nocode"><a name="2751">2751: </a></span>	// we are going to clone the current instance so that we can
<span class="nocode"><a name="2752">2752: </a></span>	// store it and use it whenever we need to calculate
<span class="nocode"><a name="2753">2753: </a></span>	// reductions and percent reductions
<span class="nocode"><a name="2754">2754: </a></span>	beforeReduction = (SetCover) this.clone();
<span class="nocode"><a name="2755">2755: </a></span>
<span class="nocode"><a name="2756">2756: </a></span>	// keep iterating until we have picked a set of test cases
<span class="nocode"><a name="2757">2757: </a></span>	// that will cover the entire universe of test requirements
<span class="nocode"><a name="2758">2758: </a></span>	// note that each test case corresponds to the coverage of 
<span class="nocode"><a name="2759">2759: </a></span>	// certain test requirements
<span class="nocode"><a name="2760">2760: </a></span>	while( ! cover.equals(requirementSubsetUniverse) )
<span class="nocode"><a name="2761">2761: </a></span>	    {
<span class="nocode"><a name="2762">2762: </a></span>
<span class="nocode"><a name="2763">2763: </a></span>// 		System.out.println(&quot;Cover = &quot; + cover);
<span class="nocode"><a name="2764">2764: </a></span>// 		System.out.println();
<span class="nocode"><a name="2765">2765: </a></span>
<span class="nocode"><a name="2766">2766: </a></span>// 		System.out.println(&quot;U = &quot; + requirementSubsetUniverse);
<span class="nocode"><a name="2767">2767: </a></span>// 		System.out.println();
<span class="nocode"><a name="2768">2768: </a></span>
<span class="nocode"><a name="2769">2769: </a></span>		// NOTE: we would like to do the following step inside
<span class="nocode"><a name="2770">2770: </a></span>		// of the while() loop but Java will throw a
<span class="nocode"><a name="2771">2771: </a></span>		// ConcurrentModificationException because the
<span class="nocode"><a name="2772">2772: </a></span>		// iterator that is returned is fail-fast
<span class="nocode"><a name="2773">2773: </a></span>
<span class="nocode"><a name="2774">2774: </a></span>		// NOTE: this might not be any faster in terms of Java
<span class="nocode"><a name="2775">2775: </a></span>		// performance because of the allocation and deallocation
<span class="nocode"><a name="2776">2776: </a></span>		// (this is probably open to experimentation) but note
<span class="nocode"><a name="2777">2777: </a></span>		// that it does result in different reduced test suites
<span class="nocode"><a name="2778">2778: </a></span>		// that still all cover the test requirements
<span class="nocode"><a name="2779">2779: </a></span>
<span class="nocode"><a name="2780">2780: </a></span>		// debugging output for now
<span class="nocode"><a name="2781">2781: </a></span>// 		System.out.println(&quot;Going to Remove Size (inside): &quot; + 
<span class="nocode"><a name="2782">2782: </a></span>// 				   goingToRemove.size());
<span class="nocode"><a name="2783">2783: </a></span>		
<span class="nocode"><a name="2784">2784: </a></span>		// remove all of the sets inside of testSubsets (data field for **SetCover**)
<span class="nocode"><a name="2785">2785: </a></span>		// that no longer ever need to be considered (this
<span class="nocode"><a name="2786">2786: </a></span>		// cuts down on the number of iterations of the next
<span class="nocode"><a name="2787">2787: </a></span>		// while loop)
<span class="nocode"><a name="2788">2788: </a></span>		testSubsets.removeAll(goingToRemove);
<span class="nocode"><a name="2789">2789: </a></span>		goingToRemoveTrack.addAll(goingToRemove);
<span class="nocode"><a name="2790">2790: </a></span>		goingToRemove = new LinkedHashSet();
<span class="nocode"><a name="2791">2791: </a></span>		
<span class="nocode"><a name="2792">2792: </a></span>		// extract an iterator of the TestSubsets; this is 
<span class="nocode"><a name="2793">2793: </a></span>		// the S for the SetCover instance ; we have to keep
<span class="nocode"><a name="2794">2794: </a></span>		// going through these until we have selected enough
<span class="nocode"><a name="2795">2795: </a></span>		// of them to equal the entire universe U
<span class="nocode"><a name="2796">2796: </a></span>		Iterator testSubsetsIterator = 
<span class="nocode"><a name="2797">2797: </a></span>		    testSubsets.iterator();
<span class="nocode"><a name="2798">2798: </a></span>
<span class="nocode"><a name="2799">2799: </a></span>		// create the MinCost RequirementSubset because this
<span class="nocode"><a name="2800">2800: </a></span>		// is the one that we are going to select for this
<span class="nocode"><a name="2801">2801: </a></span>		// iteration of the algorithm
<span class="nocode"><a name="2802">2802: </a></span>		Set minCostRequirementSubsetSet = new LinkedHashSet();
<span class="nocode"><a name="2803">2803: </a></span>
<span class="nocode"><a name="2804">2804: </a></span>		// this corresponds to the SingleTestSubset that 
<span class="nocode"><a name="2805">2805: </a></span>		// is defined to have the minimum cost 
<span class="nocode"><a name="2806">2806: </a></span>		SingleTestSubset minCostSingleTestSubset = null;
<span class="nocode"><a name="2807">2807: </a></span>		
<span class="nocode"><a name="2808">2808: </a></span>		double minimumTestSubsetCost;
<span class="nocode"><a name="2809">2809: </a></span>		
<span class="nocode"><a name="2810">2810: </a></span>		if(metric.equals(&quot;coverage&quot;))
<span class="nocode"><a name="2811">2811: </a></span>		{
<span class="nocode"><a name="2812">2812: </a></span>			minimumTestSubsetCost = Double.MIN_VALUE;
<span class="nocode"><a name="2813">2813: </a></span>		}
<span class="nocode"><a name="2814">2814: </a></span>		else
<span class="nocode"><a name="2815">2815: </a></span>		{
<span class="nocode"><a name="2816">2816: </a></span>			minimumTestSubsetCost = Double.MAX_VALUE;
<span class="nocode"><a name="2817">2817: </a></span>		}
<span class="nocode"><a name="2818">2818: </a></span>		// if there are SingleTestSubsets that have exactly
<span class="nocode"><a name="2819">2819: </a></span>		// the same cost, we go ahead and store all of them
<span class="nocode"><a name="2820">2820: </a></span>		// so that we can pick one of them afterwards
<span class="nocode"><a name="2821">2821: </a></span>		ArrayList equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2822">2822: </a></span>
<span class="nocode"><a name="2823">2823: </a></span>		// go through all of the remaining RequirementSubsets
<span class="nocode"><a name="2824">2824: </a></span>		// and measure their cost
<span class="nocode"><a name="2825">2825: </a></span>		while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="2826">2826: </a></span>		    {
<span class="nocode"><a name="2827">2827: </a></span>
<span class="nocode"><a name="2828">2828: </a></span>			// this is the listing of the selected tests
<span class="nocode"><a name="2829">2829: </a></span>			// that have the same cost (we have to 
<span class="nocode"><a name="2830">2830: </a></span>			// select from these some how)
<span class="nocode"><a name="2831">2831: </a></span>			//equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2832">2832: </a></span>
<span class="nocode"><a name="2833">2833: </a></span>			// go to the next SingleTestSubset and
<span class="nocode"><a name="2834">2834: </a></span>			// determine if it has any elements left
<span class="nocode"><a name="2835">2835: </a></span>			// within it and if so, what its cost might be
<span class="nocode"><a name="2836">2836: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="2837">2837: </a></span>			    (SingleTestSubset)testSubsetsIterator.next();
<span class="nocode"><a name="2838">2838: </a></span>
<span class="nocode"><a name="2839">2839: </a></span>// 			System.out.println(&quot;considering &quot; + 
<span class="nocode"><a name="2840">2840: </a></span>// 					   currentTestSubset);
<span class="nocode"><a name="2841">2841: </a></span>
<span class="nocode"><a name="2842">2842: </a></span>// 			System.out.println(&quot;current cover &quot; + 
<span class="nocode"><a name="2843">2843: </a></span>// 					   cover);
<span class="nocode"><a name="2844">2844: </a></span>
<span class="nocode"><a name="2845">2845: </a></span>			// we have found a SingleTestSubset that still
<span class="nocode"><a name="2846">2846: </a></span>			// has some test requirements that have not
<span class="nocode"><a name="2847">2847: </a></span>			// been covered and thus we should keep it
<span class="nocode"><a name="2848">2848: </a></span>			// running
<span class="nocode"><a name="2849">2849: </a></span>			if( currentTestSubset.containsElements(cover) )
<span class="nocode"><a name="2850">2850: </a></span>			    {
<span class="nocode"><a name="2851">2851: </a></span>
<span class="nocode"><a name="2852">2852: </a></span>				if(metric.equals(&quot;ratio&quot;))
<span class="nocode"><a name="2853">2853: </a></span>				{
<span class="nocode"><a name="2854">2854: </a></span>					//System.out.println(&quot;Using ratio&quot;);
<span class="nocode"><a name="2855">2855: </a></span>					// calculate the cost of the currentTestSubset (ratio)
<span class="nocode"><a name="2856">2856: </a></span>					double currentTestSubsetCost = 
<span class="nocode"><a name="2857">2857: </a></span>				   	 currentTestSubset.
<span class="nocode"><a name="2858">2858: </a></span>				   	 costEffectiveness(cover);
<span class="nocode"><a name="2859">2859: </a></span>
<span class="nocode"><a name="2860">2860: </a></span>// 				System.out.println(&quot;curr calculated cost: &quot; + 
<span class="nocode"><a name="2861">2861: </a></span>// 						   currentTestSubsetCost);
<span class="nocode"><a name="2862">2862: </a></span>				
<span class="nocode"><a name="2863">2863: </a></span>					// we found one that is cheaper 
<span class="nocode"><a name="2864">2864: </a></span>					// according to the cost function
<span class="nocode"><a name="2865">2865: </a></span>					if( currentTestSubsetCost &lt;  
<span class="nocode"><a name="2866">2866: </a></span>				   	 minimumTestSubsetCost )
<span class="nocode"><a name="2867">2867: </a></span>				    {
<span class="nocode"><a name="2868">2868: </a></span>
<span class="nocode"><a name="2869">2869: </a></span>	// 					System.out.println(&quot;Pick you!&quot;);
<span class="nocode"><a name="2870">2870: </a></span>
<span class="nocode"><a name="2871">2871: </a></span>						// extract the set of
<span class="nocode"><a name="2872">2872: </a></span>						// requirements that are
<span class="nocode"><a name="2873">2873: </a></span>						// covered by this test case
<span class="nocode"><a name="2874">2874: </a></span>						// that is of the new minimum
<span class="nocode"><a name="2875">2875: </a></span>						// cost
<span class="nocode"><a name="2876">2876: </a></span>						minCostRequirementSubsetSet = 
<span class="nocode"><a name="2877">2877: </a></span>						    currentTestSubset.
<span class="nocode"><a name="2878">2878: </a></span>						    getRequirementSubsetSet();
<span class="nocode"><a name="2879">2879: </a></span>
<span class="nocode"><a name="2880">2880: </a></span>						// reinitialize the list of
<span class="nocode"><a name="2881">2881: </a></span>						// test cases that are of
<span class="nocode"><a name="2882">2882: </a></span>						// equal cost since we have
<span class="nocode"><a name="2883">2883: </a></span>						// found a new minium
<span class="nocode"><a name="2884">2884: </a></span>						equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2885">2885: </a></span>
<span class="nocode"><a name="2886">2886: </a></span>						// reinitialize the test case
<span class="nocode"><a name="2887">2887: </a></span>						// that is of minimum cost;
<span class="nocode"><a name="2888">2888: </a></span>						// this is the one that we
<span class="nocode"><a name="2889">2889: </a></span>						// will currently be
<span class="nocode"><a name="2890">2890: </a></span>						// considering
<span class="nocode"><a name="2891">2891: </a></span>						minCostSingleTestSubset = 
<span class="nocode"><a name="2892">2892: </a></span>						    currentTestSubset;
<span class="nocode"><a name="2893">2893: </a></span>
<span class="nocode"><a name="2894">2894: </a></span>						// set the cost for this 
<span class="nocode"><a name="2895">2895: </a></span>						// specific test cse
<span class="nocode"><a name="2896">2896: </a></span>						minimumTestSubsetCost = 
<span class="nocode"><a name="2897">2897: </a></span>						    currentTestSubsetCost;
<span class="nocode"><a name="2898">2898: </a></span>						
<span class="nocode"><a name="2899">2899: </a></span>						// add this test case in as
<span class="nocode"><a name="2900">2900: </a></span>						// the first of those that
<span class="nocode"><a name="2901">2901: </a></span>						// might be of equal cost (of
<span class="nocode"><a name="2902">2902: </a></span>						// course, we might not find
<span class="nocode"><a name="2903">2903: </a></span>						// any others and then we have
<span class="nocode"><a name="2904">2904: </a></span>						// a singleton set)
<span class="nocode"><a name="2905">2905: </a></span>						equalCostSubsets.
<span class="nocode"><a name="2906">2906: </a></span>						    add(minCostSingleTestSubset);
<span class="nocode"><a name="2907">2907: </a></span>					
<span class="nocode"><a name="2908">2908: </a></span>					    }
<span class="nocode"><a name="2909">2909: </a></span>					
<span class="nocode"><a name="2910">2910: </a></span>					// we found a TestSubset that is the 
<span class="nocode"><a name="2911">2911: </a></span>					// same cost as the previous one that 
<span class="nocode"><a name="2912">2912: </a></span>					// was considered the minimum
<span class="nocode"><a name="2913">2913: </a></span>					else if( currentTestSubsetCost == 
<span class="nocode"><a name="2914">2914: </a></span>						 minimumTestSubsetCost )
<span class="nocode"><a name="2915">2915: </a></span>					    {
<span class="nocode"><a name="2916">2916: </a></span>
<span class="nocode"><a name="2917">2917: </a></span>	// 					System.out.println(&quot;== cost!&quot;);
<span class="nocode"><a name="2918">2918: </a></span>						equalCostSubsets.
<span class="nocode"><a name="2919">2919: </a></span>						    add(currentTestSubset);
<span class="nocode"><a name="2920">2920: </a></span>
<span class="nocode"><a name="2921">2921: </a></span>					    }
<span class="nocode"><a name="2922">2922: </a></span>					}
<span class="nocode"><a name="2923">2923: </a></span>			    
<span class="nocode"><a name="2924">2924: </a></span>			    else if(metric.equals(&quot;coverage&quot;))
<span class="nocode"><a name="2925">2925: </a></span>				{
<span class="nocode"><a name="2926">2926: </a></span>					
<span class="nocode"><a name="2927">2927: </a></span>					//System.out.println(&quot;Using coverage&quot;);
<span class="nocode"><a name="2928">2928: </a></span>					// calculate the cost of the currentTestSubset (coverage)
<span class="nocode"><a name="2929">2929: </a></span>					double currentTestSubsetCost = 
<span class="nocode"><a name="2930">2930: </a></span>				   	 currentTestSubset.
<span class="nocode"><a name="2931">2931: </a></span>				   	 coverageValue(cover);
<span class="nocode"><a name="2932">2932: </a></span>
<span class="nocode"><a name="2933">2933: </a></span>// 				System.out.println(&quot;curr calculated cost: &quot; + 
<span class="nocode"><a name="2934">2934: </a></span>// 						   currentTestSubsetCost);
<span class="nocode"><a name="2935">2935: </a></span>					
<span class="nocode"><a name="2936">2936: </a></span>					// we found one that covers more 
<span class="nocode"><a name="2937">2937: </a></span>					if( currentTestSubsetCost &gt;  
<span class="nocode"><a name="2938">2938: </a></span>				   	 minimumTestSubsetCost )
<span class="nocode"><a name="2939">2939: </a></span>				    {
<span class="nocode"><a name="2940">2940: </a></span>
<span class="nocode"><a name="2941">2941: </a></span>	// 					System.out.println(&quot;Pick you!&quot;);
<span class="nocode"><a name="2942">2942: </a></span>
<span class="nocode"><a name="2943">2943: </a></span>						// extract the set of
<span class="nocode"><a name="2944">2944: </a></span>						// requirements that are
<span class="nocode"><a name="2945">2945: </a></span>						// covered by this test case
<span class="nocode"><a name="2946">2946: </a></span>						// that is of the new minimum
<span class="nocode"><a name="2947">2947: </a></span>						// cost
<span class="nocode"><a name="2948">2948: </a></span>						minCostRequirementSubsetSet = 
<span class="nocode"><a name="2949">2949: </a></span>						    currentTestSubset.
<span class="nocode"><a name="2950">2950: </a></span>						    getRequirementSubsetSet();
<span class="nocode"><a name="2951">2951: </a></span>
<span class="nocode"><a name="2952">2952: </a></span>						// reinitialize the list of
<span class="nocode"><a name="2953">2953: </a></span>						// test cases that are of
<span class="nocode"><a name="2954">2954: </a></span>						// equal cost since we have
<span class="nocode"><a name="2955">2955: </a></span>						// found a new minium
<span class="nocode"><a name="2956">2956: </a></span>						equalCostSubsets = new ArrayList();
<span class="nocode"><a name="2957">2957: </a></span>
<span class="nocode"><a name="2958">2958: </a></span>						// reinitialize the test case
<span class="nocode"><a name="2959">2959: </a></span>						// that is of minimum cost;
<span class="nocode"><a name="2960">2960: </a></span>						// this is the one that we
<span class="nocode"><a name="2961">2961: </a></span>						// will currently be
<span class="nocode"><a name="2962">2962: </a></span>						// considering
<span class="nocode"><a name="2963">2963: </a></span>						minCostSingleTestSubset = 
<span class="nocode"><a name="2964">2964: </a></span>						    currentTestSubset;
<span class="nocode"><a name="2965">2965: </a></span>
<span class="nocode"><a name="2966">2966: </a></span>						// set the cost for this 
<span class="nocode"><a name="2967">2967: </a></span>						// specific test cse
<span class="nocode"><a name="2968">2968: </a></span>						minimumTestSubsetCost = 
<span class="nocode"><a name="2969">2969: </a></span>						    currentTestSubsetCost;
<span class="nocode"><a name="2970">2970: </a></span>						
<span class="nocode"><a name="2971">2971: </a></span>						// add this test case in as
<span class="nocode"><a name="2972">2972: </a></span>						// the first of those that
<span class="nocode"><a name="2973">2973: </a></span>						// might be of equal cost (of
<span class="nocode"><a name="2974">2974: </a></span>						// course, we might not find
<span class="nocode"><a name="2975">2975: </a></span>						// any others and then we have
<span class="nocode"><a name="2976">2976: </a></span>						// a singleton set)
<span class="nocode"><a name="2977">2977: </a></span>						equalCostSubsets.
<span class="nocode"><a name="2978">2978: </a></span>						    add(minCostSingleTestSubset);
<span class="nocode"><a name="2979">2979: </a></span>					
<span class="nocode"><a name="2980">2980: </a></span>					    }
<span class="nocode"><a name="2981">2981: </a></span>					
<span class="nocode"><a name="2982">2982: </a></span>					// we found a TestSubset that is the 
<span class="nocode"><a name="2983">2983: </a></span>					// same cost as the previous one that 
<span class="nocode"><a name="2984">2984: </a></span>					// was considered the minimum
<span class="nocode"><a name="2985">2985: </a></span>					else if( currentTestSubsetCost == 
<span class="nocode"><a name="2986">2986: </a></span>						 minimumTestSubsetCost )
<span class="nocode"><a name="2987">2987: </a></span>					    {
<span class="nocode"><a name="2988">2988: </a></span>
<span class="nocode"><a name="2989">2989: </a></span>	// 					System.out.println(&quot;== cost!&quot;);
<span class="nocode"><a name="2990">2990: </a></span>						equalCostSubsets.
<span class="nocode"><a name="2991">2991: </a></span>						    add(currentTestSubset);
<span class="nocode"><a name="2992">2992: </a></span>
<span class="nocode"><a name="2993">2993: </a></span>					    }
<span class="nocode"><a name="2994">2994: </a></span>					}
<span class="nocode"><a name="2995">2995: </a></span>			    
<span class="nocode"><a name="2996">2996: </a></span>			    else if(metric.equals(&quot;time&quot;))
<span class="nocode"><a name="2997">2997: </a></span>				 {
<span class="nocode"><a name="2998">2998: </a></span>				 
<span class="nocode"><a name="2999">2999: </a></span>				 //	System.out.println(&quot;Using time&quot;);
<span class="nocode"><a name="3000">3000: </a></span>					
<span class="nocode"><a name="3001">3001: </a></span>					// calculate the cost of the currentTestSubset (time)
<span class="nocode"><a name="3002">3002: </a></span>					double currentTestSubsetCost = 
<span class="nocode"><a name="3003">3003: </a></span>				   	 currentTestSubset.getTest().getCost();
<span class="nocode"><a name="3004">3004: </a></span>	// 				System.out.println(&quot;curr calculated cost: &quot; + 
<span class="nocode"><a name="3005">3005: </a></span>// 						   currentTestSubsetCost);
<span class="nocode"><a name="3006">3006: </a></span>					// we found one that is cheaper 
<span class="nocode"><a name="3007">3007: </a></span>
<span class="nocode"><a name="3008">3008: </a></span>					if( currentTestSubsetCost &lt;  
<span class="nocode"><a name="3009">3009: </a></span>				   	 minimumTestSubsetCost )
<span class="nocode"><a name="3010">3010: </a></span>				    {
<span class="nocode"><a name="3011">3011: </a></span>
<span class="nocode"><a name="3012">3012: </a></span>	// 					System.out.println(&quot;Pick you!&quot;);
<span class="nocode"><a name="3013">3013: </a></span>
<span class="nocode"><a name="3014">3014: </a></span>						// extract the set of
<span class="nocode"><a name="3015">3015: </a></span>						// requirements that are
<span class="nocode"><a name="3016">3016: </a></span>						// covered by this test case
<span class="nocode"><a name="3017">3017: </a></span>						// that is of the new minimum
<span class="nocode"><a name="3018">3018: </a></span>						// cost
<span class="nocode"><a name="3019">3019: </a></span>						minCostRequirementSubsetSet = 
<span class="nocode"><a name="3020">3020: </a></span>						    currentTestSubset.
<span class="nocode"><a name="3021">3021: </a></span>						    getRequirementSubsetSet();
<span class="nocode"><a name="3022">3022: </a></span>
<span class="nocode"><a name="3023">3023: </a></span>						// reinitialize the list of
<span class="nocode"><a name="3024">3024: </a></span>						// test cases that are of
<span class="nocode"><a name="3025">3025: </a></span>						// equal cost since we have
<span class="nocode"><a name="3026">3026: </a></span>						// found a new minium
<span class="nocode"><a name="3027">3027: </a></span>						equalCostSubsets = new ArrayList();
<span class="nocode"><a name="3028">3028: </a></span>
<span class="nocode"><a name="3029">3029: </a></span>						// reinitialize the test case
<span class="nocode"><a name="3030">3030: </a></span>						// that is of minimum cost;
<span class="nocode"><a name="3031">3031: </a></span>						// this is the one that we
<span class="nocode"><a name="3032">3032: </a></span>						// will currently be
<span class="nocode"><a name="3033">3033: </a></span>						// considering
<span class="nocode"><a name="3034">3034: </a></span>						minCostSingleTestSubset = 
<span class="nocode"><a name="3035">3035: </a></span>						    currentTestSubset;
<span class="nocode"><a name="3036">3036: </a></span>
<span class="nocode"><a name="3037">3037: </a></span>						// set the cost for this 
<span class="nocode"><a name="3038">3038: </a></span>						// specific test cse
<span class="nocode"><a name="3039">3039: </a></span>						minimumTestSubsetCost = 
<span class="nocode"><a name="3040">3040: </a></span>						    currentTestSubsetCost;
<span class="nocode"><a name="3041">3041: </a></span>						
<span class="nocode"><a name="3042">3042: </a></span>						// add this test case in as
<span class="nocode"><a name="3043">3043: </a></span>						// the first of those that
<span class="nocode"><a name="3044">3044: </a></span>						// might be of equal cost (of
<span class="nocode"><a name="3045">3045: </a></span>						// course, we might not find
<span class="nocode"><a name="3046">3046: </a></span>						// any others and then we have
<span class="nocode"><a name="3047">3047: </a></span>						// a singleton set)
<span class="nocode"><a name="3048">3048: </a></span>						equalCostSubsets.
<span class="nocode"><a name="3049">3049: </a></span>						    add(minCostSingleTestSubset);
<span class="nocode"><a name="3050">3050: </a></span>					
<span class="nocode"><a name="3051">3051: </a></span>					    }
<span class="nocode"><a name="3052">3052: </a></span>					
<span class="nocode"><a name="3053">3053: </a></span>					// we found a TestSubset that is the 
<span class="nocode"><a name="3054">3054: </a></span>					// same cost as the previous one that 
<span class="nocode"><a name="3055">3055: </a></span>					// was considered the minimum
<span class="nocode"><a name="3056">3056: </a></span>					else if( currentTestSubsetCost == 
<span class="nocode"><a name="3057">3057: </a></span>						 minimumTestSubsetCost )
<span class="nocode"><a name="3058">3058: </a></span>					    {
<span class="nocode"><a name="3059">3059: </a></span>
<span class="nocode"><a name="3060">3060: </a></span>	// 					System.out.println(&quot;== cost!&quot;);
<span class="nocode"><a name="3061">3061: </a></span>						equalCostSubsets.
<span class="nocode"><a name="3062">3062: </a></span>						    add(currentTestSubset);
<span class="nocode"><a name="3063">3063: </a></span>
<span class="nocode"><a name="3064">3064: </a></span>					    }
<span class="nocode"><a name="3065">3065: </a></span>					}
<span class="nocode"><a name="3066">3066: </a></span>				}
<span class="nocode"><a name="3067">3067: </a></span>
<span class="nocode"><a name="3068">3068: </a></span>			// we have found a set that does not any longer
<span class="nocode"><a name="3069">3069: </a></span>			// contain viable test requirements
<span class="nocode"><a name="3070">3070: </a></span>			else
<span class="nocode"><a name="3071">3071: </a></span>			    {
<span class="nocode"><a name="3072">3072: </a></span>
<span class="nocode"><a name="3073">3073: </a></span>// 				System.out.println(&quot;Ready to Remove: &quot; +
<span class="nocode"><a name="3074">3074: </a></span>// 						   currentTestSubset);
<span class="nocode"><a name="3075">3075: </a></span>				
<span class="nocode"><a name="3076">3076: </a></span>				// next run through the algorithm go
<span class="nocode"><a name="3077">3077: </a></span>				// ahead and remove this test case
<span class="nocode"><a name="3078">3078: </a></span>				goingToRemove.add(currentTestSubset);
<span class="nocode"><a name="3079">3079: </a></span>				
<span class="nocode"><a name="3080">3080: </a></span>				// NOTE: would like to do this, but 
<span class="nocode"><a name="3081">3081: </a></span>				// cannot because of the CME in Java
<span class="nocode"><a name="3082">3082: </a></span>				//testSubsets.remove(currentTestSubset);
<span class="nocode"><a name="3083">3083: </a></span>				
<span class="nocode"><a name="3084">3084: </a></span>			    }
<span class="nocode"><a name="3085">3085: </a></span>			
<span class="nocode"><a name="3086">3086: </a></span>			// I think that it would be at this point that
<span class="nocode"><a name="3087">3087: </a></span>			// we would resolve any of the types of ties
<span class="nocode"><a name="3088">3088: </a></span>			// that could occur; this could occur with
<span class="nocode"><a name="3089">3089: </a></span>			// respect to granularity or randomly; this could
<span class="nocode"><a name="3090">3090: </a></span>			// be triggered by some type of flag to the 
<span class="nocode"><a name="3091">3091: </a></span>			// method itself although this would break a lot
<span class="nocode"><a name="3092">3092: </a></span>			// of the test cases. SO, JUST NOTE THAT I AM
<span class="nocode"><a name="3093">3093: </a></span>			// REALLY NOT HANDLING TIES!
<span class="nocode"><a name="3094">3094: </a></span>
<span class="nocode"><a name="3095">3095: </a></span>		    }
<span class="nocode"><a name="3096">3096: </a></span>
<span class="nocode"><a name="3097">3097: </a></span>// 		System.out.println(&quot;minCostRequirementSubsetSet = &quot; + 
<span class="nocode"><a name="3098">3098: </a></span>// 				   minCostRequirementSubsetSet);
<span class="nocode"><a name="3099">3099: </a></span>
<span class="nocode"><a name="3100">3100: </a></span>// 		System.out.println(&quot;same costs &quot; + equalCostSubsets);
<span class="nocode"><a name="3101">3101: </a></span>
<span class="nocode"><a name="3102">3102: </a></span>		// add the selected minCostRequirementSubsetSet items
<span class="nocode"><a name="3103">3103: </a></span>		// to the cover listing (ONCE AGAIN, IGNORING TIES)
<span class="nocode"><a name="3104">3104: </a></span>		cover.addAll(minCostRequirementSubsetSet);
<span class="nocode"><a name="3105">3105: </a></span>
<span class="nocode"><a name="3106">3106: </a></span>		// set the purchase price of this test case that we
<span class="nocode"><a name="3107">3107: </a></span>		// have just selected and then add it to the set of
<span class="nocode"><a name="3108">3108: </a></span>		// the picked test case (by keeping track of purchase
<span class="nocode"><a name="3109">3109: </a></span>		// price we can know the order of selection)
<span class="nocode"><a name="3110">3110: </a></span>
<span class="nocode"><a name="3111">3111: </a></span>// 		System.out.println(&quot;minCostSingleTestSubset = &quot; +
<span class="nocode"><a name="3112">3112: </a></span>// 				   minCostSingleTestSubset);
<span class="nocode"><a name="3113">3113: </a></span>
<span class="nocode"><a name="3114">3114: </a></span>// 		System.out.println(&quot;getTest = &quot; + 
<span class="nocode"><a name="3115">3115: </a></span>// 				   minCostSingleTestSubset.getTest());
<span class="nocode"><a name="3116">3116: </a></span>
<span class="nocode"><a name="3117">3117: </a></span>		// purchase the test which means applying the cost
<span class="nocode"><a name="3118">3118: </a></span>		// for the entire TestSubset to this specific test
<span class="nocode"><a name="3119">3119: </a></span>		minCostSingleTestSubset.getTest().
<span class="nocode"><a name="3120">3120: </a></span>		    purchase(minimumTestSubsetCost);
<span class="nocode"><a name="3121">3121: </a></span>
<span class="nocode"><a name="3122">3122: </a></span>		// add this **SingleTest** into the final coverPickSets
<span class="nocode"><a name="3123">3123: </a></span>		// note that this might be better as a SingleTestSubset
<span class="nocode"><a name="3124">3124: </a></span>		// but we are keeping this approach because it breaks
<span class="nocode"><a name="3125">3125: </a></span>		// the tests and the clients
<span class="nocode"><a name="3126">3126: </a></span>		coverPickSets.add(minCostSingleTestSubset.getTest());
<span class="nocode"><a name="3127">3127: </a></span>
<span class="nocode"><a name="3128">3128: </a></span>		// add the SingleTestSubset to the listing that can
<span class="nocode"><a name="3129">3129: </a></span>		// be accessed after the reduction has been completed
<span class="nocode"><a name="3130">3130: </a></span>		reducedSingleTestSubsets.add(minCostSingleTestSubset);
<span class="nocode"><a name="3131">3131: </a></span>
<span class="nocode"><a name="3132">3132: </a></span>		// WRONG: this would take them out of U and we have to
<span class="nocode"><a name="3133">3133: </a></span>		// compare to U as the algorithm continues to execute
<span class="nocode"><a name="3134">3134: </a></span>
<span class="nocode"><a name="3135">3135: </a></span>		// remove the one with the minimum cost from 
<span class="nocode"><a name="3136">3136: </a></span>		// the testSubsets
<span class="nocode"><a name="3137">3137: </a></span>// 		boolean foundRsu = requirementSubsetUniverse.
<span class="nocode"><a name="3138">3138: </a></span>// 		   removeAll(minCostRequirementSubsetSet);
<span class="nocode"><a name="3139">3139: </a></span>		
<span class="nocode"><a name="3140">3140: </a></span>// 		System.out.println(&quot;found rSU ? = &quot; + foundRsu);
<span class="nocode"><a name="3141">3141: </a></span>// 		System.out.println();
<span class="nocode"><a name="3142">3142: </a></span>
<span class="nocode"><a name="3143">3143: </a></span>		// we were able to remove this test case from the 
<span class="nocode"><a name="3144">3144: </a></span>		// overall set of test cases (this flag is really
<span class="nocode"><a name="3145">3145: </a></span>		// just used for debugging purposes)
<span class="nocode"><a name="3146">3146: </a></span>		boolean found = testSubsets.remove(minCostSingleTestSubset);
<span class="nocode"><a name="3147">3147: </a></span>
<span class="nocode"><a name="3148">3148: </a></span>// 		System.out.println(&quot;found tS ? = &quot; + found);
<span class="nocode"><a name="3149">3149: </a></span>// 		System.out.println();
<span class="nocode"><a name="3150">3150: </a></span>
<span class="nocode"><a name="3151">3151: </a></span>		// increment counter; really just used for the
<span class="nocode"><a name="3152">3152: </a></span>		// purposes of performance evaluation (always equal to
<span class="nocode"><a name="3153">3153: </a></span>		// the number of final tests in the test suite)
<span class="nocode"><a name="3154">3154: </a></span>		outerWhileExecute++;
<span class="nocode"><a name="3155">3155: </a></span>
<span class="nocode"><a name="3156">3156: </a></span>	    }
<span class="nocode"><a name="3157">3157: </a></span>
<span class="nocode"><a name="3158">3158: </a></span>	// debugging output for now
<span class="nocode"><a name="3159">3159: </a></span>// 	System.out.println(&quot;size of goingtoRemoveTrack = &quot; + 
<span class="nocode"><a name="3160">3160: </a></span>// 			   goingToRemoveTrack.size());
<span class="nocode"><a name="3161">3161: </a></span>
<span class="nocode"><a name="3162">3162: </a></span>	// add back all of the test cases that were removed because
<span class="nocode"><a name="3163">3163: </a></span>	// their set of test requirements were completely exhausted;
<span class="nocode"><a name="3164">3164: </a></span>	// this will support prioritization by repeated reduction
<span class="nocode"><a name="3165">3165: </a></span>	testSubsets.addAll(goingToRemoveTrack);
<span class="nocode"><a name="3166">3166: </a></span>
<span class="nocode"><a name="3167">3167: </a></span>	// take the timing after running the algorithm
<span class="nocode"><a name="3168">3168: </a></span>	long reductionTimeAfter = System.currentTimeMillis();
<span class="nocode"><a name="3169">3169: </a></span>
<span class="nocode"><a name="3170">3170: </a></span>	// calculate the execution time and store the result
<span class="nocode"><a name="3171">3171: </a></span>	reductionTime = (reductionTimeAfter - reductionTimeBefore);
<span class="nocode"><a name="3172">3172: </a></span>
<span class="nocode"><a name="3173">3173: </a></span>	// return the result to the calling method; this actually 
<span class="nocode"><a name="3174">3174: </a></span>	// represents the test cases that we chose to KEEP and 
<span class="nocode"><a name="3175">3175: </a></span>	// thus this is the reduced test suite that we want!
<span class="nocode"><a name="3176">3176: </a></span>	return coverPickSets;
<span class="nocode"><a name="3177">3177: </a></span>
<span class="nocode"><a name="3178">3178: </a></span>    }
<span class="nocode"><a name="3179">3179: </a></span>
<span class="nocode"><a name="3180">3180: </a></span>*/
<span class="nocode"><a name="3181">3181: </a></span>
<span class="nocode"><a name="3182">3182: </a></span>    /**
<span class="nocode"><a name="3183">3183: </a></span>     *  Calculates the redundancies for each of the requirements.
<span class="nocode"><a name="3184">3184: </a></span>     *  This corresponds to how many tests cover an individual
<span class="nocode"><a name="3185">3185: </a></span>     *  requirement.  This will populate the individual
<span class="nocode"><a name="3186">3186: </a></span>     *  RequirementSubsets inside of the universe with their own
<span class="nocode"><a name="3187">3187: </a></span>     *  redundancy information.  This method also returns the maximum
<span class="nocode"><a name="3188">3188: </a></span>     *  redundancy factor for all of the test requirements.
<span class="nocode"><a name="3189">3189: </a></span>     *  
<span class="nocode"><a name="3190">3190: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="3191">3191: </a></span>     */
<span class="nocode"><a name="3192">3192: </a></span>    public int calculateRequirementRedundancy()
<span class="nocode"><a name="3193">3193: </a></span>    {
<span class="nocode"><a name="3194">3194: </a></span>
<span class="nocode"><a name="3195">3195: </a></span>	// set the maximum frequency for the entire test suite that is
<span class="nocode"><a name="3196">3196: </a></span>	// represented as a set cover instance Note that the
<span class="nocode"><a name="3197">3197: </a></span>	// maxFrequency is a measure of the redundancy of a test
<span class="nocode"><a name="3198">3198: </a></span>	// suite's ability to cover the test requirements -- higher
<span class="nocode"><a name="3199">3199: </a></span>	// values are indicators that this test suite has a good
<span class="nocode"><a name="3200">3200: </a></span>	// potential for reduction
<span class="nocode"><a name="3201">3201: </a></span>	int maxFrequency = 0;
<span class="nocode"><a name="3202">3202: </a></span>
<span class="nocode"><a name="3203">3203: </a></span>	// Note that this is inefficient in the circumstance when we
<span class="nocode"><a name="3204">3204: </a></span>	// have converted a HittingSet into a SetCover but absolutely
<span class="nocode"><a name="3205">3205: </a></span>	// needed in the circumstance when we produce the SetCover
<span class="nocode"><a name="3206">3206: </a></span>	// directly (which it seems likely that we will now do!)
<span class="nocode"><a name="3207">3207: </a></span>
<span class="nocode"><a name="3208">3208: </a></span>	// go through the tests and increment the frequencies for 
<span class="nocode"><a name="3209">3209: </a></span>	// each of the test requirements for the current SingleTest
<span class="nocode"><a name="3210">3210: </a></span>
<span class="nocode"><a name="3211">3211: </a></span>	// extract an Iterator of the SingleTestSubsets
<span class="nocode"><a name="3212">3212: </a></span>	Iterator testSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="3213">3213: </a></span>	while( testSubsetIterator.hasNext() )
<span class="nocode"><a name="3214">3214: </a></span>	    {
<span class="nocode"><a name="3215">3215: </a></span>
<span class="nocode"><a name="3216">3216: </a></span>		// extract the currentTestSubset and the SingleTest
<span class="nocode"><a name="3217">3217: </a></span>		// that it contains so we can tell the test requirement
<span class="nocode"><a name="3218">3218: </a></span>		// that it is covered by this test case
<span class="nocode"><a name="3219">3219: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3220">3220: </a></span>		    (SingleTestSubset) testSubsetIterator.next();
<span class="nocode"><a name="3221">3221: </a></span>
<span class="nocode"><a name="3222">3222: </a></span>		SingleTest currentTest = 
<span class="nocode"><a name="3223">3223: </a></span>		    currentTestSubset.getTest();
<span class="nocode"><a name="3224">3224: </a></span>
<span class="nocode"><a name="3225">3225: </a></span>		// extract an iterator of all of the requirements
<span class="nocode"><a name="3226">3226: </a></span>		Iterator requirementsIterator = 
<span class="nocode"><a name="3227">3227: </a></span>		    currentTestSubset.getRequirementSubsetSet().iterator();
<span class="nocode"><a name="3228">3228: </a></span>		while( requirementsIterator.hasNext() )
<span class="nocode"><a name="3229">3229: </a></span>		    {
<span class="nocode"><a name="3230">3230: </a></span>
<span class="nocode"><a name="3231">3231: </a></span>			// indicate that this requirement is covered
<span class="nocode"><a name="3232">3232: </a></span>			// by this current test case
<span class="nocode"><a name="3233">3233: </a></span>			RequirementSubset currentRequirement = 
<span class="nocode"><a name="3234">3234: </a></span>			    (RequirementSubset) requirementsIterator.next();
<span class="nocode"><a name="3235">3235: </a></span>
<span class="nocode"><a name="3236">3236: </a></span>			currentRequirement.addCoveringTest(currentTest);
<span class="nocode"><a name="3237">3237: </a></span>
<span class="nocode"><a name="3238">3238: </a></span>		    }
<span class="nocode"><a name="3239">3239: </a></span>
<span class="nocode"><a name="3240">3240: </a></span>	    }	
<span class="nocode"><a name="3241">3241: </a></span>
<span class="nocode"><a name="3242">3242: </a></span>	// extract an Iterator of the requirement subset universe
<span class="nocode"><a name="3243">3243: </a></span>	Iterator reqSubsetUniverseIterator = 
<span class="nocode"><a name="3244">3244: </a></span>	    requirementSubsetUniverse.iterator();
<span class="nocode"><a name="3245">3245: </a></span>
<span class="nocode"><a name="3246">3246: </a></span>	// go through all of the requirements and calculate the
<span class="nocode"><a name="3247">3247: </a></span>	// requirement redundancy levels
<span class="nocode"><a name="3248">3248: </a></span>	while ( reqSubsetUniverseIterator.hasNext() )
<span class="nocode"><a name="3249">3249: </a></span>	    {
<span class="nocode"><a name="3250">3250: </a></span>
<span class="nocode"><a name="3251">3251: </a></span>		// extract the current subset from the listing
<span class="nocode"><a name="3252">3252: </a></span>		RequirementSubset currentSubset = 
<span class="nocode"><a name="3253">3253: </a></span>		    (RequirementSubset) reqSubsetUniverseIterator.next();
<span class="nocode"><a name="3254">3254: </a></span>
<span class="nocode"><a name="3255">3255: </a></span>		// the frequency of this given subset is just the
<span class="nocode"><a name="3256">3256: </a></span>		// number of test cases that cover it ; the idea here
<span class="nocode"><a name="3257">3257: </a></span>		// is that if the frequency is high then there is a
<span class="nocode"><a name="3258">3258: </a></span>		// lot of overlap among the tests and thus there is a
<span class="nocode"><a name="3259">3259: </a></span>		// strong potential for test suite reduction
<span class="nocode"><a name="3260">3260: </a></span>		int numberOfCoveringTests = 
<span class="nocode"><a name="3261">3261: </a></span>		    currentSubset.getCoveringTests().size();
<span class="nocode"><a name="3262">3262: </a></span>
<span class="nocode"><a name="3263">3263: </a></span>		// set the redundancy for each of the requirements
<span class="nocode"><a name="3264">3264: </a></span>		currentSubset.setRedundancyFactor(numberOfCoveringTests);
<span class="nocode"><a name="3265">3265: </a></span>
<span class="nocode"><a name="3266">3266: </a></span>		// we found a more frequent test requirement and 
<span class="nocode"><a name="3267">3267: </a></span>		// thus we discard the old frequency and use new one
<span class="nocode"><a name="3268">3268: </a></span>		if( maxFrequency &lt; numberOfCoveringTests )
<span class="nocode"><a name="3269">3269: </a></span>		    {
<span class="nocode"><a name="3270">3270: </a></span>
<span class="nocode"><a name="3271">3271: </a></span>			maxFrequency = numberOfCoveringTests;
<span class="nocode"><a name="3272">3272: </a></span>
<span class="nocode"><a name="3273">3273: </a></span>		    }
<span class="nocode"><a name="3274">3274: </a></span>
<span class="nocode"><a name="3275">3275: </a></span>	    }
<span class="nocode"><a name="3276">3276: </a></span>
<span class="nocode"><a name="3277">3277: </a></span> 	return maxFrequency;
<span class="nocode"><a name="3278">3278: </a></span>
<span class="nocode"><a name="3279">3279: </a></span>    }
<span class="nocode"><a name="3280">3280: </a></span>
<span class="nocode"><a name="3281">3281: </a></span>    /**
<span class="nocode"><a name="3282">3282: </a></span>     *  Calculates the redundancies for each of the requirements.
<span class="nocode"><a name="3283">3283: </a></span>     *  This corresponds to how many tests cover an individual
<span class="nocode"><a name="3284">3284: </a></span>     *  requirement.  This will populate the individual
<span class="nocode"><a name="3285">3285: </a></span>     *  RequirementSubsets inside of the universe with their own
<span class="nocode"><a name="3286">3286: </a></span>     *  redundancy information.  This method also returns the
<span class="nocode"><a name="3287">3287: </a></span>     *  redundancy factor for all of the test requirements.
<span class="nocode"><a name="3288">3288: </a></span>     *  
<span class="nocode"><a name="3289">3289: </a></span>     *  This method was added much after the fact because it allows us
<span class="nocode"><a name="3290">3290: </a></span>     *  to make really cool ECDFs to characterize the reduction
<span class="nocode"><a name="3291">3291: </a></span>     *  potential.
<span class="nocode"><a name="3292">3292: </a></span>     *
<span class="nocode"><a name="3293">3293: </a></span>     *  @author Gregory M. Kapfhammer 3/3/2007
<span class="nocode"><a name="3294">3294: </a></span>     */
<span class="nocode"><a name="3295">3295: </a></span>
<span class="nocode"><a name="3296">3296: </a></span>
<span class="nocode"><a name="3297">3297: </a></span>    public ArrayList calculateAllRequirementRedundancy()
<span class="nocode"><a name="3298">3298: </a></span>    {
<span class="nocode"><a name="3299">3299: </a></span>
<span class="nocode"><a name="3300">3300: </a></span>	ArrayList allFrequency = new ArrayList();
<span class="nocode"><a name="3301">3301: </a></span>
<span class="nocode"><a name="3302">3302: </a></span>	// set the maximum frequency for the entire test suite that is
<span class="nocode"><a name="3303">3303: </a></span>	// represented as a set cover instance Note that the
<span class="nocode"><a name="3304">3304: </a></span>	// maxFrequency is a measure of the redundancy of a test
<span class="nocode"><a name="3305">3305: </a></span>	// suite's ability to cover the test requirements -- higher
<span class="nocode"><a name="3306">3306: </a></span>	// values are indicators that this test suite has a good
<span class="nocode"><a name="3307">3307: </a></span>	// potential for reduction
<span class="nocode"><a name="3308">3308: </a></span>	int maxFrequency = 0;
<span class="nocode"><a name="3309">3309: </a></span>
<span class="nocode"><a name="3310">3310: </a></span>	// Note that this is inefficient in the circumstance when we
<span class="nocode"><a name="3311">3311: </a></span>	// have converted a HittingSet into a SetCover but absolutely
<span class="nocode"><a name="3312">3312: </a></span>	// needed in the circumstance when we produce the SetCover
<span class="nocode"><a name="3313">3313: </a></span>	// directly (which it seems likely that we will now do!)
<span class="nocode"><a name="3314">3314: </a></span>
<span class="nocode"><a name="3315">3315: </a></span>	// go through the tests and increment the frequencies for 
<span class="nocode"><a name="3316">3316: </a></span>	// each of the test requirements for the current SingleTest
<span class="nocode"><a name="3317">3317: </a></span>
<span class="nocode"><a name="3318">3318: </a></span>	// extract an Iterator of the SingleTestSubsets
<span class="nocode"><a name="3319">3319: </a></span>	Iterator testSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="3320">3320: </a></span>	while( testSubsetIterator.hasNext() )
<span class="nocode"><a name="3321">3321: </a></span>	    {
<span class="nocode"><a name="3322">3322: </a></span>
<span class="nocode"><a name="3323">3323: </a></span>		// extract the currentTestSubset and the SingleTest
<span class="nocode"><a name="3324">3324: </a></span>		// that it contains so we can tell the test requirement
<span class="nocode"><a name="3325">3325: </a></span>		// that it is covered by this test case
<span class="nocode"><a name="3326">3326: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3327">3327: </a></span>		    (SingleTestSubset) testSubsetIterator.next();
<span class="nocode"><a name="3328">3328: </a></span>
<span class="nocode"><a name="3329">3329: </a></span>		SingleTest currentTest = 
<span class="nocode"><a name="3330">3330: </a></span>		    currentTestSubset.getTest();
<span class="nocode"><a name="3331">3331: </a></span>
<span class="nocode"><a name="3332">3332: </a></span>// 		System.out.println(&quot;Current test: &quot; + currentTest.
<span class="nocode"><a name="3333">3333: </a></span>// 				   toString());
<span class="nocode"><a name="3334">3334: </a></span>
<span class="nocode"><a name="3335">3335: </a></span>		// extract an iterator of all of the requirements
<span class="nocode"><a name="3336">3336: </a></span>		Iterator requirementsIterator = 
<span class="nocode"><a name="3337">3337: </a></span>		    currentTestSubset.getRequirementSubsetSet().iterator();
<span class="nocode"><a name="3338">3338: </a></span>		int i = 0;
<span class="nocode"><a name="3339">3339: </a></span>		while( requirementsIterator.hasNext() )
<span class="nocode"><a name="3340">3340: </a></span>		    {
<span class="nocode"><a name="3341">3341: </a></span>
<span class="nocode"><a name="3342">3342: </a></span>// 			System.out.println(&quot;i = &quot; + i);
<span class="nocode"><a name="3343">3343: </a></span>			i++;
<span class="nocode"><a name="3344">3344: </a></span>
<span class="nocode"><a name="3345">3345: </a></span>			// indicate that this requirement is covered
<span class="nocode"><a name="3346">3346: </a></span>			// by this current test case
<span class="nocode"><a name="3347">3347: </a></span>			RequirementSubset currentRequirement = 
<span class="nocode"><a name="3348">3348: </a></span>			    (RequirementSubset) requirementsIterator.next();
<span class="nocode"><a name="3349">3349: </a></span>
<span class="nocode"><a name="3350">3350: </a></span>			currentRequirement.addCoveringTest(currentTest);
<span class="nocode"><a name="3351">3351: </a></span>
<span class="nocode"><a name="3352">3352: </a></span>		    }
<span class="nocode"><a name="3353">3353: </a></span>
<span class="nocode"><a name="3354">3354: </a></span>	    }	
<span class="nocode"><a name="3355">3355: </a></span>
<span class="nocode"><a name="3356">3356: </a></span>	// extract an Iterator of the requirement subset universe
<span class="nocode"><a name="3357">3357: </a></span>	Iterator reqSubsetUniverseIterator = 
<span class="nocode"><a name="3358">3358: </a></span>	    requirementSubsetUniverse.iterator();
<span class="nocode"><a name="3359">3359: </a></span>
<span class="nocode"><a name="3360">3360: </a></span>	// go through all of the requirements and calculate the
<span class="nocode"><a name="3361">3361: </a></span>	// requirement redundancy levels
<span class="nocode"><a name="3362">3362: </a></span>	while ( reqSubsetUniverseIterator.hasNext() )
<span class="nocode"><a name="3363">3363: </a></span>	    {
<span class="nocode"><a name="3364">3364: </a></span>
<span class="nocode"><a name="3365">3365: </a></span>		// extract the current subset from the listing
<span class="nocode"><a name="3366">3366: </a></span>		RequirementSubset currentSubset = 
<span class="nocode"><a name="3367">3367: </a></span>		    (RequirementSubset) reqSubsetUniverseIterator.next();
<span class="nocode"><a name="3368">3368: </a></span>
<span class="nocode"><a name="3369">3369: </a></span>// 		System.out.println(&quot;Requirement: &quot; + 
<span class="nocode"><a name="3370">3370: </a></span>// 				   currentSubset);
<span class="nocode"><a name="3371">3371: </a></span>
<span class="nocode"><a name="3372">3372: </a></span>		// the frequency of this given subset is just the
<span class="nocode"><a name="3373">3373: </a></span>		// number of test cases that cover it ; the idea here
<span class="nocode"><a name="3374">3374: </a></span>		// is that if the frequency is high then there is a
<span class="nocode"><a name="3375">3375: </a></span>		// lot of overlap among the tests and thus there is a
<span class="nocode"><a name="3376">3376: </a></span>		// strong potential for test suite reduction
<span class="nocode"><a name="3377">3377: </a></span>		int numberOfCoveringTests = 
<span class="nocode"><a name="3378">3378: </a></span>		    currentSubset.getCoveringTests().size();
<span class="nocode"><a name="3379">3379: </a></span>
<span class="nocode"><a name="3380">3380: </a></span>// 		System.out.println(&quot;Covering Tests: &quot; + 
<span class="nocode"><a name="3381">3381: </a></span>// 				   numberOfCoveringTests);
<span class="nocode"><a name="3382">3382: </a></span>
<span class="nocode"><a name="3383">3383: </a></span>		allFrequency.add( new Integer(numberOfCoveringTests) );
<span class="nocode"><a name="3384">3384: </a></span>
<span class="nocode"><a name="3385">3385: </a></span>		// set the redundancy for each of the requirements
<span class="nocode"><a name="3386">3386: </a></span>		currentSubset.setRedundancyFactor(numberOfCoveringTests);
<span class="nocode"><a name="3387">3387: </a></span>
<span class="nocode"><a name="3388">3388: </a></span>		// we found a more frequent test requirement and 
<span class="nocode"><a name="3389">3389: </a></span>		// thus we discard the old frequency and use new one
<span class="nocode"><a name="3390">3390: </a></span>// 		if( maxFrequency &lt; numberOfCoveringTests )
<span class="nocode"><a name="3391">3391: </a></span>// 		    {
<span class="nocode"><a name="3392">3392: </a></span>
<span class="nocode"><a name="3393">3393: </a></span>// 			maxFrequency = numberOfCoveringTests;
<span class="nocode"><a name="3394">3394: </a></span>
<span class="nocode"><a name="3395">3395: </a></span>// 		    }
<span class="nocode"><a name="3396">3396: </a></span>
<span class="nocode"><a name="3397">3397: </a></span>	    }
<span class="nocode"><a name="3398">3398: </a></span>
<span class="nocode"><a name="3399">3399: </a></span> 	return allFrequency;
<span class="nocode"><a name="3400">3400: </a></span>
<span class="nocode"><a name="3401">3401: </a></span>    }
<span class="nocode"><a name="3402">3402: </a></span>
<span class="nocode"><a name="3403">3403: </a></span>    /**
<span class="nocode"><a name="3404">3404: </a></span>     *  Constructs the HGS worst case (tight) problem instance from
<span class="nocode"><a name="3405">3405: </a></span>     *  the current instance of the set cover problem.
<span class="nocode"><a name="3406">3406: </a></span>     *  
<span class="nocode"><a name="3407">3407: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="3408">3408: </a></span>     */
<span class="nocode"><a name="3409">3409: </a></span>
<span class="nocode"><a name="3410">3410: </a></span>
<span class="nocode"><a name="3411">3411: </a></span>/*
<span class="nocode"><a name="3412">3412: </a></span>
<span class="nocode"><a name="3413">3413: </a></span> * Commented out on Nov 30, 2007 by Adam M. Smith to avoid MathLink, Jlink, KernelLink dependencies
<span class="nocode"><a name="3414">3414: </a></span>
<span class="nocode"><a name="3415">3415: </a></span>    public SetCover deriveWorstCase()
<span class="nocode"><a name="3416">3416: </a></span>    {
<span class="nocode"><a name="3417">3417: </a></span>
<span class="nocode"><a name="3418">3418: </a></span>	//SetCover derived = new SetCover();
<span class="nocode"><a name="3419">3419: </a></span>	SetCover derived = (SetCover)this.clone();
<span class="nocode"><a name="3420">3420: </a></span>	
<span class="nocode"><a name="3421">3421: </a></span>	// note that we do not have to make any changes to the 
<span class="nocode"><a name="3422">3422: </a></span>	// requirementSubsetUniverse because these are going 
<span class="nocode"><a name="3423">3423: </a></span>	// to stay the same in the initial instance and the 
<span class="nocode"><a name="3424">3424: </a></span>	// worst case instance
<span class="nocode"><a name="3425">3425: </a></span>
<span class="nocode"><a name="3426">3426: </a></span>	// note that we might be able to do this in a single
<span class="nocode"><a name="3427">3427: </a></span>	// step (this would be more efficient) but I am going
<span class="nocode"><a name="3428">3428: </a></span>	// to first try to implement in multiple steps
<span class="nocode"><a name="3429">3429: </a></span>
<span class="nocode"><a name="3430">3430: </a></span>	// **** YOU HAVE TO OPERATE ON DERIVED **** 
<span class="nocode"><a name="3431">3431: </a></span>
<span class="nocode"><a name="3432">3432: </a></span>	// Step 1. clear out all of the requirements that are inside
<span class="nocode"><a name="3433">3433: </a></span>	// of the SingleTest requirements inside of the testSubsets
<span class="nocode"><a name="3434">3434: </a></span>	
<span class="nocode"><a name="3435">3435: </a></span>	// extract an Iterator of all the testSubsets
<span class="nocode"><a name="3436">3436: </a></span>	Iterator testSubsetsIterator = derived.getTestSubsets().iterator();
<span class="nocode"><a name="3437">3437: </a></span>
<span class="nocode"><a name="3438">3438: </a></span>	// go through all of the testSubsets and clear 
<span class="nocode"><a name="3439">3439: </a></span>	// out their requirements listings (we have to repartition
<span class="nocode"><a name="3440">3440: </a></span>	// these to create a worst case behavior of the algorithm)
<span class="nocode"><a name="3441">3441: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="3442">3442: </a></span>	    {
<span class="nocode"><a name="3443">3443: </a></span>
<span class="nocode"><a name="3444">3444: </a></span>		// extract the current SingleTestSubset
<span class="nocode"><a name="3445">3445: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3446">3446: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="3447">3447: </a></span>
<span class="nocode"><a name="3448">3448: </a></span>		// clear out the requirement set 
<span class="nocode"><a name="3449">3449: </a></span>		currentTestSubset.clearRequirementSubset();
<span class="nocode"><a name="3450">3450: </a></span>
<span class="nocode"><a name="3451">3451: </a></span>	    }
<span class="nocode"><a name="3452">3452: </a></span>
<span class="nocode"><a name="3453">3453: </a></span>	// Step 2. assign all of the test requirements to the
<span class="nocode"><a name="3454">3454: </a></span>	// first n - 1 test cases, leaving the last test case
<span class="nocode"><a name="3455">3455: </a></span>	// to cover all of the test requirements
<span class="nocode"><a name="3456">3456: </a></span>	
<span class="nocode"><a name="3457">3457: </a></span>	// extract an iterator of all of the test requirements
<span class="nocode"><a name="3458">3458: </a></span>	Iterator requirementsIterator = 
<span class="nocode"><a name="3459">3459: </a></span>	    derived.getRequirementSubsetUniverse().iterator();
<span class="nocode"><a name="3460">3460: </a></span>
<span class="nocode"><a name="3461">3461: </a></span>	// this variable can be used to store the last test case
<span class="nocode"><a name="3462">3462: </a></span>	// that we are going to load with all of the requirements
<span class="nocode"><a name="3463">3463: </a></span>	// the null is the flag that we are testing against so
<span class="nocode"><a name="3464">3464: </a></span>	// that we only perform an assignment to this variable once
<span class="nocode"><a name="3465">3465: </a></span>	SingleTestSubset lastTestCaseSubset = null;
<span class="nocode"><a name="3466">3466: </a></span>
<span class="nocode"><a name="3467">3467: </a></span>	// keep assigning all of the tests cases to the first
<span class="nocode"><a name="3468">3468: </a></span>	// n - 1 tests.  Note that we will have to execute the 
<span class="nocode"><a name="3469">3469: </a></span>	// outer while loop multiple times in order to perform
<span class="nocode"><a name="3470">3470: </a></span>	// this part of the derivation
<span class="nocode"><a name="3471">3471: </a></span>	while( requirementsIterator.hasNext() )
<span class="nocode"><a name="3472">3472: </a></span>	    {
<span class="nocode"><a name="3473">3473: </a></span>
<span class="nocode"><a name="3474">3474: </a></span>		// extract an iterator of the testSubsets
<span class="nocode"><a name="3475">3475: </a></span>		Iterator testSubsetsIteratorInner = 
<span class="nocode"><a name="3476">3476: </a></span>		    derived.getTestSubsets().iterator();
<span class="nocode"><a name="3477">3477: </a></span>
<span class="nocode"><a name="3478">3478: </a></span>		// go through all of the n - 1 first test case
<span class="nocode"><a name="3479">3479: </a></span>		// and assign the requirements to them (note 
<span class="nocode"><a name="3480">3480: </a></span>		// that we might have to do this multiple times)
<span class="nocode"><a name="3481">3481: </a></span>		while( testSubsetsIteratorInner.hasNext() )
<span class="nocode"><a name="3482">3482: </a></span>		    {
<span class="nocode"><a name="3483">3483: </a></span>
<span class="nocode"><a name="3484">3484: </a></span>			// extract the current SingleTestSubset
<span class="nocode"><a name="3485">3485: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3486">3486: </a></span>			    (SingleTestSubset) 
<span class="nocode"><a name="3487">3487: </a></span>			    testSubsetsIteratorInner.next();
<span class="nocode"><a name="3488">3488: </a></span>
<span class="nocode"><a name="3489">3489: </a></span>			// this is the last SingleTest and thus we 
<span class="nocode"><a name="3490">3490: </a></span>			// are going to reserve it for all of the 
<span class="nocode"><a name="3491">3491: </a></span>			// tests; do not place any requirement in it
<span class="nocode"><a name="3492">3492: </a></span>			if( !testSubsetsIteratorInner.hasNext() )
<span class="nocode"><a name="3493">3493: </a></span>			    {
<span class="nocode"><a name="3494">3494: </a></span>
<span class="nocode"><a name="3495">3495: </a></span>				// we need to keep track of this test
<span class="nocode"><a name="3496">3496: </a></span>				// case and we have not done so already
<span class="nocode"><a name="3497">3497: </a></span>				if( lastTestCaseSubset == null )
<span class="nocode"><a name="3498">3498: </a></span>				    {
<span class="nocode"><a name="3499">3499: </a></span>
<span class="nocode"><a name="3500">3500: </a></span>					lastTestCaseSubset = 
<span class="nocode"><a name="3501">3501: </a></span>					    currentTestSubset;
<span class="nocode"><a name="3502">3502: </a></span>
<span class="nocode"><a name="3503">3503: </a></span>				    }
<span class="nocode"><a name="3504">3504: </a></span>
<span class="nocode"><a name="3505">3505: </a></span>				continue;
<span class="nocode"><a name="3506">3506: </a></span>
<span class="nocode"><a name="3507">3507: </a></span>			    }
<span class="nocode"><a name="3508">3508: </a></span>
<span class="nocode"><a name="3509">3509: </a></span>			// there is still a requirement and thus 
<span class="nocode"><a name="3510">3510: </a></span>			// we should assign it to the current test 
<span class="nocode"><a name="3511">3511: </a></span>			// case by putting it in the subset
<span class="nocode"><a name="3512">3512: </a></span>			if( requirementsIterator.hasNext() )
<span class="nocode"><a name="3513">3513: </a></span>			    {
<span class="nocode"><a name="3514">3514: </a></span>
<span class="nocode"><a name="3515">3515: </a></span>				// extract the next RequirementSubset
<span class="nocode"><a name="3516">3516: </a></span>				RequirementSubset currentRequirement = 
<span class="nocode"><a name="3517">3517: </a></span>				    (RequirementSubset) 
<span class="nocode"><a name="3518">3518: </a></span>				    requirementsIterator.next();
<span class="nocode"><a name="3519">3519: </a></span>
<span class="nocode"><a name="3520">3520: </a></span>				// we need to clear the set of covering
<span class="nocode"><a name="3521">3521: </a></span>				// tests because we are re-assigning the
<span class="nocode"><a name="3522">3522: </a></span>				// requirements to new sets and the 
<span class="nocode"><a name="3523">3523: </a></span>				// old information is no longer valid 
<span class="nocode"><a name="3524">3524: </a></span>				// (note that the clone carries it over)
<span class="nocode"><a name="3525">3525: </a></span>				currentRequirement.clearCoveringTestSet();
<span class="nocode"><a name="3526">3526: </a></span>				
<span class="nocode"><a name="3527">3527: </a></span>				// add the current requirement into the 
<span class="nocode"><a name="3528">3528: </a></span>				// currentTestSubset (which indicates that
<span class="nocode"><a name="3529">3529: </a></span>				// this SingleTest covers this requirement)
<span class="nocode"><a name="3530">3530: </a></span>				currentTestSubset.
<span class="nocode"><a name="3531">3531: </a></span>				    addRequirementSubset(currentRequirement);
<span class="nocode"><a name="3532">3532: </a></span>			
<span class="nocode"><a name="3533">3533: </a></span>			    }
<span class="nocode"><a name="3534">3534: </a></span>
<span class="nocode"><a name="3535">3535: </a></span>		    }
<span class="nocode"><a name="3536">3536: </a></span>
<span class="nocode"><a name="3537">3537: </a></span>	    }
<span class="nocode"><a name="3538">3538: </a></span>
<span class="nocode"><a name="3539">3539: </a></span>	// Step 3.  All of the test cases have to be placed into
<span class="nocode"><a name="3540">3540: </a></span>	// the last SingleTestSubset.  We can also calculate the 
<span class="nocode"><a name="3541">3541: </a></span>	// cost of this test case to be the inverse of its size
<span class="nocode"><a name="3542">3542: </a></span>	// (and, then, plus the extraCost that we must calculate)
<span class="nocode"><a name="3543">3543: </a></span>
<span class="nocode"><a name="3544">3544: </a></span>// 	System.out.println(&quot;Last test case subset : &quot; + 
<span class="nocode"><a name="3545">3545: </a></span>// 			   lastTestCaseSubset);
<span class="nocode"><a name="3546">3546: </a></span>	
<span class="nocode"><a name="3547">3547: </a></span>	// set the requirements inside of the last test
<span class="nocode"><a name="3548">3548: </a></span>	lastTestCaseSubset.
<span class="nocode"><a name="3549">3549: </a></span>	    setRequirementSubsetSet( (LinkedHashSet) derived.
<span class="nocode"><a name="3550">3550: </a></span>				     getRequirementSubsetUniverse());
<span class="nocode"><a name="3551">3551: </a></span>	
<span class="nocode"><a name="3552">3552: </a></span>	// set the base cost of the last test
<span class="nocode"><a name="3553">3553: </a></span>// 	lastTestCaseSubset.
<span class="nocode"><a name="3554">3554: </a></span>// 	    getTest().
<span class="nocode"><a name="3555">3555: </a></span>// 	    setCost( ( (double) 1 / (double) derived.
<span class="nocode"><a name="3556">3556: </a></span>// 		       getRequirementSubsetUniverse().size() ) );	
<span class="nocode"><a name="3557">3557: </a></span>
<span class="nocode"><a name="3558">3558: </a></span>	lastTestCaseSubset.
<span class="nocode"><a name="3559">3559: </a></span>	    getTest().setCost(1);
<span class="nocode"><a name="3560">3560: </a></span>
<span class="nocode"><a name="3561">3561: </a></span>	// Step 4. Calculate the costs of the tests with respect to 
<span class="nocode"><a name="3562">3562: </a></span>	// what must have already been removed.  Note that we know
<span class="nocode"><a name="3563">3563: </a></span>	// that the test cases that cover the most requirements are
<span class="nocode"><a name="3564">3564: </a></span>	// at the beginning of the test suite
<span class="nocode"><a name="3565">3565: </a></span>
<span class="nocode"><a name="3566">3566: </a></span>	// **** YOU HAVE TO OPERATE ON DERIVED **** 
<span class="nocode"><a name="3567">3567: </a></span>
<span class="nocode"><a name="3568">3568: </a></span>	if( !( derived.getRequirementSubsetUniverse().size() &lt;= 
<span class="nocode"><a name="3569">3569: </a></span>	       derived.getTestSubsets().size() - 1 ) )  
<span class="nocode"><a name="3570">3570: </a></span>	    {
<span class="nocode"><a name="3571">3571: </a></span>
<span class="nocode"><a name="3572">3572: </a></span>// 		System.out.println(&quot;Inside the BIG IF&quot;);
<span class="nocode"><a name="3573">3573: </a></span>
<span class="nocode"><a name="3574">3574: </a></span>		// extract an iterator of all of the SingleTestSubsets
<span class="nocode"><a name="3575">3575: </a></span>		Iterator testSubsetCostIterator = 
<span class="nocode"><a name="3576">3576: </a></span>		    derived.getTestSubsets().iterator();
<span class="nocode"><a name="3577">3577: </a></span>
<span class="nocode"><a name="3578">3578: </a></span>		// flag to indicate whether or not we have calculated the 
<span class="nocode"><a name="3579">3579: </a></span>		// cost for the first test case; we start this at false
<span class="nocode"><a name="3580">3580: </a></span>		// and then set to true once we have encountered first test
<span class="nocode"><a name="3581">3581: </a></span>		boolean calculatedFirstCost = false;
<span class="nocode"><a name="3582">3582: </a></span>
<span class="nocode"><a name="3583">3583: </a></span>		// this is the number of requirements that have been 
<span class="nocode"><a name="3584">3584: </a></span>		// &quot;removed&quot; because of selection in previous rounds 
<span class="nocode"><a name="3585">3585: </a></span>		int removedRequirements = 0;
<span class="nocode"><a name="3586">3586: </a></span>
<span class="nocode"><a name="3587">3587: </a></span>		// this must be the 
<span class="nocode"><a name="3588">3588: </a></span>		int totalRequirementNumber = 
<span class="nocode"><a name="3589">3589: </a></span>		    derived.getRequirementSubsetUniverse().size();
<span class="nocode"><a name="3590">3590: </a></span>
<span class="nocode"><a name="3591">3591: </a></span>		// go through all of the tests in order and calculate the
<span class="nocode"><a name="3592">3592: </a></span>		// cost that would be associated with picking them 
<span class="nocode"><a name="3593">3593: </a></span>		while( testSubsetCostIterator.hasNext() )
<span class="nocode"><a name="3594">3594: </a></span>		    {
<span class="nocode"><a name="3595">3595: </a></span>
<span class="nocode"><a name="3596">3596: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3597">3597: </a></span>			    (SingleTestSubset) testSubsetCostIterator.next();
<span class="nocode"><a name="3598">3598: </a></span>
<span class="nocode"><a name="3599">3599: </a></span>			// this must be the first test case and thus its
<span class="nocode"><a name="3600">3600: </a></span>			// cost has to be the inverse of the size of the 
<span class="nocode"><a name="3601">3601: </a></span>			// nth test case
<span class="nocode"><a name="3602">3602: </a></span>			if( !calculatedFirstCost )
<span class="nocode"><a name="3603">3603: </a></span>			    {
<span class="nocode"><a name="3604">3604: </a></span>
<span class="nocode"><a name="3605">3605: </a></span>				// we are currently assuming that the first
<span class="nocode"><a name="3606">3606: </a></span>				// test case must have one or more
<span class="nocode"><a name="3607">3607: </a></span>				// requirements assigned to it and we will not
<span class="nocode"><a name="3608">3608: </a></span>				// produce a NaN cost for this test
<span class="nocode"><a name="3609">3609: </a></span>				// (otherwise, we would have a test suite that
<span class="nocode"><a name="3610">3610: </a></span>				// does not cover anything)
<span class="nocode"><a name="3611">3611: </a></span>				
<span class="nocode"><a name="3612">3612: </a></span>				int currentSize = currentTestSubset.
<span class="nocode"><a name="3613">3613: </a></span>				    getRequirementSubsetSet().size();
<span class="nocode"><a name="3614">3614: </a></span>
<span class="nocode"><a name="3615">3615: </a></span>				currentTestSubset.getTest().
<span class="nocode"><a name="3616">3616: </a></span>				    setCost( ( (double) currentSize / 
<span class="nocode"><a name="3617">3617: </a></span>					       (double) lastTestCaseSubset.
<span class="nocode"><a name="3618">3618: </a></span>					       getRequirementSubsetSet().
<span class="nocode"><a name="3619">3619: </a></span>					       size() ) );
<span class="nocode"><a name="3620">3620: </a></span>				      
<span class="nocode"><a name="3621">3621: </a></span>				currentTestSubset.getTest().
<span class="nocode"><a name="3622">3622: </a></span>				    setDesiredEffectiveness( 
<span class="nocode"><a name="3623">3623: </a></span>							    lastTestCaseSubset.
<span class="nocode"><a name="3624">3624: </a></span>						     getRequirementSubsetSet().
<span class="nocode"><a name="3625">3625: </a></span>							    size() );
<span class="nocode"><a name="3626">3626: </a></span> 
<span class="nocode"><a name="3627">3627: </a></span>				removedRequirements += currentSize;	
<span class="nocode"><a name="3628">3628: </a></span>				
<span class="nocode"><a name="3629">3629: </a></span>				calculatedFirstCost = true;
<span class="nocode"><a name="3630">3630: </a></span>				
<span class="nocode"><a name="3631">3631: </a></span>			    }
<span class="nocode"><a name="3632">3632: </a></span>
<span class="nocode"><a name="3633">3633: </a></span>			// we have encountered the last test and we do 
<span class="nocode"><a name="3634">3634: </a></span>			// not need to consider it since its cost has 
<span class="nocode"><a name="3635">3635: </a></span>			// already been calculated
<span class="nocode"><a name="3636">3636: </a></span>			else if( !testSubsetCostIterator.hasNext() )
<span class="nocode"><a name="3637">3637: </a></span>			    {
<span class="nocode"><a name="3638">3638: </a></span>
<span class="nocode"><a name="3639">3639: </a></span>				continue;
<span class="nocode"><a name="3640">3640: </a></span>
<span class="nocode"><a name="3641">3641: </a></span>			    }  
<span class="nocode"><a name="3642">3642: </a></span>
<span class="nocode"><a name="3643">3643: </a></span>			// we are not calculating the cost of the first 
<span class="nocode"><a name="3644">3644: </a></span>			// test case and we are not at the last test case
<span class="nocode"><a name="3645">3645: </a></span>			else
<span class="nocode"><a name="3646">3646: </a></span>			    {
<span class="nocode"><a name="3647">3647: </a></span>			
<span class="nocode"><a name="3648">3648: </a></span>				int currentSize = currentTestSubset.
<span class="nocode"><a name="3649">3649: </a></span>				    getRequirementSubsetSet().size();
<span class="nocode"><a name="3650">3650: </a></span>				
<span class="nocode"><a name="3651">3651: </a></span>				double everyCost = 
<span class="nocode"><a name="3652">3652: </a></span>				    ( (double) currentSize / 
<span class="nocode"><a name="3653">3653: </a></span>				      (double) 
<span class="nocode"><a name="3654">3654: </a></span>				      (totalRequirementNumber - 
<span class="nocode"><a name="3655">3655: </a></span>				       removedRequirements) );
<span class="nocode"><a name="3656">3656: </a></span>
<span class="nocode"><a name="3657">3657: </a></span>				currentTestSubset.getTest().
<span class="nocode"><a name="3658">3658: </a></span>				    setCost( everyCost );
<span class="nocode"><a name="3659">3659: </a></span>				
<span class="nocode"><a name="3660">3660: </a></span>				currentTestSubset.
<span class="nocode"><a name="3661">3661: </a></span>				    getTest().
<span class="nocode"><a name="3662">3662: </a></span>				    setDesiredEffectiveness( 
<span class="nocode"><a name="3663">3663: </a></span>						  (totalRequirementNumber - 
<span class="nocode"><a name="3664">3664: </a></span>						   removedRequirements) );
<span class="nocode"><a name="3665">3665: </a></span>
<span class="nocode"><a name="3666">3666: </a></span>				removedRequirements += currentSize;
<span class="nocode"><a name="3667">3667: </a></span>				
<span class="nocode"><a name="3668">3668: </a></span>			    }
<span class="nocode"><a name="3669">3669: </a></span>
<span class="nocode"><a name="3670">3670: </a></span>		    }
<span class="nocode"><a name="3671">3671: </a></span>
<span class="nocode"><a name="3672">3672: </a></span>		// Step 5. Calculate the extra cost for T_n which will ensure
<span class="nocode"><a name="3673">3673: </a></span>		// that we always select the smaller size test suite instead
<span class="nocode"><a name="3674">3674: </a></span>		// of picking the largest test suite that in the end would
<span class="nocode"><a name="3675">3675: </a></span>		// ensure the lowest cost for executing the test suite
<span class="nocode"><a name="3676">3676: </a></span>	
<span class="nocode"><a name="3677">3677: </a></span>		KernelLink ml = null;
<span class="nocode"><a name="3678">3678: </a></span>
<span class="nocode"><a name="3679">3679: </a></span>		String mathematicaConnect = 
<span class="nocode"><a name="3680">3680: </a></span>		    &quot;-linkmode launch -linkname \'math -mathlink\'&quot;;
<span class="nocode"><a name="3681">3681: </a></span>
<span class="nocode"><a name="3682">3682: </a></span>		//		ml = Util.getMathematicaLink();
<span class="nocode"><a name="3683">3683: </a></span>
<span class="nocode"><a name="3684">3684: </a></span>		try 
<span class="nocode"><a name="3685">3685: </a></span>		    {
<span class="nocode"><a name="3686">3686: </a></span>		
<span class="nocode"><a name="3687">3687: </a></span>			ml = MathLinkFactory.
<span class="nocode"><a name="3688">3688: </a></span>			    createKernelLink(mathematicaConnect);
<span class="nocode"><a name="3689">3689: </a></span>		
<span class="nocode"><a name="3690">3690: </a></span>// 			System.out.println(&quot;after kernel link&quot;);
<span class="nocode"><a name="3691">3691: </a></span>
<span class="nocode"><a name="3692">3692: </a></span>		    } 
<span class="nocode"><a name="3693">3693: </a></span>
<span class="nocode"><a name="3694">3694: </a></span>		catch (MathLinkException e) 
<span class="nocode"><a name="3695">3695: </a></span>		    {
<span class="nocode"><a name="3696">3696: </a></span>		
<span class="nocode"><a name="3697">3697: </a></span>			System.out.println(&quot;Fatal error opening link: &quot; + 
<span class="nocode"><a name="3698">3698: </a></span>					   e.getMessage());
<span class="nocode"><a name="3699">3699: </a></span>			e.printStackTrace();
<span class="nocode"><a name="3700">3700: </a></span>	    
<span class="nocode"><a name="3701">3701: </a></span>		    }
<span class="nocode"><a name="3702">3702: </a></span>
<span class="nocode"><a name="3703">3703: </a></span>		try 
<span class="nocode"><a name="3704">3704: </a></span>		    {
<span class="nocode"><a name="3705">3705: </a></span>			
<span class="nocode"><a name="3706">3706: </a></span>			// Get rid of the initial InputNamePacket the kernel
<span class="nocode"><a name="3707">3707: </a></span>			// will send when it is launched.
<span class="nocode"><a name="3708">3708: </a></span>			ml.discardAnswer();
<span class="nocode"><a name="3709">3709: </a></span>
<span class="nocode"><a name="3710">3710: </a></span>			// these are the StringBuffers that will contain the 
<span class="nocode"><a name="3711">3711: </a></span>			// final Mathematica code that we will send 
<span class="nocode"><a name="3712">3712: </a></span>			StringBuffer solveFirstLine = new StringBuffer();
<span class="nocode"><a name="3713">3713: </a></span>			StringBuffer solveAfterFirst = new StringBuffer();
<span class="nocode"><a name="3714">3714: </a></span>
<span class="nocode"><a name="3715">3715: </a></span>			// call FindInstance and give numerical approximation
<span class="nocode"><a name="3716">3716: </a></span>			solveFirstLine.append(&quot;N[FindInstance[&quot;);
<span class="nocode"><a name="3717">3717: </a></span>
<span class="nocode"><a name="3718">3718: </a></span>			// get an iterator of the costs and build up string
<span class="nocode"><a name="3719">3719: </a></span>			Iterator testSolveIterator = 
<span class="nocode"><a name="3720">3720: </a></span>			    derived.getTestSubsets().iterator();
<span class="nocode"><a name="3721">3721: </a></span>		
<span class="nocode"><a name="3722">3722: </a></span>// 			System.out.println(&quot;before the while tSI.hasNext&quot;);
<span class="nocode"><a name="3723">3723: </a></span>
<span class="nocode"><a name="3724">3724: </a></span>			while( testSolveIterator.hasNext() )
<span class="nocode"><a name="3725">3725: </a></span>			    {
<span class="nocode"><a name="3726">3726: </a></span>
<span class="nocode"><a name="3727">3727: </a></span>				SingleTestSubset currentTestSolve = 
<span class="nocode"><a name="3728">3728: </a></span>				    (SingleTestSubset) 
<span class="nocode"><a name="3729">3729: </a></span>				    testSolveIterator.next();
<span class="nocode"><a name="3730">3730: </a></span>
<span class="nocode"><a name="3731">3731: </a></span>				// there is still another term and thus we
<span class="nocode"><a name="3732">3732: </a></span>				// have to include a plus sign 
<span class="nocode"><a name="3733">3733: </a></span>				if( testSolveIterator.hasNext() )
<span class="nocode"><a name="3734">3734: </a></span>				    {
<span class="nocode"><a name="3735">3735: </a></span>
<span class="nocode"><a name="3736">3736: </a></span>					double currentCost = 
<span class="nocode"><a name="3737">3737: </a></span>					    currentTestSolve.getTest().
<span class="nocode"><a name="3738">3738: </a></span>					    getCost();
<span class="nocode"><a name="3739">3739: </a></span>
<span class="nocode"><a name="3740">3740: </a></span>					// add to the first conjunct
<span class="nocode"><a name="3741">3741: </a></span>					// related to the costs of
<span class="nocode"><a name="3742">3742: </a></span>					// each test case
<span class="nocode"><a name="3743">3743: </a></span>					solveFirstLine.
<span class="nocode"><a name="3744">3744: </a></span>					    append(currentCost);
<span class="nocode"><a name="3745">3745: </a></span>
<span class="nocode"><a name="3746">3746: </a></span>					// add the the last
<span class="nocode"><a name="3747">3747: </a></span>					// conjunctions for the
<span class="nocode"><a name="3748">3748: </a></span>					// relationships between each
<span class="nocode"><a name="3749">3749: </a></span>					// cost effective ness value
<span class="nocode"><a name="3750">3750: </a></span>					// (currently, F in the notes)
<span class="nocode"><a name="3751">3751: </a></span>					solveAfterFirst.
<span class="nocode"><a name="3752">3752: </a></span>					    append( &quot; (&quot; + &quot;1 / &quot; +
<span class="nocode"><a name="3753">3753: </a></span>						   currentTestSolve.getTest().
<span class="nocode"><a name="3754">3754: </a></span>						   getDesiredEffectiveness() + 
<span class="nocode"><a name="3755">3755: </a></span>						    &quot;) &lt; &quot;);
<span class="nocode"><a name="3756">3756: </a></span>
<span class="nocode"><a name="3757">3757: </a></span>					solveAfterFirst.
<span class="nocode"><a name="3758">3758: </a></span>					    append( &quot;(&quot; + 
<span class="nocode"><a name="3759">3759: </a></span>						    NUMERATOR_EFFECTIVE + 
<span class="nocode"><a name="3760">3760: </a></span>						    &quot; + ec)/&quot;);
<span class="nocode"><a name="3761">3761: </a></span>				
<span class="nocode"><a name="3762">3762: </a></span>					solveAfterFirst.
<span class="nocode"><a name="3763">3763: </a></span>					    append(currentTestSolve.getTest().
<span class="nocode"><a name="3764">3764: </a></span>						   getDesiredEffectiveness() );
<span class="nocode"><a name="3765">3765: </a></span>				
<span class="nocode"><a name="3766">3766: </a></span>					// we can assume that the last test
<span class="nocode"><a name="3767">3767: </a></span>					// case will always have a cost of 1.0
<span class="nocode"><a name="3768">3768: </a></span>					// and thus we should only append the
<span class="nocode"><a name="3769">3769: </a></span>					// plus sign if this is not where we
<span class="nocode"><a name="3770">3770: </a></span>					// are currently looking
<span class="nocode"><a name="3771">3771: </a></span>					if( currentCost != LAST_TEST_COST )
<span class="nocode"><a name="3772">3772: </a></span>					    {
<span class="nocode"><a name="3773">3773: </a></span>						
<span class="nocode"><a name="3774">3774: </a></span>						solveFirstLine.append(&quot; + &quot;);
<span class="nocode"><a name="3775">3775: </a></span>						solveAfterFirst.append(&quot; &amp;&amp;&quot;);
<span class="nocode"><a name="3776">3776: </a></span>
<span class="nocode"><a name="3777">3777: </a></span>					    }
<span class="nocode"><a name="3778">3778: </a></span>
<span class="nocode"><a name="3779">3779: </a></span>				    }
<span class="nocode"><a name="3780">3780: </a></span>				
<span class="nocode"><a name="3781">3781: </a></span>				// we are on the last test case and it
<span class="nocode"><a name="3782">3782: </a></span>				// does not get appended to this part
<span class="nocode"><a name="3783">3783: </a></span>				// of the inequality
<span class="nocode"><a name="3784">3784: </a></span>				else
<span class="nocode"><a name="3785">3785: </a></span>				    {
<span class="nocode"><a name="3786">3786: </a></span>
<span class="nocode"><a name="3787">3787: </a></span>					continue;
<span class="nocode"><a name="3788">3788: </a></span>
<span class="nocode"><a name="3789">3789: </a></span>				    }
<span class="nocode"><a name="3790">3790: </a></span>
<span class="nocode"><a name="3791">3791: </a></span>			    }
<span class="nocode"><a name="3792">3792: </a></span>		
<span class="nocode"><a name="3793">3793: </a></span>			// add on the appropriate inequality ; we are
<span class="nocode"><a name="3794">3794: </a></span>			// always assuming default cost for the last
<span class="nocode"><a name="3795">3795: </a></span>			// test case and the free variable ec for the
<span class="nocode"><a name="3796">3796: </a></span>			// &quot;extra cost&quot;
<span class="nocode"><a name="3797">3797: </a></span>			solveFirstLine.append(&quot; &gt; 1 + ec &amp;&amp;&quot;);
<span class="nocode"><a name="3798">3798: </a></span>
<span class="nocode"><a name="3799">3799: </a></span>			solveAfterFirst.append(&quot;, ec]]&quot;);
<span class="nocode"><a name="3800">3800: </a></span>
<span class="nocode"><a name="3801">3801: </a></span>			// debugging output for now
<span class="nocode"><a name="3802">3802: </a></span>// 			System.out.println(&quot;solveFirstLine = &quot; +
<span class="nocode"><a name="3803">3803: </a></span>// 					   solveFirstLine.toString());
<span class="nocode"><a name="3804">3804: </a></span>// 			System.out.println(&quot;solveAfterFirst = &quot; +
<span class="nocode"><a name="3805">3805: </a></span>// 					   solveAfterFirst.toString());
<span class="nocode"><a name="3806">3806: </a></span>// 			System.out.println(solveFirstLine.toString() + &quot; &quot; +
<span class="nocode"><a name="3807">3807: </a></span>// 					   solveAfterFirst.toString() );
<span class="nocode"><a name="3808">3808: </a></span>
<span class="nocode"><a name="3809">3809: </a></span>			// send the final string to Mathematica through 
<span class="nocode"><a name="3810">3810: </a></span>			// J/Link and retrieve the answer as a string
<span class="nocode"><a name="3811">3811: </a></span>			String solveForEc = ml.
<span class="nocode"><a name="3812">3812: </a></span>			    evaluateToOutputForm( solveFirstLine.
<span class="nocode"><a name="3813">3813: </a></span>						  toString() + &quot; &quot; +
<span class="nocode"><a name="3814">3814: </a></span>						  solveAfterFirst.
<span class="nocode"><a name="3815">3815: </a></span>						  toString(), 0 );
<span class="nocode"><a name="3816">3816: </a></span>
<span class="nocode"><a name="3817">3817: </a></span>// 			System.out.println(&quot;solveForEc = &quot; + solveForEc);
<span class="nocode"><a name="3818">3818: </a></span>
<span class="nocode"><a name="3819">3819: </a></span>			// use Java regular expressions to isolate the decimal
<span class="nocode"><a name="3820">3820: </a></span>			// that is inside of the String that is returned 
<span class="nocode"><a name="3821">3821: </a></span>			// from Mathematica 
<span class="nocode"><a name="3822">3822: </a></span>			Pattern decimalPattern = Pattern.
<span class="nocode"><a name="3823">3823: </a></span>			    compile(&quot;[0-9]*[\\.][0-9]*&quot;);
<span class="nocode"><a name="3824">3824: </a></span>			Matcher decimalMatcher = decimalPattern.
<span class="nocode"><a name="3825">3825: </a></span>			    matcher(solveForEc);
<span class="nocode"><a name="3826">3826: </a></span>			boolean decimalMatches = decimalMatcher.find();
<span class="nocode"><a name="3827">3827: </a></span>			
<span class="nocode"><a name="3828">3828: </a></span>			// we found the decimal inside of the String that is
<span class="nocode"><a name="3829">3829: </a></span>			// returned by Mathematica and we must 
<span class="nocode"><a name="3830">3830: </a></span>			if( decimalMatches )
<span class="nocode"><a name="3831">3831: </a></span>			    {
<span class="nocode"><a name="3832">3832: </a></span>
<span class="nocode"><a name="3833">3833: </a></span>				String finalDecimal = decimalMatcher.group();
<span class="nocode"><a name="3834">3834: </a></span>				
<span class="nocode"><a name="3835">3835: </a></span>// 				System.out.println( &quot;Decimal = &quot; + 
<span class="nocode"><a name="3836">3836: </a></span>// 						    finalDecimal );
<span class="nocode"><a name="3837">3837: </a></span>
<span class="nocode"><a name="3838">3838: </a></span>				Double extraCostD = new Double(finalDecimal);
<span class="nocode"><a name="3839">3839: </a></span>				
<span class="nocode"><a name="3840">3840: </a></span>				lastTestCaseSubset.getTest().
<span class="nocode"><a name="3841">3841: </a></span>				    setExtraCost( extraCostD.doubleValue() );
<span class="nocode"><a name="3842">3842: </a></span>
<span class="nocode"><a name="3843">3843: </a></span>			    }
<span class="nocode"><a name="3844">3844: </a></span>
<span class="nocode"><a name="3845">3845: </a></span>			else
<span class="nocode"><a name="3846">3846: </a></span>			    {
<span class="nocode"><a name="3847">3847: </a></span>				
<span class="nocode"><a name="3848">3848: </a></span>				// for debugging only!
<span class="nocode"><a name="3849">3849: </a></span>				//System.out.println(&quot;did not match&quot;);
<span class="nocode"><a name="3850">3850: </a></span>
<span class="nocode"><a name="3851">3851: </a></span>			    }
<span class="nocode"><a name="3852">3852: </a></span>
<span class="nocode"><a name="3853">3853: </a></span>			ml.close();
<span class="nocode"><a name="3854">3854: </a></span>
<span class="nocode"><a name="3855">3855: </a></span>		    }
<span class="nocode"><a name="3856">3856: </a></span>
<span class="nocode"><a name="3857">3857: </a></span>		catch (MathLinkException e) 
<span class="nocode"><a name="3858">3858: </a></span>		    {
<span class="nocode"><a name="3859">3859: </a></span>		
<span class="nocode"><a name="3860">3860: </a></span>			System.out.println(&quot;MathLinkException occurred: &quot; + 
<span class="nocode"><a name="3861">3861: </a></span>					   e.getMessage());
<span class="nocode"><a name="3862">3862: </a></span>			e.printStackTrace();
<span class="nocode"><a name="3863">3863: </a></span>		
<span class="nocode"><a name="3864">3864: </a></span>		    } 
<span class="nocode"><a name="3865">3865: </a></span>
<span class="nocode"><a name="3866">3866: </a></span>		finally 
<span class="nocode"><a name="3867">3867: </a></span>		    {
<span class="nocode"><a name="3868">3868: </a></span>		
<span class="nocode"><a name="3869">3869: </a></span>			ml.close();
<span class="nocode"><a name="3870">3870: </a></span>		
<span class="nocode"><a name="3871">3871: </a></span>		    }
<span class="nocode"><a name="3872">3872: </a></span>
<span class="nocode"><a name="3873">3873: </a></span>	    }
<span class="nocode"><a name="3874">3874: </a></span>
<span class="nocode"><a name="3875">3875: </a></span>	// there are less test requirements than there are test cases
<span class="nocode"><a name="3876">3876: </a></span>	else
<span class="nocode"><a name="3877">3877: </a></span>	    {
<span class="nocode"><a name="3878">3878: </a></span>
<span class="nocode"><a name="3879">3879: </a></span>// 		System.out.println(&quot;In LITTLE else&quot;);
<span class="nocode"><a name="3880">3880: </a></span>
<span class="nocode"><a name="3881">3881: </a></span>		lastTestCaseSubset.getTest().setCost(LAST_TEST_COST);
<span class="nocode"><a name="3882">3882: </a></span>
<span class="nocode"><a name="3883">3883: </a></span>		int maxDenominator = 
<span class="nocode"><a name="3884">3884: </a></span>		    derived.getRequirementSubsetUniverse().size();
<span class="nocode"><a name="3885">3885: </a></span>		int initialMaxDenominator = maxDenominator;
<span class="nocode"><a name="3886">3886: </a></span>		
<span class="nocode"><a name="3887">3887: </a></span>		Iterator testSubsetCostIterator = 
<span class="nocode"><a name="3888">3888: </a></span>		    derived.getTestSubsets().iterator();
<span class="nocode"><a name="3889">3889: </a></span>
<span class="nocode"><a name="3890">3890: </a></span>		while( testSubsetCostIterator.hasNext() )
<span class="nocode"><a name="3891">3891: </a></span>		    {
<span class="nocode"><a name="3892">3892: </a></span>
<span class="nocode"><a name="3893">3893: </a></span>			SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="3894">3894: </a></span>			    (SingleTestSubset) 
<span class="nocode"><a name="3895">3895: </a></span>			    testSubsetCostIterator.next();
<span class="nocode"><a name="3896">3896: </a></span>
<span class="nocode"><a name="3897">3897: </a></span>			if( maxDenominator &gt;= 1 )
<span class="nocode"><a name="3898">3898: </a></span>			    {
<span class="nocode"><a name="3899">3899: </a></span>
<span class="nocode"><a name="3900">3900: </a></span>				currentTestSubset.getTest().
<span class="nocode"><a name="3901">3901: </a></span>				    setCost( (double) 1 / 
<span class="nocode"><a name="3902">3902: </a></span>					     (double) maxDenominator );
<span class="nocode"><a name="3903">3903: </a></span>
<span class="nocode"><a name="3904">3904: </a></span>				maxDenominator--;
<span class="nocode"><a name="3905">3905: </a></span>
<span class="nocode"><a name="3906">3906: </a></span>			    }
<span class="nocode"><a name="3907">3907: </a></span>
<span class="nocode"><a name="3908">3908: </a></span>			else
<span class="nocode"><a name="3909">3909: </a></span>			    {
<span class="nocode"><a name="3910">3910: </a></span>
<span class="nocode"><a name="3911">3911: </a></span>				if( currentTestSubset != 
<span class="nocode"><a name="3912">3912: </a></span>				    lastTestCaseSubset )
<span class="nocode"><a name="3913">3913: </a></span>				    {
<span class="nocode"><a name="3914">3914: </a></span>
<span class="nocode"><a name="3915">3915: </a></span>					currentTestSubset.getTest().
<span class="nocode"><a name="3916">3916: </a></span>					    setCost( NO_COVER_COST );
<span class="nocode"><a name="3917">3917: </a></span>
<span class="nocode"><a name="3918">3918: </a></span>				    }
<span class="nocode"><a name="3919">3919: </a></span>
<span class="nocode"><a name="3920">3920: </a></span>			    }
<span class="nocode"><a name="3921">3921: </a></span>
<span class="nocode"><a name="3922">3922: </a></span>		    }
<span class="nocode"><a name="3923">3923: </a></span>
<span class="nocode"><a name="3924">3924: </a></span>		// build up the string that has to be sent to Mathematica
<span class="nocode"><a name="3925">3925: </a></span>		// in order to calculate the extra cost
<span class="nocode"><a name="3926">3926: </a></span>		StringBuffer extraCost = new StringBuffer();
<span class="nocode"><a name="3927">3927: </a></span>		extraCost.append(&quot;N[FindInstance[&quot;);
<span class="nocode"><a name="3928">3928: </a></span>
<span class="nocode"><a name="3929">3929: </a></span>		extraCost.append(&quot;(&quot; + 1 + &quot;/&quot; + 
<span class="nocode"><a name="3930">3930: </a></span>				 initialMaxDenominator + &quot;) &lt; &quot; + 
<span class="nocode"><a name="3931">3931: </a></span>				 &quot;((&quot; + 1 + &quot;/&quot; + 
<span class="nocode"><a name="3932">3932: </a></span>				 initialMaxDenominator + &quot;) + ec) &amp;&amp;&quot;);
<span class="nocode"><a name="3933">3933: </a></span>
<span class="nocode"><a name="3934">3934: </a></span>		extraCost.append(&quot;HarmonicNumber[&quot; + 
<span class="nocode"><a name="3935">3935: </a></span>				 initialMaxDenominator + &quot;] &gt; &quot; +  
<span class="nocode"><a name="3936">3936: </a></span>				  &quot;((&quot; + 1 + &quot;/&quot; + 
<span class="nocode"><a name="3937">3937: </a></span>				 initialMaxDenominator + &quot;) + ec)&quot;);
<span class="nocode"><a name="3938">3938: </a></span>		
<span class="nocode"><a name="3939">3939: </a></span>		extraCost.append(&quot;, ec ]]&quot;);
<span class="nocode"><a name="3940">3940: </a></span>
<span class="nocode"><a name="3941">3941: </a></span>// 		System.out.println(&quot;extraCost = &quot;);
<span class="nocode"><a name="3942">3942: </a></span>// 		System.out.println();
<span class="nocode"><a name="3943">3943: </a></span>// 		System.out.println(extraCost);
<span class="nocode"><a name="3944">3944: </a></span>
<span class="nocode"><a name="3945">3945: </a></span>		KernelLink ml = null;
<span class="nocode"><a name="3946">3946: </a></span>
<span class="nocode"><a name="3947">3947: </a></span>		String mathematicaConnect = 
<span class="nocode"><a name="3948">3948: </a></span>		    &quot;-linkmode launch -linkname \'math -mathlink\'&quot;;
<span class="nocode"><a name="3949">3949: </a></span>
<span class="nocode"><a name="3950">3950: </a></span>		try 
<span class="nocode"><a name="3951">3951: </a></span>		    {
<span class="nocode"><a name="3952">3952: </a></span>		
<span class="nocode"><a name="3953">3953: </a></span>			ml = MathLinkFactory.
<span class="nocode"><a name="3954">3954: </a></span>			    createKernelLink(mathematicaConnect);
<span class="nocode"><a name="3955">3955: </a></span>		
<span class="nocode"><a name="3956">3956: </a></span>// 			System.out.println(&quot;after kernel link&quot;);
<span class="nocode"><a name="3957">3957: </a></span>
<span class="nocode"><a name="3958">3958: </a></span>		    } 
<span class="nocode"><a name="3959">3959: </a></span>
<span class="nocode"><a name="3960">3960: </a></span>		catch (MathLinkException e) 
<span class="nocode"><a name="3961">3961: </a></span>		    {
<span class="nocode"><a name="3962">3962: </a></span>		
<span class="nocode"><a name="3963">3963: </a></span>			System.out.println(&quot;Fatal error opening link: &quot; + 
<span class="nocode"><a name="3964">3964: </a></span>					   e.getMessage());
<span class="nocode"><a name="3965">3965: </a></span>			e.printStackTrace();
<span class="nocode"><a name="3966">3966: </a></span>	    
<span class="nocode"><a name="3967">3967: </a></span>		    }
<span class="nocode"><a name="3968">3968: </a></span>
<span class="nocode"><a name="3969">3969: </a></span>		try 
<span class="nocode"><a name="3970">3970: </a></span>		    {
<span class="nocode"><a name="3971">3971: </a></span>			
<span class="nocode"><a name="3972">3972: </a></span>			// Get rid of the initial InputNamePacket the kernel
<span class="nocode"><a name="3973">3973: </a></span>			// will send when it is launched.
<span class="nocode"><a name="3974">3974: </a></span>			ml.discardAnswer();
<span class="nocode"><a name="3975">3975: </a></span>
<span class="nocode"><a name="3976">3976: </a></span>			// send the final string to Mathematica through 
<span class="nocode"><a name="3977">3977: </a></span>			// J/Link and retrieve the answer as a string
<span class="nocode"><a name="3978">3978: </a></span>			String solveForEc = ml.
<span class="nocode"><a name="3979">3979: </a></span>			    evaluateToOutputForm( extraCost.
<span class="nocode"><a name="3980">3980: </a></span>						  toString(), 0 );
<span class="nocode"><a name="3981">3981: </a></span>
<span class="nocode"><a name="3982">3982: </a></span>// 			System.out.println(&quot;solveForEc = &quot; + solveForEc);
<span class="nocode"><a name="3983">3983: </a></span>
<span class="nocode"><a name="3984">3984: </a></span>			// use Java regular expressions to isolate the decimal
<span class="nocode"><a name="3985">3985: </a></span>			// that is inside of the String that is returned 
<span class="nocode"><a name="3986">3986: </a></span>			// from Mathematica 
<span class="nocode"><a name="3987">3987: </a></span>			Pattern decimalPattern = Pattern.
<span class="nocode"><a name="3988">3988: </a></span>			    compile(&quot;[0-9]*[\\.][0-9]*&quot;);
<span class="nocode"><a name="3989">3989: </a></span>			Matcher decimalMatcher = decimalPattern.
<span class="nocode"><a name="3990">3990: </a></span>			    matcher(solveForEc);
<span class="nocode"><a name="3991">3991: </a></span>			boolean decimalMatches = decimalMatcher.find();
<span class="nocode"><a name="3992">3992: </a></span>			
<span class="nocode"><a name="3993">3993: </a></span>			// we found the decimal inside of the String that is
<span class="nocode"><a name="3994">3994: </a></span>			// returned by Mathematica and we must 
<span class="nocode"><a name="3995">3995: </a></span>			if( decimalMatches )
<span class="nocode"><a name="3996">3996: </a></span>			    {
<span class="nocode"><a name="3997">3997: </a></span>
<span class="nocode"><a name="3998">3998: </a></span>				String finalDecimal = decimalMatcher.group();
<span class="nocode"><a name="3999">3999: </a></span>				
<span class="nocode"><a name="4000">4000: </a></span>// 				System.out.println( &quot;Decimal = &quot; + 
<span class="nocode"><a name="4001">4001: </a></span>// 						    finalDecimal );
<span class="nocode"><a name="4002">4002: </a></span>
<span class="nocode"><a name="4003">4003: </a></span>				Double extraCostD = new Double(finalDecimal);
<span class="nocode"><a name="4004">4004: </a></span>				
<span class="nocode"><a name="4005">4005: </a></span>				lastTestCaseSubset.getTest().
<span class="nocode"><a name="4006">4006: </a></span>				    setExtraCost( extraCostD.doubleValue() );
<span class="nocode"><a name="4007">4007: </a></span>
<span class="nocode"><a name="4008">4008: </a></span>			    }
<span class="nocode"><a name="4009">4009: </a></span>
<span class="nocode"><a name="4010">4010: </a></span>			else
<span class="nocode"><a name="4011">4011: </a></span>			    {
<span class="nocode"><a name="4012">4012: </a></span>				
<span class="nocode"><a name="4013">4013: </a></span>				// for debugging only!
<span class="nocode"><a name="4014">4014: </a></span>// 				System.out.println(&quot;did not match&quot;);
<span class="nocode"><a name="4015">4015: </a></span>
<span class="nocode"><a name="4016">4016: </a></span>			    }
<span class="nocode"><a name="4017">4017: </a></span>
<span class="nocode"><a name="4018">4018: </a></span>		    }
<span class="nocode"><a name="4019">4019: </a></span>
<span class="nocode"><a name="4020">4020: </a></span>		catch (MathLinkException e) 
<span class="nocode"><a name="4021">4021: </a></span>		    {
<span class="nocode"><a name="4022">4022: </a></span>		
<span class="nocode"><a name="4023">4023: </a></span>			System.out.println(&quot;MathLinkException occurred: &quot; + 
<span class="nocode"><a name="4024">4024: </a></span>					   e.getMessage());
<span class="nocode"><a name="4025">4025: </a></span>			e.printStackTrace();
<span class="nocode"><a name="4026">4026: </a></span>		
<span class="nocode"><a name="4027">4027: </a></span>		    } 
<span class="nocode"><a name="4028">4028: </a></span>
<span class="nocode"><a name="4029">4029: </a></span>		finally 
<span class="nocode"><a name="4030">4030: </a></span>		    {
<span class="nocode"><a name="4031">4031: </a></span>		
<span class="nocode"><a name="4032">4032: </a></span>			ml.close();
<span class="nocode"><a name="4033">4033: </a></span>		
<span class="nocode"><a name="4034">4034: </a></span>		    }
<span class="nocode"><a name="4035">4035: </a></span>
<span class="nocode"><a name="4036">4036: </a></span>	    }
<span class="nocode"><a name="4037">4037: </a></span>
<span class="nocode"><a name="4038">4038: </a></span>	return derived;
<span class="nocode"><a name="4039">4039: </a></span>
<span class="nocode"><a name="4040">4040: </a></span>    }
<span class="nocode"><a name="4041">4041: </a></span>
<span class="nocode"><a name="4042">4042: </a></span>*/
<span class="nocode"><a name="4043">4043: </a></span>    /**
<span class="nocode"><a name="4044">4044: </a></span>     *  Finds the maximum cost test cases.  
<span class="nocode"><a name="4045">4045: </a></span>     *  
<span class="nocode"><a name="4046">4046: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4047">4047: </a></span>     */
<span class="nocode"><a name="4048">4048: </a></span>    public Set findMaximumCostTests()
<span class="nocode"><a name="4049">4049: </a></span>    {
<span class="nocode"><a name="4050">4050: </a></span>
<span class="nocode"><a name="4051">4051: </a></span>	// this is the listing of all of the tests that have maximum
<span class="nocode"><a name="4052">4052: </a></span>	// cost within the test suite; most likely for most tests this
<span class="nocode"><a name="4053">4053: </a></span>	// will end up being a Singleton set
<span class="nocode"><a name="4054">4054: </a></span>	LinkedHashSet maximumCostTests = new LinkedHashSet();
<span class="nocode"><a name="4055">4055: </a></span>
<span class="nocode"><a name="4056">4056: </a></span>	// the initial cost of the maximum cost test case
<span class="nocode"><a name="4057">4057: </a></span>	double maxTestCost = 0.0;
<span class="nocode"><a name="4058">4058: </a></span>
<span class="nocode"><a name="4059">4059: </a></span>	// extract an iterator of all of the test subsets
<span class="nocode"><a name="4060">4060: </a></span>	Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="4061">4061: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="4062">4062: </a></span>	    {
<span class="nocode"><a name="4063">4063: </a></span>
<span class="nocode"><a name="4064">4064: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4065">4065: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="4066">4066: </a></span>
<span class="nocode"><a name="4067">4067: </a></span>		SingleTest currentTest = 
<span class="nocode"><a name="4068">4068: </a></span>		    currentSubset.getTest();
<span class="nocode"><a name="4069">4069: </a></span>
<span class="nocode"><a name="4070">4070: </a></span>		double currentTestCost = currentTest.getCost();
<span class="nocode"><a name="4071">4071: </a></span>
<span class="nocode"><a name="4072">4072: </a></span>		// we found a test case that covers more than the 
<span class="nocode"><a name="4073">4073: </a></span>		// one(s) that we found previously
<span class="nocode"><a name="4074">4074: </a></span>		if( currentTestCost &gt; maxTestCost )
<span class="nocode"><a name="4075">4075: </a></span>		    {
<span class="nocode"><a name="4076">4076: </a></span>
<span class="nocode"><a name="4077">4077: </a></span>			// clear out the set of max covering tests
<span class="nocode"><a name="4078">4078: </a></span>			maximumCostTests.clear();
<span class="nocode"><a name="4079">4079: </a></span>
<span class="nocode"><a name="4080">4080: </a></span>			// add in this new test case to the set
<span class="nocode"><a name="4081">4081: </a></span>			// of maximum covering tests
<span class="nocode"><a name="4082">4082: </a></span>			maximumCostTests.add(currentSubset);
<span class="nocode"><a name="4083">4083: </a></span>
<span class="nocode"><a name="4084">4084: </a></span>			// assign the new maximum covering number
<span class="nocode"><a name="4085">4085: </a></span>			maxTestCost = currentTestCost;
<span class="nocode"><a name="4086">4086: </a></span>
<span class="nocode"><a name="4087">4087: </a></span>		    }
<span class="nocode"><a name="4088">4088: </a></span>
<span class="nocode"><a name="4089">4089: </a></span>		// there is another test case that covers the same
<span class="nocode"><a name="4090">4090: </a></span>		// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4091">4091: </a></span>		// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4092">4092: </a></span>		// we have to add it to the listing
<span class="nocode"><a name="4093">4093: </a></span>		else if( currentTestCost == maxTestCost )
<span class="nocode"><a name="4094">4094: </a></span>		    {
<span class="nocode"><a name="4095">4095: </a></span>
<span class="nocode"><a name="4096">4096: </a></span>			maximumCostTests.add(currentSubset);
<span class="nocode"><a name="4097">4097: </a></span>			
<span class="nocode"><a name="4098">4098: </a></span>		    }
<span class="nocode"><a name="4099">4099: </a></span>
<span class="nocode"><a name="4100">4100: </a></span>
<span class="nocode"><a name="4101">4101: </a></span>	    }
<span class="nocode"><a name="4102">4102: </a></span>
<span class="nocode"><a name="4103">4103: </a></span>	return maximumCostTests;
<span class="nocode"><a name="4104">4104: </a></span>
<span class="nocode"><a name="4105">4105: </a></span>    }
<span class="nocode"><a name="4106">4106: </a></span>
<span class="nocode"><a name="4107">4107: </a></span>    /**
<span class="nocode"><a name="4108">4108: </a></span>     *  Finds the minimum cost test cases.  
<span class="nocode"><a name="4109">4109: </a></span>     *  
<span class="nocode"><a name="4110">4110: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4111">4111: </a></span>     */
<span class="nocode"><a name="4112">4112: </a></span>    public Set findMinimumCostTests()
<span class="nocode"><a name="4113">4113: </a></span>    {
<span class="nocode"><a name="4114">4114: </a></span>
<span class="nocode"><a name="4115">4115: </a></span>	// this is the listing of all of the tests that have maximum
<span class="nocode"><a name="4116">4116: </a></span>	// cost within the test suite; most likely for most tests this
<span class="nocode"><a name="4117">4117: </a></span>	// will end up being a Singleton set
<span class="nocode"><a name="4118">4118: </a></span>	LinkedHashSet minimumCostTests = new LinkedHashSet();
<span class="nocode"><a name="4119">4119: </a></span>
<span class="nocode"><a name="4120">4120: </a></span>	// the initial cost of the maximum cost test case
<span class="nocode"><a name="4121">4121: </a></span>	double minTestCost = Double.MAX_VALUE;
<span class="nocode"><a name="4122">4122: </a></span>
<span class="nocode"><a name="4123">4123: </a></span>	// extract an iterator of all of the test subsets
<span class="nocode"><a name="4124">4124: </a></span>	Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="4125">4125: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="4126">4126: </a></span>	    {
<span class="nocode"><a name="4127">4127: </a></span>
<span class="nocode"><a name="4128">4128: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4129">4129: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="4130">4130: </a></span>
<span class="nocode"><a name="4131">4131: </a></span>		SingleTest currentTest = 
<span class="nocode"><a name="4132">4132: </a></span>		    currentSubset.getTest();
<span class="nocode"><a name="4133">4133: </a></span>
<span class="nocode"><a name="4134">4134: </a></span>		double currentTestCost = currentTest.getCost();
<span class="nocode"><a name="4135">4135: </a></span>
<span class="nocode"><a name="4136">4136: </a></span>		// we found a test case that covers more than the 
<span class="nocode"><a name="4137">4137: </a></span>		// one(s) that we found previously
<span class="nocode"><a name="4138">4138: </a></span>		if( currentTestCost &lt; minTestCost )
<span class="nocode"><a name="4139">4139: </a></span>		    {
<span class="nocode"><a name="4140">4140: </a></span>
<span class="nocode"><a name="4141">4141: </a></span>			// clear out the set of max covering tests
<span class="nocode"><a name="4142">4142: </a></span>			minimumCostTests.clear();
<span class="nocode"><a name="4143">4143: </a></span>
<span class="nocode"><a name="4144">4144: </a></span>			// add in this new test case to the set
<span class="nocode"><a name="4145">4145: </a></span>			// of maximum covering tests
<span class="nocode"><a name="4146">4146: </a></span>			minimumCostTests.add(currentSubset);
<span class="nocode"><a name="4147">4147: </a></span>
<span class="nocode"><a name="4148">4148: </a></span>			// assign the new maximum covering number
<span class="nocode"><a name="4149">4149: </a></span>			minTestCost = currentTestCost;
<span class="nocode"><a name="4150">4150: </a></span>
<span class="nocode"><a name="4151">4151: </a></span>		    }
<span class="nocode"><a name="4152">4152: </a></span>
<span class="nocode"><a name="4153">4153: </a></span>		// there is another test case that covers the same
<span class="nocode"><a name="4154">4154: </a></span>		// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4155">4155: </a></span>		// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4156">4156: </a></span>		// we have to add it to the listing
<span class="nocode"><a name="4157">4157: </a></span>		else if( currentTestCost == minTestCost )
<span class="nocode"><a name="4158">4158: </a></span>		    {
<span class="nocode"><a name="4159">4159: </a></span>
<span class="nocode"><a name="4160">4160: </a></span>			minimumCostTests.add(currentSubset);
<span class="nocode"><a name="4161">4161: </a></span>			
<span class="nocode"><a name="4162">4162: </a></span>		    }
<span class="nocode"><a name="4163">4163: </a></span>
<span class="nocode"><a name="4164">4164: </a></span>	    }
<span class="nocode"><a name="4165">4165: </a></span>
<span class="nocode"><a name="4166">4166: </a></span>	return minimumCostTests;
<span class="nocode"><a name="4167">4167: </a></span>
<span class="nocode"><a name="4168">4168: </a></span>    }
<span class="nocode"><a name="4169">4169: </a></span>
<span class="nocode"><a name="4170">4170: </a></span>    /**
<span class="nocode"><a name="4171">4171: </a></span>     *  Finds the maximum redundancy factor test cases.  This
<span class="nocode"><a name="4172">4172: </a></span>     *  indicates that these tests are likely to be included in the
<span class="nocode"><a name="4173">4173: </a></span>     *  final reduced test suite because they cover lots of
<span class="nocode"><a name="4174">4174: </a></span>     *  requirements that are covered by the other test cases.
<span class="nocode"><a name="4175">4175: </a></span>     *  
<span class="nocode"><a name="4176">4176: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4177">4177: </a></span>     */
<span class="nocode"><a name="4178">4178: </a></span>    public Set findMaximumRedundancyFactorTests()
<span class="nocode"><a name="4179">4179: </a></span>    {
<span class="nocode"><a name="4180">4180: </a></span>	
<span class="nocode"><a name="4181">4181: </a></span>	// this is the listing of all of the tests that have maximum
<span class="nocode"><a name="4182">4182: </a></span>	// cost within the test suite; most likely for most tests this
<span class="nocode"><a name="4183">4183: </a></span>	// will end up being a Singleton set
<span class="nocode"><a name="4184">4184: </a></span>	LinkedHashSet maxRedundancyTests = new LinkedHashSet();
<span class="nocode"><a name="4185">4185: </a></span>
<span class="nocode"><a name="4186">4186: </a></span>	// the initial cost of the maximum cost test case
<span class="nocode"><a name="4187">4187: </a></span>	double maxTestRedundancy = 0.0;
<span class="nocode"><a name="4188">4188: </a></span>
<span class="nocode"><a name="4189">4189: </a></span>	// note that we are still keeping track of the tests and not
<span class="nocode"><a name="4190">4190: </a></span>	// the requirements themselves; this means we look at all of
<span class="nocode"><a name="4191">4191: </a></span>	// the individual redundancy factors for all of the
<span class="nocode"><a name="4192">4192: </a></span>	// requirements for a given test and use this to determine the
<span class="nocode"><a name="4193">4193: </a></span>	// max for the entire test suite
<span class="nocode"><a name="4194">4194: </a></span>
<span class="nocode"><a name="4195">4195: </a></span>	// extract an iterator of all of the test subsets
<span class="nocode"><a name="4196">4196: </a></span>	Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="4197">4197: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="4198">4198: </a></span>	    {
<span class="nocode"><a name="4199">4199: </a></span>
<span class="nocode"><a name="4200">4200: </a></span>		// this is the current SingleTestSubset
<span class="nocode"><a name="4201">4201: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4202">4202: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="4203">4203: </a></span>		
<span class="nocode"><a name="4204">4204: </a></span>		// extract an iterator of the requirement subsets
<span class="nocode"><a name="4205">4205: </a></span>		// so that we can measure their individual costs
<span class="nocode"><a name="4206">4206: </a></span>		Iterator requirementSubsetIterator = 
<span class="nocode"><a name="4207">4207: </a></span>		    currentSubset.getRequirementSubsetSet().iterator();
<span class="nocode"><a name="4208">4208: </a></span>
<span class="nocode"><a name="4209">4209: </a></span>		// go through all of the individual requirement
<span class="nocode"><a name="4210">4210: </a></span>		// subsets ; each one of these has an already computed
<span class="nocode"><a name="4211">4211: </a></span>		// redundancy factor
<span class="nocode"><a name="4212">4212: </a></span>		while( requirementSubsetIterator.hasNext() )
<span class="nocode"><a name="4213">4213: </a></span>		    {
<span class="nocode"><a name="4214">4214: </a></span>
<span class="nocode"><a name="4215">4215: </a></span>			// extract the current requirement
<span class="nocode"><a name="4216">4216: </a></span>			RequirementSubset currentRequirement = 
<span class="nocode"><a name="4217">4217: </a></span>			    (RequirementSubset) 
<span class="nocode"><a name="4218">4218: </a></span>			    requirementSubsetIterator.next();
<span class="nocode"><a name="4219">4219: </a></span>
<span class="nocode"><a name="4220">4220: </a></span>			// the redundancy factor for this requirement
<span class="nocode"><a name="4221">4221: </a></span>			int currentRedundancyFactor = 
<span class="nocode"><a name="4222">4222: </a></span>			    currentRequirement.getRedundancyFactor();
<span class="nocode"><a name="4223">4223: </a></span>
<span class="nocode"><a name="4224">4224: </a></span>			// we found a test case that covers more than the 
<span class="nocode"><a name="4225">4225: </a></span>			// one(s) that we found previously
<span class="nocode"><a name="4226">4226: </a></span>			if( currentRedundancyFactor &gt; maxTestRedundancy )
<span class="nocode"><a name="4227">4227: </a></span>			    {
<span class="nocode"><a name="4228">4228: </a></span>
<span class="nocode"><a name="4229">4229: </a></span>				// clear out the set of max RF tests
<span class="nocode"><a name="4230">4230: </a></span>				maxRedundancyTests.clear();
<span class="nocode"><a name="4231">4231: </a></span>
<span class="nocode"><a name="4232">4232: </a></span>				// add in this new test case to the
<span class="nocode"><a name="4233">4233: </a></span>				// set of maximum RF tests (might be
<span class="nocode"><a name="4234">4234: </a></span>				// adding multiple times, but this is
<span class="nocode"><a name="4235">4235: </a></span>				// okay because we are treating it as
<span class="nocode"><a name="4236">4236: </a></span>				// a set)
<span class="nocode"><a name="4237">4237: </a></span>				maxRedundancyTests.add(currentSubset);
<span class="nocode"><a name="4238">4238: </a></span>
<span class="nocode"><a name="4239">4239: </a></span>				// assign the new maximum covering
<span class="nocode"><a name="4240">4240: </a></span>				// number
<span class="nocode"><a name="4241">4241: </a></span>				maxTestRedundancy = currentRedundancyFactor;
<span class="nocode"><a name="4242">4242: </a></span>
<span class="nocode"><a name="4243">4243: </a></span>			    }
<span class="nocode"><a name="4244">4244: </a></span>
<span class="nocode"><a name="4245">4245: </a></span>			// there is another test case that covers the same
<span class="nocode"><a name="4246">4246: </a></span>			// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4247">4247: </a></span>			// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4248">4248: </a></span>			// we have to add it to the listing
<span class="nocode"><a name="4249">4249: </a></span>			else if( currentRedundancyFactor == maxTestRedundancy )
<span class="nocode"><a name="4250">4250: </a></span>			    {
<span class="nocode"><a name="4251">4251: </a></span>				
<span class="nocode"><a name="4252">4252: </a></span>				maxRedundancyTests.add(currentSubset);
<span class="nocode"><a name="4253">4253: </a></span>				
<span class="nocode"><a name="4254">4254: </a></span>			    }
<span class="nocode"><a name="4255">4255: </a></span>
<span class="nocode"><a name="4256">4256: </a></span>		    }
<span class="nocode"><a name="4257">4257: </a></span>
<span class="nocode"><a name="4258">4258: </a></span>	    }
<span class="nocode"><a name="4259">4259: </a></span>
<span class="nocode"><a name="4260">4260: </a></span>	return maxRedundancyTests;
<span class="nocode"><a name="4261">4261: </a></span>
<span class="nocode"><a name="4262">4262: </a></span>    }
<span class="nocode"><a name="4263">4263: </a></span>
<span class="nocode"><a name="4264">4264: </a></span>    /**
<span class="nocode"><a name="4265">4265: </a></span>     *  Finds the maximum AVERAGE redundancy factor test cases.  This
<span class="nocode"><a name="4266">4266: </a></span>     *  indicates that these tests are likely to be included in the
<span class="nocode"><a name="4267">4267: </a></span>     *  final reduced test suite because they cover lots of
<span class="nocode"><a name="4268">4268: </a></span>     *  requirements that are covered by the other test cases.
<span class="nocode"><a name="4269">4269: </a></span>     *  
<span class="nocode"><a name="4270">4270: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4271">4271: </a></span>     */
<span class="nocode"><a name="4272">4272: </a></span>    public Set findMaximumAverageRedundancyFactorTests()
<span class="nocode"><a name="4273">4273: </a></span>    {
<span class="nocode"><a name="4274">4274: </a></span>	
<span class="nocode"><a name="4275">4275: </a></span>	// this is the listing of all of the tests that have maximum
<span class="nocode"><a name="4276">4276: </a></span>	// cost within the test suite; most likely for most tests this
<span class="nocode"><a name="4277">4277: </a></span>	// will end up being a Singleton set
<span class="nocode"><a name="4278">4278: </a></span>	LinkedHashSet maxRedundancyTests = new LinkedHashSet();
<span class="nocode"><a name="4279">4279: </a></span>
<span class="nocode"><a name="4280">4280: </a></span>	// the initial cost of the maximum cost test case
<span class="nocode"><a name="4281">4281: </a></span>	double maxTestRedundancy = 0.0;
<span class="nocode"><a name="4282">4282: </a></span>
<span class="nocode"><a name="4283">4283: </a></span>	// note that we are still keeping track of the tests and not
<span class="nocode"><a name="4284">4284: </a></span>	// the requirements themselves; this means we look at all of
<span class="nocode"><a name="4285">4285: </a></span>	// the individual redundancy factors for all of the
<span class="nocode"><a name="4286">4286: </a></span>	// requirements for a given test and use this to determine the
<span class="nocode"><a name="4287">4287: </a></span>	// max for the entire test suite
<span class="nocode"><a name="4288">4288: </a></span>
<span class="nocode"><a name="4289">4289: </a></span>	// extract an iterator of all of the test subsets
<span class="nocode"><a name="4290">4290: </a></span>	Iterator testSubsetsIterator = testSubsets.iterator();
<span class="nocode"><a name="4291">4291: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="4292">4292: </a></span>	    {
<span class="nocode"><a name="4293">4293: </a></span>
<span class="nocode"><a name="4294">4294: </a></span>		// this is the current SingleTestSubset
<span class="nocode"><a name="4295">4295: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4296">4296: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="4297">4297: </a></span>		
<span class="nocode"><a name="4298">4298: </a></span>		// extract an iterator of the requirement subsets
<span class="nocode"><a name="4299">4299: </a></span>		// so that we can measure their individual costs
<span class="nocode"><a name="4300">4300: </a></span>		Iterator requirementSubsetIterator = 
<span class="nocode"><a name="4301">4301: </a></span>		    currentSubset.getRequirementSubsetSet().iterator();
<span class="nocode"><a name="4302">4302: </a></span>
<span class="nocode"><a name="4303">4303: </a></span>		// the total number of requirements for this SingleTest
<span class="nocode"><a name="4304">4304: </a></span>		int totalNumberRequirements = 0;
<span class="nocode"><a name="4305">4305: </a></span>
<span class="nocode"><a name="4306">4306: </a></span>		// the sum of all of the redundancy factors for this 
<span class="nocode"><a name="4307">4307: </a></span>		// listing of requirements
<span class="nocode"><a name="4308">4308: </a></span>		int redundancyFactorSum = 0;
<span class="nocode"><a name="4309">4309: </a></span>
<span class="nocode"><a name="4310">4310: </a></span>		// go through all of the individual requirement
<span class="nocode"><a name="4311">4311: </a></span>		// subsets ; each one of these has an already computed
<span class="nocode"><a name="4312">4312: </a></span>		// redundancy factor
<span class="nocode"><a name="4313">4313: </a></span>		while( requirementSubsetIterator.hasNext() )
<span class="nocode"><a name="4314">4314: </a></span>		    {
<span class="nocode"><a name="4315">4315: </a></span>
<span class="nocode"><a name="4316">4316: </a></span>			// extract the current requirement
<span class="nocode"><a name="4317">4317: </a></span>			RequirementSubset currentRequirement = 
<span class="nocode"><a name="4318">4318: </a></span>			    (RequirementSubset) 
<span class="nocode"><a name="4319">4319: </a></span>			    requirementSubsetIterator.next();
<span class="nocode"><a name="4320">4320: </a></span>
<span class="nocode"><a name="4321">4321: </a></span>			// the redundancy factor for this requirement
<span class="nocode"><a name="4322">4322: </a></span>			int currentRedundancyFactor = 
<span class="nocode"><a name="4323">4323: </a></span>			    currentRequirement.getRedundancyFactor();
<span class="nocode"><a name="4324">4324: </a></span>
<span class="nocode"><a name="4325">4325: </a></span>			redundancyFactorSum = redundancyFactorSum +
<span class="nocode"><a name="4326">4326: </a></span>			    currentRedundancyFactor;
<span class="nocode"><a name="4327">4327: </a></span>
<span class="nocode"><a name="4328">4328: </a></span>			totalNumberRequirements++;
<span class="nocode"><a name="4329">4329: </a></span>		
<span class="nocode"><a name="4330">4330: </a></span>		    }
<span class="nocode"><a name="4331">4331: </a></span>
<span class="nocode"><a name="4332">4332: </a></span>		// this is the average redundancyFactor
<span class="nocode"><a name="4333">4333: </a></span>		double averageRedundancyFactor = 
<span class="nocode"><a name="4334">4334: </a></span>		    ( (double) redundancyFactorSum ) /
<span class="nocode"><a name="4335">4335: </a></span>		    ( (double) totalNumberRequirements );
<span class="nocode"><a name="4336">4336: </a></span>
<span class="nocode"><a name="4337">4337: </a></span>		// we found a test case that covers more than the 
<span class="nocode"><a name="4338">4338: </a></span>		// one(s) that we found previously
<span class="nocode"><a name="4339">4339: </a></span>		if( averageRedundancyFactor &gt; maxTestRedundancy )
<span class="nocode"><a name="4340">4340: </a></span>		    {
<span class="nocode"><a name="4341">4341: </a></span>
<span class="nocode"><a name="4342">4342: </a></span>			// clear out the set of max RF tests
<span class="nocode"><a name="4343">4343: </a></span>			maxRedundancyTests.clear();
<span class="nocode"><a name="4344">4344: </a></span>
<span class="nocode"><a name="4345">4345: </a></span>			// add in this new test case to the set of
<span class="nocode"><a name="4346">4346: </a></span>			// maximum RF tests (might be adding multiple
<span class="nocode"><a name="4347">4347: </a></span>			// times, but this is okay because we are
<span class="nocode"><a name="4348">4348: </a></span>			// treating it as a set)
<span class="nocode"><a name="4349">4349: </a></span>			maxRedundancyTests.add(currentSubset);
<span class="nocode"><a name="4350">4350: </a></span>
<span class="nocode"><a name="4351">4351: </a></span>			// assign the new maximum covering number
<span class="nocode"><a name="4352">4352: </a></span>			maxTestRedundancy = averageRedundancyFactor;
<span class="nocode"><a name="4353">4353: </a></span>
<span class="nocode"><a name="4354">4354: </a></span>		    }
<span class="nocode"><a name="4355">4355: </a></span>
<span class="nocode"><a name="4356">4356: </a></span>		// there is another test case that covers the same
<span class="nocode"><a name="4357">4357: </a></span>		// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4358">4358: </a></span>		// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4359">4359: </a></span>		// we have to add it to the listing
<span class="nocode"><a name="4360">4360: </a></span>		else if( averageRedundancyFactor == maxTestRedundancy )
<span class="nocode"><a name="4361">4361: </a></span>		    {
<span class="nocode"><a name="4362">4362: </a></span>				
<span class="nocode"><a name="4363">4363: </a></span>			maxRedundancyTests.add(currentSubset);
<span class="nocode"><a name="4364">4364: </a></span>			
<span class="nocode"><a name="4365">4365: </a></span>		    }
<span class="nocode"><a name="4366">4366: </a></span>
<span class="nocode"><a name="4367">4367: </a></span>	    }
<span class="nocode"><a name="4368">4368: </a></span>
<span class="nocode"><a name="4369">4369: </a></span>	return maxRedundancyTests;
<span class="nocode"><a name="4370">4370: </a></span>
<span class="nocode"><a name="4371">4371: </a></span>    }
<span class="nocode"><a name="4372">4372: </a></span>
<span class="nocode"><a name="4373">4373: </a></span>    /**
<span class="nocode"><a name="4374">4374: </a></span>     *  Produces a set of the test cases that achieve maximum coverage 
<span class="nocode"><a name="4375">4375: </a></span>     *  of the test requirements.  Intuitively, these are the tests that 
<span class="nocode"><a name="4376">4376: </a></span>     *  are likely to be included in the final reduced test suite as 
<span class="nocode"><a name="4377">4377: </a></span>     *  long as they are not too costly.
<span class="nocode"><a name="4378">4378: </a></span>     *  
<span class="nocode"><a name="4379">4379: </a></span>     *  @author Gregory M. Kapfhammer 9/24/2005
<span class="nocode"><a name="4380">4380: </a></span>     */
<span class="nocode"><a name="4381">4381: </a></span>    public Set findMaximumCoverageTests()
<span class="nocode"><a name="4382">4382: </a></span>    {
<span class="nocode"><a name="4383">4383: </a></span>
<span class="nocode"><a name="4384">4384: </a></span>	LinkedHashSet maximumCoverageTests = new LinkedHashSet();
<span class="nocode"><a name="4385">4385: </a></span>	int maxCoveringNumber = 0;
<span class="nocode"><a name="4386">4386: </a></span>
<span class="nocode"><a name="4387">4387: </a></span>	// extract an iterator of all of the SingleTestSubsets
<span class="nocode"><a name="4388">4388: </a></span>	Iterator singleTestSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="4389">4389: </a></span>
<span class="nocode"><a name="4390">4390: </a></span>	// look through the iterator for the test case that 
<span class="nocode"><a name="4391">4391: </a></span>	// covers the most test requirements
<span class="nocode"><a name="4392">4392: </a></span>	while( singleTestSubsetIterator.hasNext() )
<span class="nocode"><a name="4393">4393: </a></span>	    {
<span class="nocode"><a name="4394">4394: </a></span>
<span class="nocode"><a name="4395">4395: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4396">4396: </a></span>		    (SingleTestSubset) singleTestSubsetIterator.next();
<span class="nocode"><a name="4397">4397: </a></span>
<span class="nocode"><a name="4398">4398: </a></span>		int currentCoveringNumber = 
<span class="nocode"><a name="4399">4399: </a></span>		    currentSubset.getRequirementSubsetSet().size();
<span class="nocode"><a name="4400">4400: </a></span>
<span class="nocode"><a name="4401">4401: </a></span>		// we found a test case that covers more than the 
<span class="nocode"><a name="4402">4402: </a></span>		// one(s) that we found previously
<span class="nocode"><a name="4403">4403: </a></span>		if( currentCoveringNumber &gt; maxCoveringNumber )
<span class="nocode"><a name="4404">4404: </a></span>		    {
<span class="nocode"><a name="4405">4405: </a></span>
<span class="nocode"><a name="4406">4406: </a></span>			// clear out the set of max covering tests
<span class="nocode"><a name="4407">4407: </a></span>			maximumCoverageTests.clear();
<span class="nocode"><a name="4408">4408: </a></span>
<span class="nocode"><a name="4409">4409: </a></span>			// add in this new test case to the set
<span class="nocode"><a name="4410">4410: </a></span>			// of maximum covering tests
<span class="nocode"><a name="4411">4411: </a></span>			maximumCoverageTests.add(currentSubset);
<span class="nocode"><a name="4412">4412: </a></span>
<span class="nocode"><a name="4413">4413: </a></span>			// assign the new maximum covering number
<span class="nocode"><a name="4414">4414: </a></span>			maxCoveringNumber = currentCoveringNumber;
<span class="nocode"><a name="4415">4415: </a></span>
<span class="nocode"><a name="4416">4416: </a></span>		    }
<span class="nocode"><a name="4417">4417: </a></span>
<span class="nocode"><a name="4418">4418: </a></span>		// there is another test case that covers the same
<span class="nocode"><a name="4419">4419: </a></span>		// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4420">4420: </a></span>		// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4421">4421: </a></span>		// we have to add it to the listing
<span class="nocode"><a name="4422">4422: </a></span>		else if( currentCoveringNumber == maxCoveringNumber )
<span class="nocode"><a name="4423">4423: </a></span>		    {
<span class="nocode"><a name="4424">4424: </a></span>
<span class="nocode"><a name="4425">4425: </a></span>			maximumCoverageTests.add(currentSubset);
<span class="nocode"><a name="4426">4426: </a></span>			
<span class="nocode"><a name="4427">4427: </a></span>		    }
<span class="nocode"><a name="4428">4428: </a></span>
<span class="nocode"><a name="4429">4429: </a></span>	    }
<span class="nocode"><a name="4430">4430: </a></span>
<span class="nocode"><a name="4431">4431: </a></span>	return maximumCoverageTests;
<span class="nocode"><a name="4432">4432: </a></span>
<span class="nocode"><a name="4433">4433: </a></span>    }
<span class="nocode"><a name="4434">4434: </a></span>
<span class="nocode"><a name="4435">4435: </a></span>    /**
<span class="nocode"><a name="4436">4436: </a></span>     *  Produces a set of the test cases that achieve minimum coverage
<span class="nocode"><a name="4437">4437: </a></span>     *  of the test requirements.  Intuitively, these are the tests
<span class="nocode"><a name="4438">4438: </a></span>     *  that are not as likely to be included in the final reduced
<span class="nocode"><a name="4439">4439: </a></span>     *  test suite because they do not cover as much.
<span class="nocode"><a name="4440">4440: </a></span>     *  
<span class="nocode"><a name="4441">4441: </a></span>     *  @author Gregory M. Kapfhammer 9/24/2005
<span class="nocode"><a name="4442">4442: </a></span>     */
<span class="nocode"><a name="4443">4443: </a></span>    public Set findMinimumCoverageTests()
<span class="nocode"><a name="4444">4444: </a></span>    {
<span class="nocode"><a name="4445">4445: </a></span>
<span class="nocode"><a name="4446">4446: </a></span>	LinkedHashSet minimumCoverageTests = new LinkedHashSet();
<span class="nocode"><a name="4447">4447: </a></span>	int minCoveringNumber = Integer.MAX_VALUE;
<span class="nocode"><a name="4448">4448: </a></span>
<span class="nocode"><a name="4449">4449: </a></span>	// extract an iterator of all of the SingleTestSubsets
<span class="nocode"><a name="4450">4450: </a></span>	Iterator singleTestSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="4451">4451: </a></span>
<span class="nocode"><a name="4452">4452: </a></span>	// look through the iterator for the test case that 
<span class="nocode"><a name="4453">4453: </a></span>	// covers the most test requirements
<span class="nocode"><a name="4454">4454: </a></span>	while( singleTestSubsetIterator.hasNext() )
<span class="nocode"><a name="4455">4455: </a></span>	    {
<span class="nocode"><a name="4456">4456: </a></span>
<span class="nocode"><a name="4457">4457: </a></span>		SingleTestSubset currentSubset = 
<span class="nocode"><a name="4458">4458: </a></span>		    (SingleTestSubset) singleTestSubsetIterator.next();
<span class="nocode"><a name="4459">4459: </a></span>
<span class="nocode"><a name="4460">4460: </a></span>		int currentCoveringNumber = 
<span class="nocode"><a name="4461">4461: </a></span>		    currentSubset.getRequirementSubsetSet().size();
<span class="nocode"><a name="4462">4462: </a></span>
<span class="nocode"><a name="4463">4463: </a></span>		// we found a test case that covers more than the 
<span class="nocode"><a name="4464">4464: </a></span>		// one(s) that we found previously
<span class="nocode"><a name="4465">4465: </a></span>		if( currentCoveringNumber &lt; minCoveringNumber )
<span class="nocode"><a name="4466">4466: </a></span>		    {
<span class="nocode"><a name="4467">4467: </a></span>
<span class="nocode"><a name="4468">4468: </a></span>			// clear out the set of max covering tests
<span class="nocode"><a name="4469">4469: </a></span>			minimumCoverageTests.clear();
<span class="nocode"><a name="4470">4470: </a></span>
<span class="nocode"><a name="4471">4471: </a></span>			// add in this new test case to the set
<span class="nocode"><a name="4472">4472: </a></span>			// of maximum covering tests
<span class="nocode"><a name="4473">4473: </a></span>			minimumCoverageTests.add(currentSubset);
<span class="nocode"><a name="4474">4474: </a></span>
<span class="nocode"><a name="4475">4475: </a></span>			// assign the new maximum covering number
<span class="nocode"><a name="4476">4476: </a></span>			minCoveringNumber = currentCoveringNumber;
<span class="nocode"><a name="4477">4477: </a></span>
<span class="nocode"><a name="4478">4478: </a></span>		    }
<span class="nocode"><a name="4479">4479: </a></span>
<span class="nocode"><a name="4480">4480: </a></span>		// there is another test case that covers the same
<span class="nocode"><a name="4481">4481: </a></span>		// NUMBER of test requirements (not checking here to 
<span class="nocode"><a name="4482">4482: </a></span>		// actually see what the requirements ARE) and thus
<span class="nocode"><a name="4483">4483: </a></span>		// we have to add it to the listing
<span class="nocode"><a name="4484">4484: </a></span>		else if( currentCoveringNumber == minCoveringNumber )
<span class="nocode"><a name="4485">4485: </a></span>		    {
<span class="nocode"><a name="4486">4486: </a></span>
<span class="nocode"><a name="4487">4487: </a></span>			minimumCoverageTests.add(currentSubset);
<span class="nocode"><a name="4488">4488: </a></span>			
<span class="nocode"><a name="4489">4489: </a></span>		    }
<span class="nocode"><a name="4490">4490: </a></span>
<span class="nocode"><a name="4491">4491: </a></span>	    }
<span class="nocode"><a name="4492">4492: </a></span>
<span class="nocode"><a name="4493">4493: </a></span>	return minimumCoverageTests;
<span class="nocode"><a name="4494">4494: </a></span>
<span class="nocode"><a name="4495">4495: </a></span>    }
<span class="nocode"><a name="4496">4496: </a></span>
<span class="nocode"><a name="4497">4497: </a></span>    /**
<span class="nocode"><a name="4498">4498: </a></span>     *  Finds the test cases that have high redundancy and low cost.
<span class="nocode"><a name="4499">4499: </a></span>     *  
<span class="nocode"><a name="4500">4500: </a></span>     *  Note that selection to be included in the set of tests that 
<span class="nocode"><a name="4501">4501: </a></span>     *  match the &quot;high redundancy and low cost&quot; description include:
<span class="nocode"><a name="4502">4502: </a></span>     *
<span class="nocode"><a name="4503">4503: </a></span>     *  1. test cost &lt;= mininum cost + (minCostFactor * minimum cost)
<span class="nocode"><a name="4504">4504: </a></span>     *
<span class="nocode"><a name="4505">4505: </a></span>     *  2. test redundancy factor &gt;= maximum redundancy * percent redundancy
<span class="nocode"><a name="4506">4506: </a></span>     *  
<span class="nocode"><a name="4507">4507: </a></span>     *  Finally note that the minCostFactor in equation (1) is
<span class="nocode"><a name="4508">4508: </a></span>     *  included in the list of the paramters as percentMinCost.  This
<span class="nocode"><a name="4509">4509: </a></span>     *  is a slight misnomer because it is not really a percent; it
<span class="nocode"><a name="4510">4510: </a></span>     *  can be greater than one (and potentially less than 0?).  See
<span class="nocode"><a name="4511">4511: </a></span>     *  the test cases for some examples.
<span class="nocode"><a name="4512">4512: </a></span>     *
<span class="nocode"><a name="4513">4513: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4514">4514: </a></span>     */
<span class="nocode"><a name="4515">4515: </a></span>    public Set findHighRedundancyLowCostTests(double maxRedundancyFactor,
<span class="nocode"><a name="4516">4516: </a></span>					      double percentMaxRedundancy,
<span class="nocode"><a name="4517">4517: </a></span>					      double minCost,
<span class="nocode"><a name="4518">4518: </a></span>					      double percentMinCost)
<span class="nocode"><a name="4519">4519: </a></span>    {
<span class="nocode"><a name="4520">4520: </a></span>
<span class="nocode"><a name="4521">4521: </a></span>	// this is the listing of the tests that have high redundancy
<span class="nocode"><a name="4522">4522: </a></span>	// and low cost according to the established criterion
<span class="nocode"><a name="4523">4523: </a></span>	LinkedHashSet maxRedundancyMinCost = new LinkedHashSet();
<span class="nocode"><a name="4524">4524: </a></span>
<span class="nocode"><a name="4525">4525: </a></span>	// extract an iterator of all of the SingleTestSubsets
<span class="nocode"><a name="4526">4526: </a></span>	Iterator singleTestSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="4527">4527: </a></span>
<span class="nocode"><a name="4528">4528: </a></span>	// calculate the threshold values that we must see
<span class="nocode"><a name="4529">4529: </a></span>	
<span class="nocode"><a name="4530">4530: </a></span>	// redundancy threshold sets the bar that a test's redundancy
<span class="nocode"><a name="4531">4531: </a></span>	// factor must be greater than (or equal to) for inclusion
<span class="nocode"><a name="4532">4532: </a></span>	double redundancyIncludeThreshold = 
<span class="nocode"><a name="4533">4533: </a></span>	    percentMaxRedundancy * maxRedundancyFactor;
<span class="nocode"><a name="4534">4534: </a></span>
<span class="nocode"><a name="4535">4535: </a></span>// 	System.out.println(&quot;redundancyInclude = &quot; + 
<span class="nocode"><a name="4536">4536: </a></span>// 			   redundancyIncludeThreshold);
<span class="nocode"><a name="4537">4537: </a></span>
<span class="nocode"><a name="4538">4538: </a></span>	// cost threshold sets the bar that a test's cost must be less
<span class="nocode"><a name="4539">4539: </a></span>	// than (or equal to) for inclusion
<span class="nocode"><a name="4540">4540: </a></span>	double costIncludeThreshold = 
<span class="nocode"><a name="4541">4541: </a></span>	    minCost + (percentMinCost * minCost);
<span class="nocode"><a name="4542">4542: </a></span>
<span class="nocode"><a name="4543">4543: </a></span>// 	System.out.println(&quot;costIncludeThreshold = &quot; +
<span class="nocode"><a name="4544">4544: </a></span>// 			   costIncludeThreshold);
<span class="nocode"><a name="4545">4545: </a></span>
<span class="nocode"><a name="4546">4546: </a></span>	// look through the iterator for the test case that 
<span class="nocode"><a name="4547">4547: </a></span>	// covers the most test requirements
<span class="nocode"><a name="4548">4548: </a></span>	while( singleTestSubsetIterator.hasNext() )
<span class="nocode"><a name="4549">4549: </a></span>	    {
<span class="nocode"><a name="4550">4550: </a></span>
<span class="nocode"><a name="4551">4551: </a></span>		// extract the current SingleTestSubset
<span class="nocode"><a name="4552">4552: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="4553">4553: </a></span>		    (SingleTestSubset) singleTestSubsetIterator.next();
<span class="nocode"><a name="4554">4554: </a></span>
<span class="nocode"><a name="4555">4555: </a></span>		// get the current test out of the SingleTestSubset
<span class="nocode"><a name="4556">4556: </a></span>		SingleTest currentTest = currentTestSubset.getTest();
<span class="nocode"><a name="4557">4557: </a></span>
<span class="nocode"><a name="4558">4558: </a></span>		// this current test has a cost that is under the 
<span class="nocode"><a name="4559">4559: </a></span>		// threshold and thus we must check to see about its
<span class="nocode"><a name="4560">4560: </a></span>		// redundancy factor (this is probably a good screen)
<span class="nocode"><a name="4561">4561: </a></span>		if( currentTest.getCost() &lt;= costIncludeThreshold )
<span class="nocode"><a name="4562">4562: </a></span>		    {
<span class="nocode"><a name="4563">4563: </a></span>
<span class="nocode"><a name="4564">4564: </a></span>			// look through the different redundancy
<span class="nocode"><a name="4565">4565: </a></span>			// factors for this SingleTest and find 
<span class="nocode"><a name="4566">4566: </a></span>			// the maximum, ***average***, what?
<span class="nocode"><a name="4567">4567: </a></span>			Iterator testSubsets = 
<span class="nocode"><a name="4568">4568: </a></span>			    currentTestSubset.
<span class="nocode"><a name="4569">4569: </a></span>			    getRequirementSubsetSet().
<span class="nocode"><a name="4570">4570: </a></span>			    iterator();
<span class="nocode"><a name="4571">4571: </a></span>			
<span class="nocode"><a name="4572">4572: </a></span>			// note that our current implementation looks
<span class="nocode"><a name="4573">4573: </a></span>			// at the average redundancy factor for a test
<span class="nocode"><a name="4574">4574: </a></span>			// case; this requires that we look at them
<span class="nocode"><a name="4575">4575: </a></span>			// all and then compute the average
<span class="nocode"><a name="4576">4576: </a></span>
<span class="nocode"><a name="4577">4577: </a></span>			// it might be desirable to refactor this code
<span class="nocode"><a name="4578">4578: </a></span>			// so that we take it into a separate method
<span class="nocode"><a name="4579">4579: </a></span>			// that is just responsible for computing the
<span class="nocode"><a name="4580">4580: </a></span>			// average redundancy factor
<span class="nocode"><a name="4581">4581: </a></span>
<span class="nocode"><a name="4582">4582: </a></span>			// keep running total of the sum of the
<span class="nocode"><a name="4583">4583: </a></span>			// redundancy factor and the total number of
<span class="nocode"><a name="4584">4584: </a></span>			// requirements that have already been
<span class="nocode"><a name="4585">4585: </a></span>			// analyzed
<span class="nocode"><a name="4586">4586: </a></span>			double sumRedundancyFactor = 0.0;	       	
<span class="nocode"><a name="4587">4587: </a></span>			int totalNumberRequirements = 0;
<span class="nocode"><a name="4588">4588: </a></span>
<span class="nocode"><a name="4589">4589: </a></span>			// go through all of the test subsets for each
<span class="nocode"><a name="4590">4590: </a></span>			// of the requirements and extract the already
<span class="nocode"><a name="4591">4591: </a></span>			// calculated redundancy factor
<span class="nocode"><a name="4592">4592: </a></span>			while( testSubsets.hasNext() )
<span class="nocode"><a name="4593">4593: </a></span>			    {
<span class="nocode"><a name="4594">4594: </a></span>
<span class="nocode"><a name="4595">4595: </a></span>				// this is the current requirement
<span class="nocode"><a name="4596">4596: </a></span>				RequirementSubset currentRequirementSubset = 
<span class="nocode"><a name="4597">4597: </a></span>				    (RequirementSubset) testSubsets.next();
<span class="nocode"><a name="4598">4598: </a></span>
<span class="nocode"><a name="4599">4599: </a></span>				// add in this redundancy factor
<span class="nocode"><a name="4600">4600: </a></span>				// to the running sum and increment
<span class="nocode"><a name="4601">4601: </a></span>				// the counter that keeps track of 
<span class="nocode"><a name="4602">4602: </a></span>				// how many requirements we have analyzed
<span class="nocode"><a name="4603">4603: </a></span>				// so far
<span class="nocode"><a name="4604">4604: </a></span>				sumRedundancyFactor = 
<span class="nocode"><a name="4605">4605: </a></span>				    sumRedundancyFactor + 
<span class="nocode"><a name="4606">4606: </a></span>				    currentRequirementSubset.
<span class="nocode"><a name="4607">4607: </a></span>				    getRedundancyFactor();
<span class="nocode"><a name="4608">4608: </a></span>				totalNumberRequirements++;
<span class="nocode"><a name="4609">4609: </a></span>
<span class="nocode"><a name="4610">4610: </a></span>			    }
<span class="nocode"><a name="4611">4611: </a></span>			
<span class="nocode"><a name="4612">4612: </a></span>			// calculate the average redundancy factor
<span class="nocode"><a name="4613">4613: </a></span>			// (note that we want this to be a double)
<span class="nocode"><a name="4614">4614: </a></span>			double averageRedundancyFactor = 
<span class="nocode"><a name="4615">4615: </a></span>			    ( (double) sumRedundancyFactor ) /
<span class="nocode"><a name="4616">4616: </a></span>			    ( (double) totalNumberRequirements );
<span class="nocode"><a name="4617">4617: </a></span>
<span class="nocode"><a name="4618">4618: </a></span>			// we have found a test with redundancy that has
<span class="nocode"><a name="4619">4619: </a></span>			// a greater redundancy factor than the threshold
<span class="nocode"><a name="4620">4620: </a></span>			// since we already know that its cost is under
<span class="nocode"><a name="4621">4621: </a></span>			// the threshold, we should go ahead and add it 
<span class="nocode"><a name="4622">4622: </a></span>			// to the listing of &quot;good&quot; test cases
<span class="nocode"><a name="4623">4623: </a></span>			if( averageRedundancyFactor &gt;= 
<span class="nocode"><a name="4624">4624: </a></span>			    redundancyIncludeThreshold )
<span class="nocode"><a name="4625">4625: </a></span>			    {
<span class="nocode"><a name="4626">4626: </a></span>
<span class="nocode"><a name="4627">4627: </a></span>				maxRedundancyMinCost.
<span class="nocode"><a name="4628">4628: </a></span>				    add(currentTestSubset);
<span class="nocode"><a name="4629">4629: </a></span>
<span class="nocode"><a name="4630">4630: </a></span>			    }
<span class="nocode"><a name="4631">4631: </a></span>
<span class="nocode"><a name="4632">4632: </a></span>		    }
<span class="nocode"><a name="4633">4633: </a></span>
<span class="nocode"><a name="4634">4634: </a></span>	    }
<span class="nocode"><a name="4635">4635: </a></span>
<span class="nocode"><a name="4636">4636: </a></span>	return maxRedundancyMinCost;
<span class="nocode"><a name="4637">4637: </a></span>
<span class="nocode"><a name="4638">4638: </a></span>    }
<span class="nocode"><a name="4639">4639: </a></span>
<span class="nocode"><a name="4640">4640: </a></span>    /**
<span class="nocode"><a name="4641">4641: </a></span>     *  Finds the test cases that have high coverage and low cost.
<span class="nocode"><a name="4642">4642: </a></span>     *  
<span class="nocode"><a name="4643">4643: </a></span>     *  Note that selection to be included in the set of tests that 
<span class="nocode"><a name="4644">4644: </a></span>     *  match the &quot;high redundancy and low cost&quot; description include:
<span class="nocode"><a name="4645">4645: </a></span>     *
<span class="nocode"><a name="4646">4646: </a></span>     *  1. test cost &lt;= mininum cost + (minCostFactor * minimum cost)
<span class="nocode"><a name="4647">4647: </a></span>     *
<span class="nocode"><a name="4648">4648: </a></span>     *  2. test coverage &gt;= maximum coverage * percent maximum coverage
<span class="nocode"><a name="4649">4649: </a></span>     *
<span class="nocode"><a name="4650">4650: </a></span>     *  Note that the term percentMinCost is also a misnomer in this
<span class="nocode"><a name="4651">4651: </a></span>     *  paramter listing because it is not a percentage per se.  See
<span class="nocode"><a name="4652">4652: </a></span>     *  the test cases for an example of what this value can really
<span class="nocode"><a name="4653">4653: </a></span>     *  be.
<span class="nocode"><a name="4654">4654: </a></span>     *  
<span class="nocode"><a name="4655">4655: </a></span>     *  @author Gregory M. Kapfhammer 10/12/2005
<span class="nocode"><a name="4656">4656: </a></span>     */
<span class="nocode"><a name="4657">4657: </a></span>    public Set findHighCoverageLowCostTests(double maxCoverage,
<span class="nocode"><a name="4658">4658: </a></span>					    double percentMaxCoverage,
<span class="nocode"><a name="4659">4659: </a></span>					    double minCost,
<span class="nocode"><a name="4660">4660: </a></span>					    double percentMinCost)
<span class="nocode"><a name="4661">4661: </a></span>    {
<span class="nocode"><a name="4662">4662: </a></span>
<span class="nocode"><a name="4663">4663: </a></span>	// this is the listing of the tests that have high coverage
<span class="nocode"><a name="4664">4664: </a></span>	// and low cost according to the established criterion
<span class="nocode"><a name="4665">4665: </a></span>	LinkedHashSet maxCoverageMinCost = new LinkedHashSet();
<span class="nocode"><a name="4666">4666: </a></span>
<span class="nocode"><a name="4667">4667: </a></span>	// extract an iterator of all of the SingleTestSubsets
<span class="nocode"><a name="4668">4668: </a></span>	Iterator singleTestSubsetIterator = testSubsets.iterator();
<span class="nocode"><a name="4669">4669: </a></span>
<span class="nocode"><a name="4670">4670: </a></span>	// calculate the threshold values that we must see
<span class="nocode"><a name="4671">4671: </a></span>	
<span class="nocode"><a name="4672">4672: </a></span>	// redundancy threshold sets the bar that a test's redundancy
<span class="nocode"><a name="4673">4673: </a></span>	// factor must be greater than (or equal to) for inclusion
<span class="nocode"><a name="4674">4674: </a></span>	double coverageIncludeThreshold = 
<span class="nocode"><a name="4675">4675: </a></span>	    percentMaxCoverage * maxCoverage;
<span class="nocode"><a name="4676">4676: </a></span>
<span class="nocode"><a name="4677">4677: </a></span>// 	System.out.println(&quot;coverageInclude = &quot; + 
<span class="nocode"><a name="4678">4678: </a></span>// 			   coverageIncludeThreshold);
<span class="nocode"><a name="4679">4679: </a></span>
<span class="nocode"><a name="4680">4680: </a></span>	// cost threshold sets the bar that a test's cost must be less
<span class="nocode"><a name="4681">4681: </a></span>	// than (or equal to) for inclusion
<span class="nocode"><a name="4682">4682: </a></span>	double costIncludeThreshold = 
<span class="nocode"><a name="4683">4683: </a></span>	    minCost + (percentMinCost * minCost);
<span class="nocode"><a name="4684">4684: </a></span>
<span class="nocode"><a name="4685">4685: </a></span>// 	System.out.println(&quot;costIncludeThreshold = &quot; +
<span class="nocode"><a name="4686">4686: </a></span>// 			   costIncludeThreshold);
<span class="nocode"><a name="4687">4687: </a></span>
<span class="nocode"><a name="4688">4688: </a></span>	// look through the iterator for the test case that 
<span class="nocode"><a name="4689">4689: </a></span>	// covers the most test requirements
<span class="nocode"><a name="4690">4690: </a></span>	while( singleTestSubsetIterator.hasNext() )
<span class="nocode"><a name="4691">4691: </a></span>	    {
<span class="nocode"><a name="4692">4692: </a></span>
<span class="nocode"><a name="4693">4693: </a></span>		// extract the current SingleTestSubset
<span class="nocode"><a name="4694">4694: </a></span>		SingleTestSubset currentTestSubset = 
<span class="nocode"><a name="4695">4695: </a></span>		    (SingleTestSubset) singleTestSubsetIterator.next();
<span class="nocode"><a name="4696">4696: </a></span>
<span class="nocode"><a name="4697">4697: </a></span>		// get the current test out of the SingleTestSubset
<span class="nocode"><a name="4698">4698: </a></span>		SingleTest currentTest = currentTestSubset.getTest();
<span class="nocode"><a name="4699">4699: </a></span>
<span class="nocode"><a name="4700">4700: </a></span>// 		System.out.println(&quot;currentTest = &quot; + 
<span class="nocode"><a name="4701">4701: </a></span>// 				   currentTest.getName());
<span class="nocode"><a name="4702">4702: </a></span>
<span class="nocode"><a name="4703">4703: </a></span>		// this current test has a cost that is under the 
<span class="nocode"><a name="4704">4704: </a></span>		// threshold and thus we must check to see about its
<span class="nocode"><a name="4705">4705: </a></span>		// redundancy factor (this is probably a good screen)
<span class="nocode"><a name="4706">4706: </a></span>		if( currentTest.getCost() &lt;= costIncludeThreshold )
<span class="nocode"><a name="4707">4707: </a></span>		    {
<span class="nocode"><a name="4708">4708: </a></span>
<span class="nocode"><a name="4709">4709: </a></span>// 			System.out.println(&quot;cost is under threshold&quot;);
<span class="nocode"><a name="4710">4710: </a></span>
<span class="nocode"><a name="4711">4711: </a></span>			// we just need to determine how many test 
<span class="nocode"><a name="4712">4712: </a></span>			// cases this current test covers; this is 
<span class="nocode"><a name="4713">4713: </a></span>			// just the size of the requirementsSubsetsSet
<span class="nocode"><a name="4714">4714: </a></span>			int testCoverage = 
<span class="nocode"><a name="4715">4715: </a></span>			    currentTestSubset.
<span class="nocode"><a name="4716">4716: </a></span>			    getRequirementSubsetSet().size();
<span class="nocode"><a name="4717">4717: </a></span>
<span class="nocode"><a name="4718">4718: </a></span>			// TESTING RESEARCHER NOTE: this was an example
<span class="nocode"><a name="4719">4719: </a></span>			// of a nice bug!  I had the conditional logic
<span class="nocode"><a name="4720">4720: </a></span>			// statement 
<span class="nocode"><a name="4721">4721: </a></span>
<span class="nocode"><a name="4722">4722: </a></span>			// if( testCoverage &gt;= 
<span class="nocode"><a name="4723">4723: </a></span>			//    costIncludeThreshold )
<span class="nocode"><a name="4724">4724: </a></span>			
<span class="nocode"><a name="4725">4725: </a></span>			// and it should have been the
<span class="nocode"><a name="4726">4726: </a></span>			// coverageIncludeThresh several test cases
<span class="nocode"><a name="4727">4727: </a></span>			// passed and did not reveal this bug.  This
<span class="nocode"><a name="4728">4728: </a></span>			// might be a good example to include in 
<span class="nocode"><a name="4729">4729: </a></span>			// future writing
<span class="nocode"><a name="4730">4730: </a></span>
<span class="nocode"><a name="4731">4731: </a></span>			// we have found a test whose coverage is
<span class="nocode"><a name="4732">4732: </a></span>			// greater than the threshold; we already know
<span class="nocode"><a name="4733">4733: </a></span>			// that its cost is under the threshold; thus
<span class="nocode"><a name="4734">4734: </a></span>			// go ahead and add it into the set of the
<span class="nocode"><a name="4735">4735: </a></span>			// &quot;best&quot; test cases
<span class="nocode"><a name="4736">4736: </a></span>			if( testCoverage &gt;= 
<span class="nocode"><a name="4737">4737: </a></span>			    coverageIncludeThreshold )
<span class="nocode"><a name="4738">4738: </a></span>			    {
<span class="nocode"><a name="4739">4739: </a></span>
<span class="nocode"><a name="4740">4740: </a></span>				maxCoverageMinCost.
<span class="nocode"><a name="4741">4741: </a></span>				    add(currentTestSubset);
<span class="nocode"><a name="4742">4742: </a></span>
<span class="nocode"><a name="4743">4743: </a></span>			    }
<span class="nocode"><a name="4744">4744: </a></span>
<span class="nocode"><a name="4745">4745: </a></span>		    }
<span class="nocode"><a name="4746">4746: </a></span>
<span class="nocode"><a name="4747">4747: </a></span>	    }
<span class="nocode"><a name="4748">4748: </a></span>
<span class="nocode"><a name="4749">4749: </a></span>	return maxCoverageMinCost;
<span class="nocode"><a name="4750">4750: </a></span>
<span class="nocode"><a name="4751">4751: </a></span>    }
<span class="nocode"><a name="4752">4752: </a></span>
<span class="nocode"><a name="4753">4753: </a></span>    /**
<span class="nocode"><a name="4754">4754: </a></span>     *  Determines the size of the overfilled sets in worst-case
<span class="nocode"><a name="4755">4755: </a></span>     *  
<span class="nocode"><a name="4756">4756: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4757">4757: </a></span>     */
<span class="nocode"><a name="4758">4758: </a></span>    public double worstCaseMaxSize()
<span class="nocode"><a name="4759">4759: </a></span>    {
<span class="nocode"><a name="4760">4760: </a></span>
<span class="nocode"><a name="4761">4761: </a></span>	int numberOfTests = testSubsets.size();
<span class="nocode"><a name="4762">4762: </a></span>	int totalRequirementNum = requirementSubsetUniverse.size();
<span class="nocode"><a name="4763">4763: </a></span>
<span class="nocode"><a name="4764">4764: </a></span>	return Math.ceil( ( (double)totalRequirementNum /  
<span class="nocode"><a name="4765">4765: </a></span>			    (double) (numberOfTests-1)  ) );
<span class="nocode"><a name="4766">4766: </a></span>	
<span class="nocode"><a name="4767">4767: </a></span>
<span class="nocode"><a name="4768">4768: </a></span>    }
<span class="nocode"><a name="4769">4769: </a></span>
<span class="nocode"><a name="4770">4770: </a></span>    /**
<span class="nocode"><a name="4771">4771: </a></span>     *  Determines the size of the underfilled sets in worst-case
<span class="nocode"><a name="4772">4772: </a></span>     *  
<span class="nocode"><a name="4773">4773: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4774">4774: </a></span>     */
<span class="nocode"><a name="4775">4775: </a></span>    public double worstCaseMinSize()
<span class="nocode"><a name="4776">4776: </a></span>    {
<span class="nocode"><a name="4777">4777: </a></span>
<span class="nocode"><a name="4778">4778: </a></span>	int numberOfTests = testSubsets.size();
<span class="nocode"><a name="4779">4779: </a></span>	int totalRequirementNum = requirementSubsetUniverse.size();
<span class="nocode"><a name="4780">4780: </a></span>
<span class="nocode"><a name="4781">4781: </a></span>	return Math.floor( ( (double)totalRequirementNum /  
<span class="nocode"><a name="4782">4782: </a></span>			    (double) (numberOfTests-1) ) );
<span class="nocode"><a name="4783">4783: </a></span>
<span class="nocode"><a name="4784">4784: </a></span>    }
<span class="nocode"><a name="4785">4785: </a></span>
<span class="nocode"><a name="4786">4786: </a></span>    /**
<span class="nocode"><a name="4787">4787: </a></span>     *  Determines the number of the overfilled sets in worst-case
<span class="nocode"><a name="4788">4788: </a></span>     *  
<span class="nocode"><a name="4789">4789: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4790">4790: </a></span>     */
<span class="nocode"><a name="4791">4791: </a></span>    public int worstCaseMaxNumber()
<span class="nocode"><a name="4792">4792: </a></span>    {
<span class="nocode"><a name="4793">4793: </a></span>
<span class="nocode"><a name="4794">4794: </a></span>	int numberOfTests = testSubsets.size();
<span class="nocode"><a name="4795">4795: </a></span>	int totalRequirementNum = requirementSubsetUniverse.size();
<span class="nocode"><a name="4796">4796: </a></span>
<span class="nocode"><a name="4797">4797: </a></span>	return totalRequirementNum % (numberOfTests-1);
<span class="nocode"><a name="4798">4798: </a></span>
<span class="nocode"><a name="4799">4799: </a></span>    }    
<span class="nocode"><a name="4800">4800: </a></span>
<span class="nocode"><a name="4801">4801: </a></span>    /**
<span class="nocode"><a name="4802">4802: </a></span>     *  Determines the number of the overfilled sets in worst-case
<span class="nocode"><a name="4803">4803: </a></span>     *  
<span class="nocode"><a name="4804">4804: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4805">4805: </a></span>     */
<span class="nocode"><a name="4806">4806: </a></span>    public int worstCaseMinNumber()
<span class="nocode"><a name="4807">4807: </a></span>    {
<span class="nocode"><a name="4808">4808: </a></span>
<span class="nocode"><a name="4809">4809: </a></span>	int numberOfTests = testSubsets.size();
<span class="nocode"><a name="4810">4810: </a></span>	int totalRequirementNum = requirementSubsetUniverse.size();
<span class="nocode"><a name="4811">4811: </a></span>
<span class="nocode"><a name="4812">4812: </a></span>	return ( numberOfTests - (totalRequirementNum % numberOfTests) );
<span class="nocode"><a name="4813">4813: </a></span>
<span class="nocode"><a name="4814">4814: </a></span>    }    
<span class="nocode"><a name="4815">4815: </a></span>
<span class="nocode"><a name="4816">4816: </a></span>   
<span class="nocode"><a name="4817">4817: </a></span>   /**
<span class="nocode"><a name="4818">4818: </a></span>    * Serializes a SetCover to a byte array, retaining the object graph.
<span class="nocode"><a name="4819">4819: </a></span>    * @author Adam M. Smith 08/01/2007
<span class="nocode"><a name="4820">4820: </a></span>    *
<span class="nocode"><a name="4821">4821: </a></span>    * 
<span class="nocode"><a name="4822">4822: </a></span>    */
<span class="nocode"><a name="4823">4823: </a></span>   
<span class="nocode"><a name="4824">4824: </a></span>   public FastByteArrayOutputStream createFastByteArrayOutputStream() {
<span class="nocode"><a name="4825">4825: </a></span>   	FastByteArrayOutputStream fbos = null;
<span class="nocode"><a name="4826">4826: </a></span>   	try {
<span class="nocode"><a name="4827">4827: </a></span>   		// Write the object out to a byte array
<span class="nocode"><a name="4828">4828: </a></span>           fbos = new FastByteArrayOutputStream();
<span class="nocode"><a name="4829">4829: </a></span>           ObjectOutputStream out = new ObjectOutputStream(fbos);
<span class="nocode"><a name="4830">4830: </a></span>           out.writeObject(this);
<span class="nocode"><a name="4831">4831: </a></span>           out.flush();
<span class="nocode"><a name="4832">4832: </a></span>           out.close();
<span class="nocode"><a name="4833">4833: </a></span>		}
<span class="nocode"><a name="4834">4834: </a></span>		
<span class="nocode"><a name="4835">4835: </a></span>		catch(IOException e) { 
<span class="nocode"><a name="4836">4836: </a></span>			e.printStackTrace();
<span class="nocode"><a name="4837">4837: </a></span>		}
<span class="nocode"><a name="4838">4838: </a></span>		     
<span class="nocode"><a name="4839">4839: </a></span>      return fbos;
<span class="nocode"><a name="4840">4840: </a></span>   
<span class="nocode"><a name="4841">4841: </a></span>   }
<span class="nocode"><a name="4842">4842: </a></span>   
<span class="nocode"><a name="4843">4843: </a></span>   
<span class="nocode"><a name="4844">4844: </a></span>   /**
<span class="nocode"><a name="4845">4845: </a></span>    * Clones a SetCover from the bottom up
<span class="nocode"><a name="4846">4846: </a></span>    * @author Adam M. Smith 07/31/2007
<span class="nocode"><a name="4847">4847: </a></span>    *
<span class="nocode"><a name="4848">4848: </a></span>    * This code did not retain the cloned objects graph and so is not used.  Serialization using JOS is 
<span class="nocode"><a name="4849">4849: </a></span>    * used instead.
<span class="nocode"><a name="4850">4850: </a></span>    */
<span class="nocode"><a name="4851">4851: </a></span>  
<span class="nocode"><a name="4852">4852: </a></span>  
<span class="nocode"><a name="4853">4853: </a></span>  /* 
<span class="nocode"><a name="4854">4854: </a></span>   
<span class="nocode"><a name="4855">4855: </a></span>   public SetCover cloneBottomUp() {
<span class="nocode"><a name="4856">4856: </a></span>   
<span class="nocode"><a name="4857">4857: </a></span>   	SetCover clone = new SetCover();
<span class="nocode"><a name="4858">4858: </a></span>   	
<span class="nocode"><a name="4859">4859: </a></span>   	LinkedHashSet newRequirements = new LinkedHashSet(); 
<span class="nocode"><a name="4860">4860: </a></span>		LinkedHashSet newSingleTestSubsets = new LinkedHashSet();
<span class="nocode"><a name="4861">4861: </a></span>		LinkedHashSet newTests = new LinkedHashSet();
<span class="nocode"><a name="4862">4862: </a></span>		
<span class="nocode"><a name="4863">4863: </a></span>		
<span class="nocode"><a name="4864">4864: </a></span>		Iterator getRequirementsIterator = requirementSubsetUniverse.iterator();
<span class="nocode"><a name="4865">4865: </a></span>		
<span class="nocode"><a name="4866">4866: </a></span>		// copy the requirementSubsetUniverse
<span class="nocode"><a name="4867">4867: </a></span>		while (getRequirementsIterator.hasNext()){
<span class="nocode"><a name="4868">4868: </a></span>			newRequirements.add( (RequirementSubset) ( (RequirementSubset) getRequirementsIterator.next()).clone() );
<span class="nocode"><a name="4869">4869: </a></span>   	}
<span class="nocode"><a name="4870">4870: </a></span>   	
<span class="nocode"><a name="4871">4871: </a></span>   	// Make the list of Singletests
<span class="nocode"><a name="4872">4872: </a></span>     	Iterator newRequirementsIterator = newRequirements.iterator();
<span class="nocode"><a name="4873">4873: </a></span>     	
<span class="nocode"><a name="4874">4874: </a></span>     	System.out.println(&quot;about to add in clone ************\n\n\n&quot;);
<span class="nocode"><a name="4875">4875: </a></span>     	
<span class="nocode"><a name="4876">4876: </a></span>     	while (newRequirementsIterator.hasNext()){
<span class="nocode"><a name="4877">4877: </a></span>     		Iterator getTestsIterator = ((RequirementSubset) newRequirementsIterator.next()).getCoveringTests().iterator();
<span class="nocode"><a name="4878">4878: </a></span>     		while (getTestsIterator.hasNext()){
<span class="nocode"><a name="4879">4879: </a></span>     			SingleTest currentSingleTest = (SingleTest) getTestsIterator.next();
<span class="nocode"><a name="4880">4880: </a></span>     			if (!newTests.contains(currentSingleTest)){
<span class="nocode"><a name="4881">4881: </a></span>     				newTests.add(currentSingleTest);
<span class="nocode"><a name="4882">4882: </a></span>     				System.out.println(currentSingleTest);
<span class="nocode"><a name="4883">4883: </a></span>     			}
<span class="nocode"><a name="4884">4884: </a></span>     		}
<span class="nocode"><a name="4885">4885: </a></span>     	}
<span class="nocode"><a name="4886">4886: </a></span>   		
<span class="nocode"><a name="4887">4887: </a></span>   	Iterator testSuiteUniverseIterator = newTests.iterator();
<span class="nocode"><a name="4888">4888: </a></span>   	
<span class="nocode"><a name="4889">4889: </a></span>   	while (testSuiteUniverseIterator.hasNext()){
<span class="nocode"><a name="4890">4890: </a></span>   		SingleTest currentTest = (SingleTest) testSuiteUniverseIterator.next();
<span class="nocode"><a name="4891">4891: </a></span>   		
<span class="nocode"><a name="4892">4892: </a></span>   		Iterator newRequirementsIteratorAgain = newRequirements.iterator();
<span class="nocode"><a name="4893">4893: </a></span>   		
<span class="nocode"><a name="4894">4894: </a></span>   		SingleTestSubset sts = new SingleTestSubset(currentTest);
<span class="nocode"><a name="4895">4895: </a></span>   		
<span class="nocode"><a name="4896">4896: </a></span>   		while (newRequirementsIteratorAgain.hasNext()){
<span class="nocode"><a name="4897">4897: </a></span>   			RequirementSubset currentSubset = (RequirementSubset) newRequirementsIteratorAgain.next();
<span class="nocode"><a name="4898">4898: </a></span>   			
<span class="nocode"><a name="4899">4899: </a></span>   			if (currentSubset.containsSingleTest(currentTest)){
<span class="nocode"><a name="4900">4900: </a></span>   				sts.addRequirementSubset(currentSubset);
<span class="nocode"><a name="4901">4901: </a></span>   			}
<span class="nocode"><a name="4902">4902: </a></span>   			
<span class="nocode"><a name="4903">4903: </a></span>   			clone.addSingleTestSubset(sts);
<span class="nocode"><a name="4904">4904: </a></span>   			
<span class="nocode"><a name="4905">4905: </a></span>   		}
<span class="nocode"><a name="4906">4906: </a></span>   	}
<span class="nocode"><a name="4907">4907: </a></span>   	   
<span class="nocode"><a name="4908">4908: </a></span>   	   clone.setRequirementSubsetUniverse(newRequirements);
<span class="nocode"><a name="4909">4909: </a></span>   	return clone;
<span class="nocode"><a name="4910">4910: </a></span>   }
<span class="nocode"><a name="4911">4911: </a></span>   */
<span class="nocode"><a name="4912">4912: </a></span>   
<span class="nocode"><a name="4913">4913: </a></span>    /**
<span class="nocode"><a name="4914">4914: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4915">4915: </a></span>     */
<span class="nocode"><a name="4916">4916: </a></span>     
<span class="nocode"><a name="4917">4917: </a></span>    public Object clone()
<span class="nocode"><a name="4918">4918: </a></span>    {
<span class="nocode"><a name="4919">4919: </a></span>
<span class="nocode"><a name="4920">4920: </a></span>	
<span class="nocode"><a name="4921">4921: </a></span>
<span class="nocode"><a name="4922">4922: </a></span>	SetCover clone = new SetCover();
<span class="nocode"><a name="4923">4923: </a></span>	
<span class="nocode"><a name="4924">4924: </a></span>	// create a universe for the clone
<span class="nocode"><a name="4925">4925: </a></span>// 	clone.
<span class="nocode"><a name="4926">4926: </a></span>// 	    setRequirementSubsetUniverse(this.
<span class="nocode"><a name="4927">4927: </a></span>// 					 getRequirementSubsetUniverse());
<span class="nocode"><a name="4928">4928: </a></span>
<span class="nocode"><a name="4929">4929: </a></span>	LinkedHashSet newRSU = new LinkedHashSet();
<span class="nocode"><a name="4930">4930: </a></span>	Iterator rsuIterator = 
<span class="nocode"><a name="4931">4931: </a></span>	    this.getRequirementSubsetUniverse().iterator();
<span class="nocode"><a name="4932">4932: </a></span>	while( rsuIterator.hasNext() )
<span class="nocode"><a name="4933">4933: </a></span>	    {
<span class="nocode"><a name="4934">4934: </a></span>
<span class="nocode"><a name="4935">4935: </a></span>		RequirementSubset currentSubset = 
<span class="nocode"><a name="4936">4936: </a></span>		    (RequirementSubset)rsuIterator.next();
<span class="nocode"><a name="4937">4937: </a></span>
<span class="nocode"><a name="4938">4938: </a></span>		newRSU.add(currentSubset.clone());
<span class="nocode"><a name="4939">4939: </a></span>
<span class="nocode"><a name="4940">4940: </a></span>	    }
<span class="nocode"><a name="4941">4941: </a></span>
<span class="nocode"><a name="4942">4942: </a></span>	clone.setRequirementSubsetUniverse(newRSU);
<span class="nocode"><a name="4943">4943: </a></span>	
<span class="nocode"><a name="4944">4944: </a></span>	// create a new SingleTestSubset for the clone
<span class="nocode"><a name="4945">4945: </a></span>// 	clone.
<span class="nocode"><a name="4946">4946: </a></span>// 	    setTestSubsetsSet( (LinkedHashSet) 
<span class="nocode"><a name="4947">4947: </a></span>// 			       this.getTestSubsets().clone() );
<span class="nocode"><a name="4948">4948: </a></span>
<span class="nocode"><a name="4949">4949: </a></span>	LinkedHashSet newSet = new LinkedHashSet();
<span class="nocode"><a name="4950">4950: </a></span>	Iterator testSubsetsIterator = this.getTestSubsets().iterator();
<span class="nocode"><a name="4951">4951: </a></span>	while( testSubsetsIterator.hasNext() )
<span class="nocode"><a name="4952">4952: </a></span>	    {
<span class="nocode"><a name="4953">4953: </a></span>
<span class="nocode"><a name="4954">4954: </a></span>		SingleTestSubset currentTs = 
<span class="nocode"><a name="4955">4955: </a></span>		    (SingleTestSubset) testSubsetsIterator.next();
<span class="nocode"><a name="4956">4956: </a></span>
<span class="nocode"><a name="4957">4957: </a></span>		newSet.add(currentTs.clone());
<span class="nocode"><a name="4958">4958: </a></span>		
<span class="nocode"><a name="4959">4959: </a></span>	    }
<span class="nocode"><a name="4960">4960: </a></span>
<span class="nocode"><a name="4961">4961: </a></span>	clone.setTestSubsetsSet(newSet);
<span class="nocode"><a name="4962">4962: </a></span>
<span class="nocode"><a name="4963">4963: </a></span>// 	if( this.getBeforeReduction() != null )
<span class="nocode"><a name="4964">4964: </a></span>// 	    {
<span class="nocode"><a name="4965">4965: </a></span>
<span class="nocode"><a name="4966">4966: </a></span>// 		SetCover beforeInThis = this.getBeforeReduction();
<span class="nocode"><a name="4967">4967: </a></span>// 		SetCover beforeInClone = (SetCover)beforeInThis.clone();
<span class="nocode"><a name="4968">4968: </a></span>// 		clone.setBeforeReduction(beforeInClone);
<span class="nocode"><a name="4969">4969: </a></span>
<span class="nocode"><a name="4970">4970: </a></span>// 	    }
<span class="nocode"><a name="4971">4971: </a></span>
<span class="nocode"><a name="4972">4972: </a></span>	return clone;
<span class="nocode"><a name="4973">4973: </a></span>
<span class="nocode"><a name="4974">4974: </a></span>    }
<span class="nocode"><a name="4975">4975: </a></span>
<span class="nocode"><a name="4976">4976: </a></span>    /**
<span class="nocode"><a name="4977">4977: </a></span>     *  @author Gregory M. Kapfhammer 9/20/2005
<span class="nocode"><a name="4978">4978: </a></span>     */
<span class="nocode"><a name="4979">4979: </a></span>    public String toString()
<span class="nocode"><a name="4980">4980: </a></span>    {
<span class="nocode"><a name="4981">4981: </a></span>
<span class="nocode"><a name="4982">4982: </a></span>	return &quot;SetCover(U = &quot; + requirementSubsetUniverse + 
<span class="nocode"><a name="4983">4983: </a></span>	    &quot; U.size = &quot; + requirementSubsetUniverse.size() + &quot;, S=&quot; + 
<span class="nocode"><a name="4984">4984: </a></span>	    testSubsets + &quot; S.size = &quot; + testSubsets.size() + &quot;)&quot;;
<span class="nocode"><a name="4985">4985: </a></span>
<span class="nocode"><a name="4986">4986: </a></span>//  	return &quot;SetCover(U = &quot; + requirementSubsetUniverse +  &quot;, S=&quot; + 
<span class="nocode"><a name="4987">4987: </a></span>//  	    testSubsets + &quot;)&quot;;
<span class="nocode"><a name="4988">4988: </a></span>
<span class="nocode"><a name="4989">4989: </a></span>    }
<span class="nocode"><a name="4990">4990: </a></span>    
<span class="nocode"><a name="4991">4991: </a></span>    public static String getCoveringTestSetString(Set inSet,String separator)
<span class="nocode"><a name="4992">4992: </a></span>	{
<span class="nocode"><a name="4993">4993: </a></span>		String output=&quot;&quot;;
<span class="nocode"><a name="4994">4994: </a></span>		Iterator coverPickSetsIterator = inSet.iterator();
<span class="nocode"><a name="4995">4995: </a></span>		
<span class="nocode"><a name="4996">4996: </a></span>		if (coverPickSetsIterator.hasNext())
<span class="nocode"><a name="4997">4997: </a></span>		{
<span class="nocode"><a name="4998">4998: </a></span>			int index = (((SingleTest) coverPickSetsIterator.next()).getIndex()+1);
<span class="nocode"><a name="4999">4999: </a></span>			output = (output+index);
<span class="nocode"><a name="5000">5000: </a></span>		}
<span class="nocode"><a name="5001">5001: </a></span>		
<span class="nocode"><a name="5002">5002: </a></span>		while (coverPickSetsIterator.hasNext())	
<span class="nocode"><a name="5003">5003: </a></span>		{
<span class="nocode"><a name="5004">5004: </a></span>			int index = (((SingleTest) coverPickSetsIterator.next()).getIndex()+1);
<span class="nocode"><a name="5005">5005: </a></span>			output = (output+separator+index );
<span class="nocode"><a name="5006">5006: </a></span>		}
<span class="nocode"><a name="5007">5007: </a></span>		
<span class="nocode"><a name="5008">5008: </a></span>		return output;
<span class="nocode"><a name="5009">5009: </a></span>	
<span class="nocode"><a name="5010">5010: </a></span>	}
<span class="nocode"><a name="5011">5011: </a></span>
<span class="nocode"><a name="5012">5012: </a></span>}
</pre><table class="mutation_table" summary="Mutations">
<tr><th>ID</th><th>Line</th><th>Type</th><th>Detected</th></tr><tr><td>3</td><td><a href="#140">140</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>4</td><td><a href="#140">140</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>2</td><td><a href="#140">140</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>5</td><td><a href="#142">142</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>6</td><td><a href="#142">142</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>7</td><td><a href="#143">143</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>8</td><td><a href="#143">143</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>9</td><td><a href="#146">146</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>10</td><td><a href="#146">146</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>11</td><td><a href="#147">147</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>12</td><td><a href="#147">147</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>13</td><td><a href="#219">219</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>15</td><td><a href="#220">220</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>14</td><td><a href="#220">220</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>16</td><td><a href="#224">224</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>17</td><td><a href="#228">228</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>18</td><td><a href="#231">231</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>19</td><td><a href="#231">231(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>20</td><td><a href="#250">250</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>21</td><td><a href="#254">254</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>23</td><td><a href="#256">256</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>22</td><td><a href="#256">256</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>24</td><td><a href="#258">258</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>25</td><td><a href="#258">258(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>26</td><td><a href="#260">260</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>27</td><td><a href="#260">260(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>29</td><td><a href="#262">262</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>28</td><td><a href="#262">262</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>30</td><td><a href="#264">264</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>32</td><td><a href="#265">265</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>31</td><td><a href="#265">265</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>33</td><td><a href="#266">266</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>35</td><td><a href="#270">270</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>34</td><td><a href="#270">270</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>37</td><td><a href="#271">271</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>38</td><td><a href="#271">271</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>36</td><td><a href="#271">271</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>39</td><td><a href="#274">274</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>40</td><td><a href="#274">274</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>41</td><td><a href="#285">285</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>43</td><td><a href="#288">288</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>42</td><td><a href="#288">288</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>44</td><td><a href="#290">290</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>45</td><td><a href="#295">295</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>49</td><td><a href="#301">301</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>46</td><td><a href="#301">301</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>47</td><td><a href="#301">301(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>48</td><td><a href="#301">301(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>50</td><td><a href="#321">321</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>51</td><td><a href="#322">322</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>53</td><td><a href="#365">365</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>54</td><td><a href="#365">365</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>52</td><td><a href="#365">365</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>55</td><td><a href="#366">366</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>56</td><td><a href="#366">366</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>57</td><td><a href="#381">381</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>58</td><td><a href="#386">386</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>59</td><td><a href="#392">392</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>60</td><td><a href="#393">393</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>61</td><td><a href="#403">403</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>63</td><td><a href="#406">406</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>62</td><td><a href="#406">406</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>64</td><td><a href="#408">408</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>66</td><td><a href="#412">412</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>65</td><td><a href="#412">412</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>67</td><td><a href="#414">414</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>68</td><td><a href="#420">420</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>69</td><td><a href="#420">420</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>70</td><td><a href="#420">420</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>71</td><td><a href="#423">423</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>72</td><td><a href="#424">424</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>73</td><td><a href="#424">424(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>74</td><td><a href="#425">425</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>75</td><td><a href="#425">425(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>76</td><td><a href="#425">425(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>77</td><td><a href="#426">426</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>78</td><td><a href="#427">427</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>79</td><td><a href="#434">434</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>80</td><td><a href="#436">436</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>81</td><td><a href="#439">439</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>82</td><td><a href="#439">439</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>83</td><td><a href="#439">439</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>84</td><td><a href="#442">442</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>85</td><td><a href="#442">442(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>86</td><td><a href="#442">442(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>87</td><td><a href="#445">445</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>88</td><td><a href="#451">451</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>89</td><td><a href="#451">451</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>90</td><td><a href="#451">451</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>94</td><td><a href="#455">455</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>95</td><td><a href="#455">455</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>93</td><td><a href="#455">455</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>96</td><td><a href="#455">455</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>91</td><td><a href="#455">455</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>92</td><td><a href="#455">455(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>97</td><td><a href="#458">458</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>98</td><td><a href="#458">458(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>99</td><td><a href="#461">461</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>100</td><td><a href="#461">461(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>101</td><td><a href="#466">466</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>102</td><td><a href="#469">469</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>103</td><td><a href="#469">469</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>104</td><td><a href="#469">469</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>105</td><td><a href="#471">471</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>106</td><td><a href="#471">471(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>107</td><td><a href="#474">474</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>108</td><td><a href="#474">474</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>109</td><td><a href="#474">474</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>110</td><td><a href="#476">476</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>111</td><td><a href="#476">476(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>112</td><td><a href="#505">505</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>114</td><td><a href="#512">512</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>115</td><td><a href="#512">512</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>113</td><td><a href="#512">512</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>116</td><td><a href="#517">517</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>117</td><td><a href="#517">517(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>119</td><td><a href="#518">518</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>118</td><td><a href="#518">518</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>120</td><td><a href="#522">522</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>121</td><td><a href="#526">526</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>122</td><td><a href="#538">538</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>123</td><td><a href="#538">538(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>124</td><td><a href="#547">547</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>125</td><td><a href="#567">567</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>126</td><td><a href="#567">567</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>127</td><td><a href="#570">570</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>129</td><td><a href="#571">571</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>128</td><td><a href="#571">571</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>130</td><td><a href="#574">574</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>132</td><td><a href="#575">575</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>131</td><td><a href="#575">575</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>133</td><td><a href="#594">594</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>134</td><td><a href="#594">594</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>135</td><td><a href="#597">597</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>137</td><td><a href="#598">598</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>136</td><td><a href="#598">598</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>138</td><td><a href="#601">601</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>140</td><td><a href="#602">602</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>139</td><td><a href="#602">602</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>141</td><td><a href="#618">618</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>142</td><td><a href="#633">633</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>143</td><td><a href="#633">633</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>144</td><td><a href="#636">636</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>146</td><td><a href="#637">637</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>145</td><td><a href="#637">637</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>147</td><td><a href="#641">641</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>148</td><td><a href="#645">645</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>150</td><td><a href="#648">648</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>149</td><td><a href="#648">648</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>151</td><td><a href="#666">666</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>152</td><td><a href="#703">703</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>153</td><td><a href="#714">714</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>154</td><td><a href="#746">746</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>155</td><td><a href="#758">758</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>156</td><td><a href="#770">770</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>157</td><td><a href="#782">782</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>158</td><td><a href="#794">794</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>159</td><td><a href="#806">806</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>160</td><td><a href="#820">820</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>161</td><td><a href="#832">832</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>162</td><td><a href="#1063">1063</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>163</td><td><a href="#1070">1070</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>164</td><td><a href="#1070">1070(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>165</td><td><a href="#1070">1070(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>166</td><td><a href="#1070">1070(3)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>167</td><td><a href="#1077">1077</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>168</td><td><a href="#1082">1082</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>169</td><td><a href="#1082">1082</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>170</td><td><a href="#1087">1087</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>172</td><td><a href="#1089">1089</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>173</td><td><a href="#1089">1089(1)</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>171</td><td><a href="#1089">1089</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>174</td><td><a href="#1097">1097</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>175</td><td><a href="#1100">1100</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>176</td><td><a href="#1100">1100(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>177</td><td><a href="#1104">1104</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>178</td><td><a href="#1112">1112</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>179</td><td><a href="#1113">1113</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>180</td><td><a href="#1139">1139</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>182</td><td><a href="#1151">1151</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>183</td><td><a href="#1151">1151</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>181</td><td><a href="#1151">1151</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>184</td><td><a href="#1155">1155</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>185</td><td><a href="#1169">1169</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>187</td><td><a href="#1170">1170</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>186</td><td><a href="#1170">1170</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>188</td><td><a href="#1178">1178</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>189</td><td><a href="#1181">1181</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>190</td><td><a href="#1181">1181(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>191</td><td><a href="#1185">1185</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>192</td><td><a href="#1191">1191</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>193</td><td><a href="#1192">1192</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>194</td><td><a href="#1211">1211</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>195</td><td><a href="#1219">1219</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>196</td><td><a href="#1224">1224</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>197</td><td><a href="#1224">1224</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>198</td><td><a href="#1229">1229</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>200</td><td><a href="#1231">1231</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>201</td><td><a href="#1231">1231(1)</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>199</td><td><a href="#1231">1231</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>202</td><td><a href="#1239">1239</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>203</td><td><a href="#1242">1242</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>204</td><td><a href="#1242">1242(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>205</td><td><a href="#1246">1246</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>206</td><td><a href="#1254">1254</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>207</td><td><a href="#1255">1255</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>208</td><td><a href="#1272">1272</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>209</td><td><a href="#1280">1280</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>210</td><td><a href="#1286">1286</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>212</td><td><a href="#1287">1287</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>211</td><td><a href="#1287">1287</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>213</td><td><a href="#1294">1294</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>214</td><td><a href="#1297">1297</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>215</td><td><a href="#1297">1297(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>216</td><td><a href="#1301">1301</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>217</td><td><a href="#1307">1307</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>218</td><td><a href="#1308">1308</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>219</td><td><a href="#1326">1326</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>220</td><td><a href="#1337">1337</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>222</td><td><a href="#1338">1338</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>221</td><td><a href="#1338">1338</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>223</td><td><a href="#1341">1341</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>224</td><td><a href="#1344">1344</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>225</td><td><a href="#1344">1344(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>226</td><td><a href="#1348">1348</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>227</td><td><a href="#1354">1354</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>228</td><td><a href="#1355">1355</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>229</td><td><a href="#1374">1374</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>230</td><td><a href="#1384">1384</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>231</td><td><a href="#1384">1384</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>232</td><td><a href="#1389">1389</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>234</td><td><a href="#1391">1391</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>235</td><td><a href="#1391">1391(1)</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>233</td><td><a href="#1391">1391</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>236</td><td><a href="#1394">1394</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>237</td><td><a href="#1397">1397</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>238</td><td><a href="#1397">1397(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>239</td><td><a href="#1401">1401</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>240</td><td><a href="#1409">1409</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>241</td><td><a href="#1410">1410</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>242</td><td><a href="#1925">1925</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>243</td><td><a href="#1937">1937</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>244</td><td><a href="#1940">1940</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>245</td><td><a href="#1940">1940</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>246</td><td><a href="#1943">1943</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>248</td><td><a href="#1945">1945</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>249</td><td><a href="#1945">1945(1)</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>247</td><td><a href="#1945">1945</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>250</td><td><a href="#1948">1948</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>251</td><td><a href="#1951">1951</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>252</td><td><a href="#1951">1951(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>253</td><td><a href="#1955">1955</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>254</td><td><a href="#1963">1963</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>255</td><td><a href="#1964">1964</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>256</td><td><a href="#1981">1981</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>257</td><td><a href="#1992">1992</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>258</td><td><a href="#2005">2005</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>260</td><td><a href="#2006">2006</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>259</td><td><a href="#2006">2006</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>261</td><td><a href="#2009">2009</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>262</td><td><a href="#2012">2012</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>263</td><td><a href="#2012">2012(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>264</td><td><a href="#2016">2016</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>265</td><td><a href="#2022">2022</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>266</td><td><a href="#2023">2023</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>267</td><td><a href="#2049">2049</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>268</td><td><a href="#2064">2064</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>270</td><td><a href="#2068">2068</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>269</td><td><a href="#2068">2068</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>271</td><td><a href="#2086">2086</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>272</td><td><a href="#2103">2103</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>274</td><td><a href="#2104">2104</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>273</td><td><a href="#2104">2104</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>275</td><td><a href="#2108">2108</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>276</td><td><a href="#2115">2115</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>277</td><td><a href="#2120">2120</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>278</td><td><a href="#2134">2134</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>279</td><td><a href="#2143">2143</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>281</td><td><a href="#2149">2149</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>282</td><td><a href="#2149">2149</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>280</td><td><a href="#2149">2149</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>283</td><td><a href="#2149">2149</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>284</td><td><a href="#2161">2161</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>285</td><td><a href="#2161">2161(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>286</td><td><a href="#2171">2171</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>287</td><td><a href="#2174">2174</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>288</td><td><a href="#2356">2356</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>289</td><td><a href="#2399">2399</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>290</td><td><a href="#2399">2399</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>291</td><td><a href="#2404">2404</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>293</td><td><a href="#2410">2410</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>292</td><td><a href="#2410">2410</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>294</td><td><a href="#2438">2438</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>295</td><td><a href="#2439">2439</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>296</td><td><a href="#2446">2446</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>298</td><td><a href="#2457">2457</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>299</td><td><a href="#2457">2457</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>297</td><td><a href="#2457">2457</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>301</td><td><a href="#2466">2466</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>300</td><td><a href="#2466">2466</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>302</td><td><a href="#2477">2477</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>304</td><td><a href="#2490">2490</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>303</td><td><a href="#2490">2490</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>305</td><td><a href="#2496">2496</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>306</td><td><a href="#2505">2505</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>307</td><td><a href="#2516">2516</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>308</td><td><a href="#2545">2545</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>309</td><td><a href="#2553">2553</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>310</td><td><a href="#2558">2558</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>311</td><td><a href="#2575">2575</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>312</td><td><a href="#2601">2601</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>313</td><td><a href="#2616">2616</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>314</td><td><a href="#2616">2616(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>315</td><td><a href="#2623">2623</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>316</td><td><a href="#2623">2623(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>317</td><td><a href="#2627">2627</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>318</td><td><a href="#2643">2643</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>320</td><td><a href="#2651">2651</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>321</td><td><a href="#2651">2651</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>319</td><td><a href="#2651">2651</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>322</td><td><a href="#2651">2651</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>323</td><td><a href="#2662">2662</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>324</td><td><a href="#2665">2665</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>325</td><td><a href="#2668">2668</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>326</td><td><a href="#3201">3201</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>327</td><td><a href="#3201">3201</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>328</td><td><a href="#3212">3212</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>330</td><td><a href="#3213">3213</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>329</td><td><a href="#3213">3213</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>331</td><td><a href="#3219">3219</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>332</td><td><a href="#3222">3222</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>333</td><td><a href="#3226">3226</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>334</td><td><a href="#3226">3226(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>336</td><td><a href="#3228">3228</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>335</td><td><a href="#3228">3228</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>337</td><td><a href="#3233">3233</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>338</td><td><a href="#3236">3236</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>339</td><td><a href="#3243">3243</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>341</td><td><a href="#3248">3248</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>340</td><td><a href="#3248">3248</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>342</td><td><a href="#3252">3252</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>343</td><td><a href="#3260">3260</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>344</td><td><a href="#3260">3260(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>345</td><td><a href="#3264">3264</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>346</td><td><a href="#3268">3268</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>347</td><td><a href="#3308">3308</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>348</td><td><a href="#3308">3308</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>349</td><td><a href="#3319">3319</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>351</td><td><a href="#3320">3320</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>350</td><td><a href="#3320">3320</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>352</td><td><a href="#3326">3326</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>353</td><td><a href="#3329">3329</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>354</td><td><a href="#3336">3336</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>355</td><td><a href="#3336">3336(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>356</td><td><a href="#3338">3338</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>357</td><td><a href="#3338">3338</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>359</td><td><a href="#3339">3339</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>358</td><td><a href="#3339">3339</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>360</td><td><a href="#3347">3347</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>361</td><td><a href="#3350">3350</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>362</td><td><a href="#3357">3357</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>364</td><td><a href="#3362">3362</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>363</td><td><a href="#3362">3362</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>365</td><td><a href="#3366">3366</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>366</td><td><a href="#3377">3377</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>367</td><td><a href="#3377">3377(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>368</td><td><a href="#3383">3383</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>369</td><td><a href="#3386">3386</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>370</td><td><a href="#4057">4057</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>371</td><td><a href="#4057">4057</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>372</td><td><a href="#4060">4060</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>374</td><td><a href="#4061">4061</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>373</td><td><a href="#4061">4061</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>375</td><td><a href="#4064">4064</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>376</td><td><a href="#4067">4067</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>377</td><td><a href="#4070">4070</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>378</td><td><a href="#4074">4074</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>379</td><td><a href="#4078">4078</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>380</td><td><a href="#4082">4082</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>381</td><td><a href="#4093">4093</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>382</td><td><a href="#4096">4096</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>384</td><td><a href="#4121">4121</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>385</td><td><a href="#4121">4121</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>383</td><td><a href="#4121">4121</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>386</td><td><a href="#4124">4124</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>388</td><td><a href="#4125">4125</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>387</td><td><a href="#4125">4125</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>389</td><td><a href="#4128">4128</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>390</td><td><a href="#4131">4131</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>391</td><td><a href="#4134">4134</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>392</td><td><a href="#4138">4138</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>393</td><td><a href="#4142">4142</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>394</td><td><a href="#4146">4146</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>395</td><td><a href="#4157">4157</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>396</td><td><a href="#4160">4160</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>397</td><td><a href="#4187">4187</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>398</td><td><a href="#4187">4187</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>399</td><td><a href="#4196">4196</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>401</td><td><a href="#4197">4197</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>400</td><td><a href="#4197">4197</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>402</td><td><a href="#4201">4201</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>403</td><td><a href="#4206">4206</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>404</td><td><a href="#4206">4206(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>406</td><td><a href="#4212">4212</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>405</td><td><a href="#4212">4212</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>407</td><td><a href="#4216">4216</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>408</td><td><a href="#4221">4221</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>409</td><td><a href="#4226">4226</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>410</td><td><a href="#4230">4230</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>411</td><td><a href="#4237">4237</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>412</td><td><a href="#4249">4249</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>413</td><td><a href="#4252">4252</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>414</td><td><a href="#4281">4281</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>415</td><td><a href="#4281">4281</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>416</td><td><a href="#4290">4290</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>418</td><td><a href="#4291">4291</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>417</td><td><a href="#4291">4291</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>419</td><td><a href="#4295">4295</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>420</td><td><a href="#4300">4300</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>421</td><td><a href="#4300">4300(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>422</td><td><a href="#4304">4304</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>423</td><td><a href="#4304">4304</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>424</td><td><a href="#4308">4308</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>425</td><td><a href="#4308">4308</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>427</td><td><a href="#4313">4313</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>426</td><td><a href="#4313">4313</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>428</td><td><a href="#4317">4317</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>429</td><td><a href="#4322">4322</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>430</td><td><a href="#4325">4325</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>431</td><td><a href="#4333">4333</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>432</td><td><a href="#4339">4339</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>433</td><td><a href="#4343">4343</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>434</td><td><a href="#4349">4349</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>435</td><td><a href="#4360">4360</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>436</td><td><a href="#4363">4363</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>437</td><td><a href="#4385">4385</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>438</td><td><a href="#4385">4385</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>439</td><td><a href="#4388">4388</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>441</td><td><a href="#4392">4392</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>440</td><td><a href="#4392">4392</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>442</td><td><a href="#4395">4395</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>443</td><td><a href="#4398">4398</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>444</td><td><a href="#4398">4398(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>445</td><td><a href="#4403">4403</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>446</td><td><a href="#4407">4407</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>447</td><td><a href="#4411">4411</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>448</td><td><a href="#4422">4422</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>449</td><td><a href="#4425">4425</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>451</td><td><a href="#4447">4447</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>452</td><td><a href="#4447">4447</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>450</td><td><a href="#4447">4447</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>453</td><td><a href="#4450">4450</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>455</td><td><a href="#4454">4454</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>454</td><td><a href="#4454">4454</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>456</td><td><a href="#4457">4457</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>457</td><td><a href="#4460">4460</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>458</td><td><a href="#4460">4460(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>459</td><td><a href="#4465">4465</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>460</td><td><a href="#4469">4469</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>461</td><td><a href="#4473">4473</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>462</td><td><a href="#4484">4484</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>463</td><td><a href="#4487">4487</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>464</td><td><a href="#4526">4526</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>465</td><td><a href="#4532">4532</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>466</td><td><a href="#4540">4540</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>467</td><td><a href="#4540">4540(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>469</td><td><a href="#4548">4548</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>468</td><td><a href="#4548">4548</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>470</td><td><a href="#4552">4552</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>471</td><td><a href="#4556">4556</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>473</td><td><a href="#4561">4561</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>472</td><td><a href="#4561">4561</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>474</td><td><a href="#4567">4567</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>475</td><td><a href="#4567">4567(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>476</td><td><a href="#4586">4586</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>477</td><td><a href="#4586">4586</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>478</td><td><a href="#4587">4587</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>479</td><td><a href="#4587">4587</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>481</td><td><a href="#4592">4592</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>480</td><td><a href="#4592">4592</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>482</td><td><a href="#4596">4596</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>484</td><td><a href="#4604">4604</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>483</td><td><a href="#4604">4604</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>485</td><td><a href="#4614">4614</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>486</td><td><a href="#4623">4623</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>487</td><td><a href="#4627">4627</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>488</td><td><a href="#4668">4668</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>489</td><td><a href="#4674">4674</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>490</td><td><a href="#4682">4682</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>491</td><td><a href="#4682">4682(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>493</td><td><a href="#4690">4690</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>492</td><td><a href="#4690">4690</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>494</td><td><a href="#4694">4694</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>495</td><td><a href="#4698">4698</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>497</td><td><a href="#4706">4706</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>496</td><td><a href="#4706">4706</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>498</td><td><a href="#4714">4714</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>499</td><td><a href="#4714">4714(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>500</td><td><a href="#4736">4736</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>501</td><td><a href="#4740">4740</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>502</td><td><a href="#4761">4761</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>503</td><td><a href="#4762">4762</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>505</td><td><a href="#4764">4764</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>506</td><td><a href="#4764">4764</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>504</td><td><a href="#4764">4764</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>507</td><td><a href="#4764">4764</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>508</td><td><a href="#4764">4764(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>509</td><td><a href="#4764">4764</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>510</td><td><a href="#4778">4778</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>511</td><td><a href="#4779">4779</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>513</td><td><a href="#4781">4781</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>514</td><td><a href="#4781">4781</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>512</td><td><a href="#4781">4781</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>515</td><td><a href="#4781">4781</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>516</td><td><a href="#4781">4781(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>517</td><td><a href="#4781">4781</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>518</td><td><a href="#4794">4794</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>519</td><td><a href="#4795">4795</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>521</td><td><a href="#4797">4797</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>522</td><td><a href="#4797">4797</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>520</td><td><a href="#4797">4797</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>523</td><td><a href="#4797">4797</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>524</td><td><a href="#4797">4797(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>525</td><td><a href="#4809">4809</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>526</td><td><a href="#4810">4810</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>527</td><td><a href="#4812">4812</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>528</td><td><a href="#4812">4812(1)</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>529</td><td><a href="#4830">4830</a></td><td>Remove method call</td><td><img src="detected.png"/></td></tr>
<tr><td>530</td><td><a href="#4831">4831</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>531</td><td><a href="#4832">4832</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>532</td><td><a href="#4836">4836</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>533</td><td><a href="#4930">4930</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>534</td><td><a href="#4930">4930(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>536</td><td><a href="#4932">4932</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>535</td><td><a href="#4932">4932</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>537</td><td><a href="#4935">4935</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>538</td><td><a href="#4938">4938</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>539</td><td><a href="#4938">4938(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>540</td><td><a href="#4942">4942</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>541</td><td><a href="#4950">4950</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>542</td><td><a href="#4950">4950(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>544</td><td><a href="#4951">4951</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>543</td><td><a href="#4951">4951</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>545</td><td><a href="#4954">4954</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>546</td><td><a href="#4957">4957</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>547</td><td><a href="#4957">4957(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>548</td><td><a href="#4961">4961</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>549</td><td><a href="#4982">4982</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>550</td><td><a href="#4982">4982(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>551</td><td><a href="#4982">4982(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>552</td><td><a href="#4982">4982(3)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>553</td><td><a href="#4982">4982(4)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>554</td><td><a href="#4982">4982(5)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>555</td><td><a href="#4982">4982(6)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>556</td><td><a href="#4982">4982(7)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>557</td><td><a href="#4982">4982(8)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>558</td><td><a href="#4982">4982(9)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>559</td><td><a href="#4982">4982(10)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>560</td><td><a href="#4982">4982(11)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>561</td><td><a href="#4994">4994</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>563</td><td><a href="#4996">4996</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>562</td><td><a href="#4996">4996</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>567</td><td><a href="#4998">4998</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>568</td><td><a href="#4998">4998</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>566</td><td><a href="#4998">4998</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>569</td><td><a href="#4998">4998</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>564</td><td><a href="#4998">4998</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>565</td><td><a href="#4998">4998(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>570</td><td><a href="#4999">4999</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>571</td><td><a href="#4999">4999(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>572</td><td><a href="#4999">4999(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>574</td><td><a href="#5002">5002</a></td><td>Negate jump condition</td><td><img src="not_detected.png"/></td></tr>
<tr><td>573</td><td><a href="#5002">5002</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>578</td><td><a href="#5004">5004</a></td><td>Constant +1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>579</td><td><a href="#5004">5004</a></td><td>Constant -1</td><td><img src="not_detected.png"/></td></tr>
<tr><td>577</td><td><a href="#5004">5004</a></td><td>Replace Constant by 0</td><td><img src="not_detected.png"/></td></tr>
<tr><td>580</td><td><a href="#5004">5004</a></td><td>Replace arithmetic operator</td><td><img src="not_detected.png"/></td></tr>
<tr><td>575</td><td><a href="#5004">5004</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>576</td><td><a href="#5004">5004(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>581</td><td><a href="#5005">5005</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>582</td><td><a href="#5005">5005(1)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>583</td><td><a href="#5005">5005(2)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
<tr><td>584</td><td><a href="#5005">5005(3)</a></td><td>Remove method call</td><td><img src="not_detected.png"/></td></tr>
</table>
</body>
</html>